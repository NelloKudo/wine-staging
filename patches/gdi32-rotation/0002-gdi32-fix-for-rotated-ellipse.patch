From fdc9d34400af31765d20ca7b070e53d7eec710e4 Mon Sep 17 00:00:00 2001
From: Daniel Wendt <daniel.wendt@linux.com>
Date: Tue, 10 Dec 2013 14:55:32 +0100
Subject: [PATCH] gdi32: fix for rotated ellipse

Bug: http://bugs.winehq.org/show_bug.cgi?id=35331
---
 dlls/win32u/dibdrv/graphics.c | 63 ++++++++++++++++++++++++-----------
 1 file changed, 44 insertions(+), 19 deletions(-)

diff --git a/dlls/win32u/dibdrv/graphics.c b/dlls/win32u/dibdrv/graphics.c
index 21d2eabbc9e..1eeea1d68ea 100644
--- a/dlls/win32u/dibdrv/graphics.c
+++ b/dlls/win32u/dibdrv/graphics.c
@@ -1531,10 +1531,28 @@ BOOL dibdrv_RoundRect( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
     DC *dc = get_physdev_dc( dev );
     RECT rect;
     POINT pt[2], *points;
-    int i, end, count;
+    int i, end;
+    ULONG count;
     BOOL ret = TRUE;
     HRGN outline = 0, interior = 0;
 
+    BOOL exclude_rotation_translation = FALSE;
+    XFORM old;
+    XFORM rotation_and_translation;
+
+    if (dc->attr->graphics_mode == GM_ADVANCED)
+    {
+        XFORM xf;
+        NtGdiGetTransform( pdev->dev.hdc, 0x203, &old );
+        xf = old;
+        if (xform_has_rotate_and_uniform_scale_and_shear( &xf ) &&
+            xform_decompose_rotation_and_translation( &xf, &rotation_and_translation ))
+        {
+            NtGdiModifyWorldTransform( pdev->dev.hdc, &xf, MWT_SET );
+            exclude_rotation_translation = TRUE;
+        }
+    }
+
     if (!get_pen_device_rect( dc, pdev, &rect, left, top, right, bottom )) return TRUE;
 
     pt[0].x = pt[0].y = 0;
@@ -1555,23 +1573,6 @@ BOOL dibdrv_RoundRect( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
         return FALSE;
     }
 
-    if (pdev->brush.style != BS_NULL &&
-        !(interior = NtGdiCreateRoundRectRgn( rect.left, rect.top, rect.right + 1, rect.bottom + 1,
-                                              ellipse_width, ellipse_height )))
-    {
-        free( points );
-        if (outline) NtGdiDeleteObjectApp( outline );
-        return FALSE;
-    }
-
-    /* if not using a region, paint the interior first so the outline can overlap it */
-    if (interior && !outline)
-    {
-        ret = brush_region( pdev, interior );
-        NtGdiDeleteObjectApp( interior );
-        interior = 0;
-    }
-
     count = ellipse_first_quadrant( ellipse_width, ellipse_height, points );
 
     if (dc->attr->arc_direction == AD_CLOCKWISE)
@@ -1615,13 +1616,37 @@ BOOL dibdrv_RoundRect( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
     }
     count = end + 1;
 
+    if (exclude_rotation_translation == TRUE)
+    {
+        NtGdiModifyWorldTransform( pdev->dev.hdc, &rotation_and_translation, MWT_SET );
+        /* apply rotation and translation to calculated points */
+        NtGdiTransformPoints( dev->hdc, points, points, count, NtGdiLPtoDP );
+        /* restore origin matrix */
+        NtGdiModifyWorldTransform( pdev->dev.hdc, &old, MWT_SET );
+    }
+
+    if (pdev->brush.style != BS_NULL &&
+        !(interior = ULongToHandle(NtGdiPolyPolyDraw( ULongToHandle(ALTERNATE), points, &count, 1, NtGdiPolyPolygonRgn ))))
+    {
+        free( points );
+        if (outline) NtGdiDeleteObjectApp( outline );
+            return FALSE;
+    }
+
+    /* if not using a region, paint the interior first so the outline can overlap it */
+    if (interior && !outline)
+    {
+        ret = brush_region( pdev, interior );
+        NtGdiDeleteObjectApp( interior );
+        interior = 0;
+    }
+
     reset_dash_origin( pdev );
     pdev->pen_lines( pdev, count, points, TRUE, outline );
     add_pen_lines_bounds( pdev, count, points, outline );
 
     if (interior)
     {
-        NtGdiCombineRgn( interior, interior, outline, RGN_DIFF );
         ret = brush_region( pdev, interior );
         NtGdiDeleteObjectApp( interior );
     }
-- 
2.43.0

