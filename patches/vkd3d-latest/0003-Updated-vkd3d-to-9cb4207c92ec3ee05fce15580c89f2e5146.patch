From b7ab480481541737db8e9b5514bc0e52309211c9 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 10 Oct 2024 07:16:15 +1100
Subject: [PATCH] Updated vkd3d to 9cb4207c92ec3ee05fce15580c89f2e5146354db.

---
 libs/vkd3d/libs/vkd3d-shader/dxil.c           |  15 +++
 libs/vkd3d/libs/vkd3d-shader/glsl.c           | 101 ++++++++++++++++--
 libs/vkd3d/libs/vkd3d-shader/ir.c             |  40 +++++++
 libs/vkd3d/libs/vkd3d-shader/spirv.c          |  24 ++---
 libs/vkd3d/libs/vkd3d-shader/tpf.c            |  15 +++
 .../libs/vkd3d-shader/vkd3d_shader_main.c     |   2 +
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |   1 +
 7 files changed, 173 insertions(+), 25 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index c66b059325a..5db9d6da063 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -10315,6 +10315,21 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, struct vsir_pro
     sm6->ptr = &sm6->start[1];
     sm6->bitpos = 2;
 
+    switch (program->shader_version.type)
+    {
+        case VKD3D_SHADER_TYPE_HULL:
+        case VKD3D_SHADER_TYPE_DOMAIN:
+            break;
+
+        default:
+            if (program->patch_constant_signature.element_count != 0)
+            {
+                WARN("The patch constant signature only makes sense for Hull and Domain Shaders, ignoring it.\n");
+                shader_signature_cleanup(&program->patch_constant_signature);
+            }
+            break;
+    }
+
     input_signature = &program->input_signature;
     output_signature = &program->output_signature;
     patch_constant_signature = &program->patch_constant_signature;
diff --git a/libs/vkd3d/libs/vkd3d-shader/glsl.c b/libs/vkd3d/libs/vkd3d-shader/glsl.c
index 4dc95899a11..91ee355ed39 100644
--- a/libs/vkd3d/libs/vkd3d-shader/glsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/glsl.c
@@ -651,6 +651,20 @@ static void shader_glsl_cast(struct vkd3d_glsl_generator *gen, const struct vkd3
     glsl_dst_cleanup(&dst, &gen->string_buffers);
 }
 
+static void shader_glsl_end_block(struct vkd3d_glsl_generator *gen)
+{
+    --gen->indent;
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "}\n");
+}
+
+static void shader_glsl_begin_block(struct vkd3d_glsl_generator *gen)
+{
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "{\n");
+    ++gen->indent;
+}
+
 static void shader_glsl_if(struct vkd3d_glsl_generator *gen, const struct vkd3d_shader_instruction *ins)
 {
     const char *condition;
@@ -664,23 +678,65 @@ static void shader_glsl_if(struct vkd3d_glsl_generator *gen, const struct vkd3d_
 
     glsl_src_cleanup(&src, &gen->string_buffers);
 
-    shader_glsl_print_indent(gen->buffer, gen->indent);
-    vkd3d_string_buffer_printf(gen->buffer, "{\n");
-    ++gen->indent;
+    shader_glsl_begin_block(gen);
 }
 
 static void shader_glsl_else(struct vkd3d_glsl_generator *gen, const struct vkd3d_shader_instruction *ins)
 {
-    unsigned int i = 4 * (gen->indent - 1);
+    shader_glsl_end_block(gen);
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "else\n");
+    shader_glsl_begin_block(gen);
+}
 
-    vkd3d_string_buffer_printf(gen->buffer, "%*s}\n%*selse\n%*s{\n", i, "", i, "", i, "");
+static void shader_glsl_loop(struct vkd3d_glsl_generator *gen)
+{
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "for (;;)\n");
+    shader_glsl_begin_block(gen);
 }
 
-static void shader_glsl_endif(struct vkd3d_glsl_generator *gen)
+static void shader_glsl_break(struct vkd3d_glsl_generator *gen)
 {
-    --gen->indent;
     shader_glsl_print_indent(gen->buffer, gen->indent);
-    vkd3d_string_buffer_printf(gen->buffer, "}\n");
+    vkd3d_string_buffer_printf(gen->buffer, "break;\n");
+}
+
+static void shader_glsl_continue(struct vkd3d_glsl_generator *gen)
+{
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "continue;\n");
+}
+
+static void shader_glsl_switch(struct vkd3d_glsl_generator *gen, const struct vkd3d_shader_instruction *ins)
+{
+    struct glsl_src src;
+
+    glsl_src_init(&src, gen, &ins->src[0], VKD3DSP_WRITEMASK_0);
+
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "switch (%s)\n", src.str->buffer);
+    shader_glsl_begin_block(gen);
+
+    glsl_src_cleanup(&src, &gen->string_buffers);
+}
+
+static void shader_glsl_case(struct vkd3d_glsl_generator *gen, const struct vkd3d_shader_instruction *ins)
+{
+    struct glsl_src src;
+
+    glsl_src_init(&src, gen, &ins->src[0], VKD3DSP_WRITEMASK_0);
+
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "case %s:\n", src.str->buffer);
+
+    glsl_src_cleanup(&src, &gen->string_buffers);
+}
+
+static void shader_glsl_default(struct vkd3d_glsl_generator *gen)
+{
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "default:\n");
 }
 
 static void shader_glsl_ld(struct vkd3d_glsl_generator *gen, const struct vkd3d_shader_instruction *ins)
@@ -1013,6 +1069,9 @@ static void shader_glsl_shader_prologue(struct vkd3d_glsl_generator *gen)
                     case VKD3D_SHADER_COMPONENT_UINT:
                         vkd3d_string_buffer_printf(buffer, " = uintBitsToFloat(shader_in_%u)", i);
                         break;
+                    case VKD3D_SHADER_COMPONENT_INT:
+                        vkd3d_string_buffer_printf(buffer, " = intBitsToFloat(shader_in_%u)", i);
+                        break;
                     default:
                         vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
                                 "Internal compiler error: Unhandled input component type %#x.", e->component_type);
@@ -1127,6 +1186,15 @@ static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *gen,
         case VKD3DSIH_AND:
             shader_glsl_binop(gen, ins, "&");
             break;
+        case VKD3DSIH_BREAK:
+            shader_glsl_break(gen);
+            break;
+        case VKD3DSIH_CASE:
+            shader_glsl_case(gen, ins);
+            break;
+        case VKD3DSIH_CONTINUE:
+            shader_glsl_continue(gen);
+            break;
         case VKD3DSIH_DCL_INDEXABLE_TEMP:
             shader_glsl_dcl_indexable_temp(gen, ins);
             break;
@@ -1138,6 +1206,9 @@ static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *gen,
         case VKD3DSIH_DCL_OUTPUT_SIV:
         case VKD3DSIH_NOP:
             break;
+        case VKD3DSIH_DEFAULT:
+            shader_glsl_default(gen);
+            break;
         case VKD3DSIH_DIV:
             shader_glsl_binop(gen, ins, "/");
             break;
@@ -1154,7 +1225,9 @@ static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *gen,
             shader_glsl_else(gen, ins);
             break;
         case VKD3DSIH_ENDIF:
-            shader_glsl_endif(gen);
+        case VKD3DSIH_ENDLOOP:
+        case VKD3DSIH_ENDSWITCH:
+            shader_glsl_end_block(gen);
             break;
         case VKD3DSIH_EQO:
         case VKD3DSIH_IEQ:
@@ -1184,6 +1257,7 @@ static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *gen,
             break;
         case VKD3DSIH_ILT:
         case VKD3DSIH_LTO:
+        case VKD3DSIH_ULT:
             shader_glsl_relop(gen, ins, "<", "lessThan");
             break;
         case VKD3DSIH_IMAX:
@@ -1220,6 +1294,9 @@ static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *gen,
         case VKD3DSIH_LOG:
             shader_glsl_intrinsic(gen, ins, "log2");
             break;
+        case VKD3DSIH_LOOP:
+            shader_glsl_loop(gen);
+            break;
         case VKD3DSIH_MOV:
             shader_glsl_mov(gen, ins);
             break;
@@ -1259,6 +1336,9 @@ static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *gen,
         case VKD3DSIH_SQRT:
             shader_glsl_intrinsic(gen, ins, "sqrt");
             break;
+        case VKD3DSIH_SWITCH:
+            shader_glsl_switch(gen, ins);
+            break;
         default:
             shader_glsl_unhandled(gen, ins);
             break;
@@ -1663,6 +1743,9 @@ static void shader_glsl_generate_input_declarations(struct vkd3d_glsl_generator
                 case VKD3D_SHADER_COMPONENT_UINT:
                     vkd3d_string_buffer_printf(buffer, "uvec4");
                     break;
+                case VKD3D_SHADER_COMPONENT_INT:
+                    vkd3d_string_buffer_printf(buffer, "ivec4");
+                    break;
                 case VKD3D_SHADER_COMPONENT_FLOAT:
                     vkd3d_string_buffer_printf(buffer, "vec4");
                     break;
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index 14cf23e8d1a..affbae3ea4e 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -6505,6 +6505,30 @@ static bool vsir_validate_src_max_count(struct validation_context *ctx,
     return true;
 }
 
+static void vsir_validate_signature_element(struct validation_context *ctx,
+        const struct shader_signature *signature, const char *signature_type,
+        unsigned int idx)
+{
+    const struct signature_element *element = &signature->elements[idx];
+
+    if (element->register_count == 0)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                "element %u of %s signature: Invalid zero register count.", idx, signature_type);
+
+    if (element->mask == 0 || (element->mask & ~0xf))
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                "element %u of %s signature: Invalid mask %#x.", idx, signature_type, element->mask);
+}
+
+static void vsir_validate_signature(struct validation_context *ctx,
+        const struct shader_signature *signature, const char *signature_type)
+{
+    unsigned int i;
+
+    for (i = 0; i < signature->element_count; ++i)
+        vsir_validate_signature_element(ctx, signature, signature_type, i);
+}
+
 static const char *name_from_cf_type(enum vsir_control_flow_type type)
 {
     switch (type)
@@ -7042,6 +7066,22 @@ enum vkd3d_result vsir_program_validate(struct vsir_program *program, uint64_t c
     if (!(config_flags & VKD3D_SHADER_CONFIG_FLAG_FORCE_VALIDATION))
         return VKD3D_OK;
 
+    switch (program->shader_version.type)
+    {
+        case VKD3D_SHADER_TYPE_HULL:
+        case VKD3D_SHADER_TYPE_DOMAIN:
+            break;
+
+        default:
+            if (program->patch_constant_signature.element_count != 0)
+                validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                        "Patch constant signature is only valid for hull and domain shaders.");
+    }
+
+    vsir_validate_signature(&ctx, &program->input_signature, "input");
+    vsir_validate_signature(&ctx, &program->output_signature, "output");
+    vsir_validate_signature(&ctx, &program->patch_constant_signature, "patch constant");
+
     if (!(ctx.temps = vkd3d_calloc(ctx.program->temp_count, sizeof(*ctx.temps))))
         goto fail;
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index cb610c929b6..692432d5513 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -3267,18 +3267,6 @@ static void spirv_compiler_emit_register_debug_name(struct vkd3d_spirv_builder *
         vkd3d_spirv_build_op_name(builder, id, "%s", debug_name);
 }
 
-static uint32_t spirv_compiler_emit_variable(struct spirv_compiler *compiler,
-        struct vkd3d_spirv_stream *stream, SpvStorageClass storage_class,
-        enum vkd3d_shader_component_type component_type, unsigned int component_count)
-{
-    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    uint32_t type_id, ptr_type_id;
-
-    type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
-    ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, storage_class, type_id);
-    return vkd3d_spirv_build_op_variable(builder, stream, ptr_type_id, storage_class, 0);
-}
-
 static uint32_t spirv_compiler_emit_array_variable(struct spirv_compiler *compiler,
         struct vkd3d_spirv_stream *stream, SpvStorageClass storage_class,
         enum vkd3d_shader_component_type component_type, unsigned int component_count,
@@ -3288,10 +3276,6 @@ static uint32_t spirv_compiler_emit_array_variable(struct spirv_compiler *compil
     uint32_t type_id, length_id, ptr_type_id;
     unsigned int i;
 
-    if (!length_count)
-        return spirv_compiler_emit_variable(compiler,
-                stream, storage_class, component_type, component_count);
-
     type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
     for (i = 0; i < length_count; ++i)
     {
@@ -3305,6 +3289,14 @@ static uint32_t spirv_compiler_emit_array_variable(struct spirv_compiler *compil
     return vkd3d_spirv_build_op_variable(builder, stream, ptr_type_id, storage_class, 0);
 }
 
+static uint32_t spirv_compiler_emit_variable(struct spirv_compiler *compiler,
+        struct vkd3d_spirv_stream *stream, SpvStorageClass storage_class,
+        enum vkd3d_shader_component_type component_type, unsigned int component_count)
+{
+    return spirv_compiler_emit_array_variable(compiler, stream, storage_class,
+            component_type, component_count, NULL, 0);
+}
+
 static const struct vkd3d_spec_constant_info
 {
     enum vkd3d_shader_parameter_name name;
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index 75bdb06fe0e..f79e97e92d4 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -2914,6 +2914,21 @@ int tpf_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t con
     if (program->shader_version.type == VKD3D_SHADER_TYPE_HULL)
         uninvert_used_masks(&program->patch_constant_signature);
 
+    switch (program->shader_version.type)
+    {
+        case VKD3D_SHADER_TYPE_HULL:
+        case VKD3D_SHADER_TYPE_DOMAIN:
+            break;
+
+        default:
+            if (program->patch_constant_signature.element_count != 0)
+            {
+                WARN("The patch constant signature only makes sense for Hull and Domain Shaders, ignoring it.\n");
+                shader_signature_cleanup(&program->patch_constant_signature);
+            }
+            break;
+    }
+
     if (!shader_sm4_parser_validate_signature(&sm4, &program->input_signature,
             sm4.input_register_masks, "Input")
             || !shader_sm4_parser_validate_signature(&sm4, &program->output_signature,
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index 9b320106340..f84ac551272 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -1846,6 +1846,8 @@ void shader_signature_cleanup(struct shader_signature *signature)
     }
     vkd3d_free(signature->elements);
     signature->elements = NULL;
+    signature->elements_capacity = 0;
+    signature->element_count = 0;
 }
 
 int vkd3d_shader_parse_input_signature(const struct vkd3d_shader_code *dxbc,
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index 1a42f385fc0..41b879af4b4 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -245,6 +245,7 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_VSIR_INVALID_GS                  = 9019,
     VKD3D_SHADER_ERROR_VSIR_INVALID_PARAMETER           = 9020,
     VKD3D_SHADER_ERROR_VSIR_MISSING_SEMANTIC            = 9021,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE           = 9022,
 
     VKD3D_SHADER_WARNING_VSIR_DYNAMIC_DESCRIPTOR_ARRAY  = 9300,
 
-- 
2.45.2

