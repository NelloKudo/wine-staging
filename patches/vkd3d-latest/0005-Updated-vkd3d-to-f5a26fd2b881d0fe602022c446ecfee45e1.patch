From 9520c6e767ef9d5e1c1024f56a20383c5692078b Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 15 May 2025 06:43:50 +1000
Subject: [PATCH] Updated vkd3d to f5a26fd2b881d0fe602022c446ecfee45e1252b3.

---
 libs/vkd3d/include/private/vkd3d_version.h    |  2 +-
 libs/vkd3d/include/vkd3d_shader.h             |  5 +++
 libs/vkd3d/libs/vkd3d-shader/hlsl.c           | 43 +++++++++++++++++++
 libs/vkd3d/libs/vkd3d-shader/hlsl.h           |  4 ++
 libs/vkd3d/libs/vkd3d-shader/hlsl.y           | 14 ++++--
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c   | 42 ++++++------------
 .../libs/vkd3d-shader/hlsl_constant_ops.c     |  9 ++--
 libs/vkd3d/libs/vkd3d-shader/ir.c             | 10 ++++-
 libs/vkd3d/libs/vkd3d-shader/spirv.c          | 14 +++---
 9 files changed, 92 insertions(+), 51 deletions(-)

diff --git a/libs/vkd3d/include/private/vkd3d_version.h b/libs/vkd3d/include/private/vkd3d_version.h
index fb2e2f11f8b..f71f90e6b78 100644
--- a/libs/vkd3d/include/private/vkd3d_version.h
+++ b/libs/vkd3d/include/private/vkd3d_version.h
@@ -1 +1 @@
-#define VKD3D_VCS_ID " (git 4289ec60)"
+#define VKD3D_VCS_ID " (git f5a26fd2)"
diff --git a/libs/vkd3d/include/vkd3d_shader.h b/libs/vkd3d/include/vkd3d_shader.h
index 6b2805e8759..1b7bdd196bb 100644
--- a/libs/vkd3d/include/vkd3d_shader.h
+++ b/libs/vkd3d/include/vkd3d_shader.h
@@ -2740,6 +2740,10 @@ VKD3D_SHADER_API const enum vkd3d_shader_target_type *vkd3d_shader_get_supported
  * source code or byte code.
  *
  * This version of vkd3d-shader supports the following transformations:
+ * - VKD3D_SHADER_SOURCE_DXBC_DXIL to VKD3D_SHADER_TARGET_SPIRV_BINARY
+ * - VKD3D_SHADER_SOURCE_DXBC_DXIL to VKD3D_SHADER_TARGET_SPIRV_TEXT
+ *   (if vkd3d was compiled with SPIRV-Tools)
+ * - VKD3D_SHADER_SOURCE_DXBC_DXIL to VKD3D_SHADER_TARGET_D3D_ASM
  * - VKD3D_SHADER_SOURCE_DXBC_TPF to VKD3D_SHADER_TARGET_SPIRV_BINARY
  * - VKD3D_SHADER_SOURCE_DXBC_TPF to VKD3D_SHADER_TARGET_SPIRV_TEXT
  *   (if vkd3d was compiled with SPIRV-Tools)
@@ -2952,6 +2956,7 @@ VKD3D_SHADER_API int vkd3d_shader_convert_root_signature(struct vkd3d_shader_ver
  * VKD3D_SHADER_RESOURCE_DATA_FLOAT.)
  *
  * Currently this function supports the following code types:
+ * - VKD3D_SHADER_SOURCE_DXBC_DXIL
  * - VKD3D_SHADER_SOURCE_DXBC_TPF
  * - VKD3D_SHADER_SOURCE_D3D_BYTECODE
  *
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 36c79f4c076..653ddd2e8be 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -319,6 +319,28 @@ bool hlsl_type_is_shader(const struct hlsl_type *type)
     return false;
 }
 
+bool hlsl_type_is_minimum_precision(const struct hlsl_type *type)
+{
+    if (!hlsl_is_numeric_type(type))
+        return false;
+
+    switch (type->e.numeric.type)
+    {
+        case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_DOUBLE:
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_HALF:
+        case HLSL_TYPE_INT:
+        case HLSL_TYPE_UINT:
+            return false;
+
+        case HLSL_TYPE_MIN16UINT:
+            return true;
+    }
+
+    vkd3d_unreachable();
+}
+
 bool hlsl_type_is_patch_array(const struct hlsl_type *type)
 {
     return type->class == HLSL_CLASS_ARRAY && (type->e.array.array_type == HLSL_ARRAY_PATCH_INPUT
@@ -350,6 +372,27 @@ bool hlsl_base_type_is_integer(enum hlsl_base_type type)
     vkd3d_unreachable();
 }
 
+bool hlsl_type_is_signed_integer(const struct hlsl_type *type)
+{
+    VKD3D_ASSERT(hlsl_is_numeric_type(type));
+
+    switch (type->e.numeric.type)
+    {
+        case HLSL_TYPE_INT:
+            return true;
+
+        case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_DOUBLE:
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_HALF:
+        case HLSL_TYPE_MIN16UINT:
+        case HLSL_TYPE_UINT:
+            return false;
+    }
+
+    vkd3d_unreachable();
+}
+
 bool hlsl_type_is_integer(const struct hlsl_type *type)
 {
     VKD3D_ASSERT(hlsl_is_numeric_type(type));
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index 9eb86534f81..58f579cd9f9 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -234,6 +234,8 @@ struct hlsl_type
     /* Offset where the type's description starts in the output bytecode, in bytes. */
     size_t bytecode_offset;
 
+    bool is_typedef;
+
     uint32_t is_minimum_precision : 1;
 };
 
@@ -1771,10 +1773,12 @@ unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_ty
 bool hlsl_type_is_integer(const struct hlsl_type *type);
 bool hlsl_type_is_floating_point(const struct hlsl_type *type);
 bool hlsl_type_is_row_major(const struct hlsl_type *type);
+bool hlsl_type_is_signed_integer(const struct hlsl_type *type);
 unsigned int hlsl_type_minor_size(const struct hlsl_type *type);
 unsigned int hlsl_type_major_size(const struct hlsl_type *type);
 unsigned int hlsl_type_element_count(const struct hlsl_type *type);
 bool hlsl_type_is_integer(const struct hlsl_type *type);
+bool hlsl_type_is_minimum_precision(const struct hlsl_type *type);
 bool hlsl_type_is_resource(const struct hlsl_type *type);
 bool hlsl_type_is_shader(const struct hlsl_type *type);
 bool hlsl_type_is_patch_array(const struct hlsl_type *type);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index 24c7ae6b00b..5aee1e701cd 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -1183,6 +1183,7 @@ static bool add_typedef(struct hlsl_ctx *ctx, struct hlsl_type *const orig_type,
 
         vkd3d_free((void *)type->name);
         type->name = v->name;
+        type->is_typedef = true;
 
         ret = hlsl_scope_add_type(ctx->cur_scope, type);
         if (!ret)
@@ -3189,6 +3190,11 @@ static bool elementwise_intrinsic_uint_convert_args(struct hlsl_ctx *ctx,
 static bool intrinsic_abs(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
+    const struct hlsl_type *type = params->args[0]->data_type;
+
+    if (!hlsl_type_is_floating_point(type) && !hlsl_type_is_signed_integer(type))
+        return true;
+
     return !!add_unary_arithmetic_expr(ctx, params->instrs, HLSL_OP1_ABS, params->args[0], loc);
 }
 
@@ -8177,14 +8183,14 @@ type_no_void:
     | TYPE_IDENTIFIER
         {
             $$ = hlsl_get_type(ctx->cur_scope, $1, true, true);
-            if ($$->is_minimum_precision)
+            if ($$->is_minimum_precision || hlsl_type_is_minimum_precision($$))
             {
                 if (hlsl_version_lt(ctx, 4, 0))
                 {
                     hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                             "Target profile doesn't support minimum-precision types.");
                 }
-                else
+                else if ($$->is_minimum_precision)
                 {
                     FIXME("Reinterpreting type %s.\n", $$->name);
                 }
@@ -8214,8 +8220,8 @@ type_no_void:
     | KW_STRUCT TYPE_IDENTIFIER
         {
             $$ = hlsl_get_type(ctx->cur_scope, $2, true, true);
-            if ($$->class != HLSL_CLASS_STRUCT)
-                hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_REDEFINED, "\"%s\" redefined as a structure.", $2);
+            if ($$->class != HLSL_CLASS_STRUCT || $$->is_typedef)
+                hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_REDEFINED, "\"%s\" is not a structure.", $2);
             vkd3d_free($2);
         }
     | KW_RENDERTARGETVIEW
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index 9c3affda534..38d5c55c26b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -7154,7 +7154,7 @@ struct hlsl_reg hlsl_reg_from_deref(struct hlsl_ctx *ctx, const struct hlsl_dere
 }
 
 static bool get_integral_argument_value(struct hlsl_ctx *ctx, const struct hlsl_attribute *attr,
-        unsigned int i, enum hlsl_base_type *base_type, int *value)
+        unsigned int i, int *value)
 {
     const struct hlsl_ir_node *instr = attr->args[i].node;
     const struct hlsl_type *type = instr->data_type;
@@ -7178,7 +7178,6 @@ static bool get_integral_argument_value(struct hlsl_ctx *ctx, const struct hlsl_
         return false;
     }
 
-    *base_type = type->e.numeric.type;
     *value = hlsl_ir_constant(instr)->value.u[0].i;
     return true;
 }
@@ -7205,6 +7204,7 @@ static const char *get_string_argument_value(struct hlsl_ctx *ctx, const struct
 
 static void parse_numthreads_attribute(struct hlsl_ctx *ctx, const struct hlsl_attribute *attr)
 {
+    static const unsigned int limits[3] = {1024, 1024, 64};
     unsigned int i;
 
     ctx->found_numthreads = 1;
@@ -7218,18 +7218,21 @@ static void parse_numthreads_attribute(struct hlsl_ctx *ctx, const struct hlsl_a
 
     for (i = 0; i < attr->args_count; ++i)
     {
-        enum hlsl_base_type base_type;
         int value;
 
-        if (!get_integral_argument_value(ctx, attr, i, &base_type, &value))
+        if (!get_integral_argument_value(ctx, attr, i, &value))
             return;
 
-        if ((base_type == HLSL_TYPE_INT && value <= 0) || (base_type == HLSL_TYPE_UINT && !value))
+        if (value < 1 || value > limits[i])
             hlsl_error(ctx, &attr->args[i].node->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_THREAD_COUNT,
-                    "Thread count must be a positive integer.");
+                    "Dimension %u of the thread count must be between 1 and %u.", i, limits[i]);
 
         ctx->thread_count[i] = value;
     }
+
+    if (ctx->thread_count[0] * ctx->thread_count[1] * ctx->thread_count[2] > 1024)
+        hlsl_error(ctx, &attr->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_THREAD_COUNT,
+                "Product of thread count parameters cannot exceed 1024.");
 }
 
 static void parse_domain_attribute(struct hlsl_ctx *ctx, const struct hlsl_attribute *attr)
@@ -7260,7 +7263,6 @@ static void parse_domain_attribute(struct hlsl_ctx *ctx, const struct hlsl_attri
 
 static void parse_outputcontrolpoints_attribute(struct hlsl_ctx *ctx, const struct hlsl_attribute *attr)
 {
-    enum hlsl_base_type base_type;
     int value;
 
     if (attr->args_count != 1)
@@ -7270,7 +7272,7 @@ static void parse_outputcontrolpoints_attribute(struct hlsl_ctx *ctx, const stru
         return;
     }
 
-    if (!get_integral_argument_value(ctx, attr, 0, &base_type, &value))
+    if (!get_integral_argument_value(ctx, attr, 0, &value))
         return;
 
     if (value < 0 || value > 32)
@@ -7373,7 +7375,6 @@ static void parse_patchconstantfunc_attribute(struct hlsl_ctx *ctx, const struct
 
 static void parse_maxvertexcount_attribute(struct hlsl_ctx *ctx, const struct hlsl_attribute *attr)
 {
-    enum hlsl_base_type base_type;
     int value;
 
     if (attr->args_count != 1)
@@ -7383,7 +7384,7 @@ static void parse_maxvertexcount_attribute(struct hlsl_ctx *ctx, const struct hl
         return;
     }
 
-    if (!get_integral_argument_value(ctx, attr, 0, &base_type, &value))
+    if (!get_integral_argument_value(ctx, attr, 0, &value))
         return;
 
     if (value < 1 || value > 1024)
@@ -11838,25 +11839,6 @@ static void generate_vsir_scan_required_features(struct hlsl_ctx *ctx, struct vs
      * STENCIL_REF, and TYPED_UAV_LOAD_ADDITIONAL_FORMATS. */
 }
 
-static bool is_minimum_precision(enum hlsl_base_type type)
-{
-    switch (type)
-    {
-        case HLSL_TYPE_BOOL:
-        case HLSL_TYPE_DOUBLE:
-        case HLSL_TYPE_FLOAT:
-        case HLSL_TYPE_HALF:
-        case HLSL_TYPE_INT:
-        case HLSL_TYPE_UINT:
-            return false;
-
-        case HLSL_TYPE_MIN16UINT:
-            return true;
-    }
-
-    vkd3d_unreachable();
-}
-
 static void generate_vsir_scan_global_flags(struct hlsl_ctx *ctx,
         struct vsir_program *program, const struct hlsl_ir_function_decl *entry_func)
 {
@@ -11894,7 +11876,7 @@ static void generate_vsir_scan_global_flags(struct hlsl_ctx *ctx,
         /* Note that it doesn't matter if the semantic is unused or doesn't
          * generate a signature element (e.g. SV_DispatchThreadID). */
         if ((var->is_input_semantic || var->is_output_semantic)
-                && (type->is_minimum_precision || is_minimum_precision(type->e.numeric.type)))
+                && (type->is_minimum_precision || hlsl_type_is_minimum_precision(type)))
         {
             program->global_flags |= VKD3DSGF_ENABLE_MINIMUM_PRECISION;
             break;
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
index f74ecffcd4b..d339a06e6c7 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
@@ -51,14 +51,11 @@ static bool fold_abs(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
                     dst->u[k].i = abs(src->value.u[k].i);
                 break;
 
+            case HLSL_TYPE_BOOL:
             case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
-                dst->u[k].u = src->value.u[k].u;
-                break;
-
-            default:
-                FIXME("Fold abs() for type %s.\n", debug_hlsl_type(ctx, dst_type));
-                return false;
+                /* Should not occur. */
+                vkd3d_unreachable();
         }
     }
     return true;
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index 4101e92e91f..7466f7a2da1 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -862,12 +862,14 @@ static enum vkd3d_result vsir_program_lower_tex(struct vsir_program *program,
     }
     else if (tex->flags == VKD3DSI_TEXLD_BIAS)
     {
+        enum vkd3d_shader_swizzle_component w = vsir_swizzle_get_component(srcs[0].swizzle, 3);
+
         tex->opcode = VKD3DSIH_SAMPLE_B;
         tex->src = srcs;
         tex->src_count = 4;
 
         srcs[3] = tex->src[0];
-        srcs[3].swizzle = VKD3D_SHADER_SWIZZLE(W, W, W, W);
+        srcs[3].swizzle = vkd3d_shader_create_swizzle(w, w, w, w);
     }
     else
     {
@@ -2048,23 +2050,27 @@ static enum vkd3d_result shader_signature_map_patch_constant_index_ranges(struct
 
     for (i = 0; i < s->element_count; i += register_count)
     {
+        uint32_t used_mask;
+
         e = &s->elements[i];
         register_count = 1;
 
         if (!e->sysval_semantic)
             continue;
 
+        used_mask = e->used_mask;
         for (j = i + 1; j < s->element_count; ++j, ++register_count)
         {
             f = &s->elements[j];
             if (f->register_index != e->register_index + register_count || !sysval_semantics_should_merge(e, f))
                 break;
+            used_mask |= f->used_mask;
         }
         if (register_count < 2)
             continue;
 
         if ((ret = range_map_set_register_range(normaliser, range_map,
-                e->register_index, register_count, e->mask, e->used_mask, false)) < 0)
+                e->register_index, register_count, e->mask, used_mask, false)) < 0)
             return ret;
     }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index 6a393c5f35d..4297d656e51 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -5775,7 +5775,7 @@ static unsigned int shader_signature_next_location(const struct shader_signature
     return max_row;
 }
 
-static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
+static void spirv_compiler_emit_input(struct spirv_compiler *compiler,
         enum vkd3d_shader_register_type reg_type, unsigned int element_idx)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
@@ -5786,12 +5786,10 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     const struct vkd3d_spirv_builtin *builtin;
     enum vkd3d_shader_sysval_semantic sysval;
     uint32_t write_mask, reg_write_mask;
-    struct vkd3d_symbol *symbol = NULL;
     uint32_t val_id, input_id, var_id;
     uint32_t type_id, float_type_id;
     struct vkd3d_symbol reg_symbol;
     SpvStorageClass storage_class;
-    struct rb_entry *entry = NULL;
     bool use_private_var = false;
     unsigned int array_sizes[2];
 
@@ -5806,6 +5804,9 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     if (compiler->shader_type == VKD3D_SHADER_TYPE_DOMAIN && reg_type != VKD3DSPR_PATCHCONST)
         sysval = VKD3D_SHADER_SV_NONE;
 
+    if (!signature_element->used_mask)
+        return;
+
     builtin = get_spirv_builtin_for_sysval(compiler, sysval);
 
     array_sizes[0] = signature_element->register_count;
@@ -5846,7 +5847,7 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
 
     vkd3d_symbol_make_io(&reg_symbol, reg_type, element_idx);
 
-    if ((entry = rb_get(&compiler->symbol_table, &reg_symbol)))
+    if (rb_get(&compiler->symbol_table, &reg_symbol))
     {
         /* Except for vicp there should be one declaration per signature element. Sources of
          * duplicate declarations are: a single register split into multiple declarations having
@@ -5854,8 +5855,7 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
          * being repeated in another (i.e. vcp/vocp), which should have been deleted. */
         if (reg_type != VKD3DSPR_INPUT || !is_in_fork_or_join_phase(compiler))
             FIXME("Duplicate input definition found.\n");
-        symbol = RB_ENTRY_VALUE(entry, struct vkd3d_symbol, entry);
-        return symbol->id;
+        return;
     }
 
     if (builtin)
@@ -5927,8 +5927,6 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
 
         spirv_compiler_emit_store_reg(compiler, &dst_reg, signature_element->mask, val_id);
     }
-
-    return input_id;
 }
 
 static void spirv_compiler_emit_io_register(struct spirv_compiler *compiler,
-- 
2.47.2

