From cbe529eb436f19a2f0a8654fe6a49d6566c3e6a2 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 24 Apr 2024 09:05:20 +1000
Subject: [PATCH] Updated vkd3d to 46fca3f9f4a9b47b32e9dfbacda0f3d19536c02c.

---
 libs/vkd3d/include/private/vkd3d_common.h   |   2 +
 libs/vkd3d/libs/vkd3d-shader/d3dbc.c        |  12 +-
 libs/vkd3d/libs/vkd3d-shader/dxil.c         |   2 +-
 libs/vkd3d/libs/vkd3d-shader/fx.c           |  77 +++++++----
 libs/vkd3d/libs/vkd3d-shader/hlsl.c         |  44 +++++--
 libs/vkd3d/libs/vkd3d-shader/hlsl.h         |  12 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.y         |  32 +++--
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c |   5 +
 libs/vkd3d/libs/vkd3d-shader/ir.c           | 137 ++++++++++++++++----
 libs/vkd3d/libs/vkd3d-shader/tpf.c          |   5 +
 10 files changed, 248 insertions(+), 80 deletions(-)

diff --git a/libs/vkd3d/include/private/vkd3d_common.h b/libs/vkd3d/include/private/vkd3d_common.h
index 1da73bcfb2e..b0e9230dab6 100644
--- a/libs/vkd3d/include/private/vkd3d_common.h
+++ b/libs/vkd3d/include/private/vkd3d_common.h
@@ -340,6 +340,8 @@ static inline int vkd3d_u32_compare(uint32_t x, uint32_t y)
     return (x > y) - (x < y);
 }
 
+#define VKD3D_BITMAP_SIZE(x) (((x) + 0x1f) >> 5)
+
 static inline bool bitmap_clear(uint32_t *map, unsigned int idx)
 {
     return map[idx >> 5] &= ~(1u << (idx & 0x1f));
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index ace7694a59e..55d9ecf707d 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -216,7 +216,7 @@ struct vkd3d_shader_sm1_parser
     struct vkd3d_shader_parser p;
 
 #define MAX_CONSTANT_COUNT 8192
-    uint32_t constant_def_mask[3][MAX_CONSTANT_COUNT / 32];
+    uint32_t constant_def_mask[3][VKD3D_BITMAP_SIZE(MAX_CONSTANT_COUNT)];
 };
 
 /* This table is not order or position dependent. */
@@ -1517,6 +1517,11 @@ D3DXPARAMETER_CLASS hlsl_sm1_class(const struct hlsl_type *type)
         case HLSL_CLASS_STRING:
         case HLSL_CLASS_TEXTURE:
             return D3DXPC_OBJECT;
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
+        case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_VOID:
             break;
@@ -1614,6 +1619,11 @@ D3DXPARAMETER_TYPE hlsl_sm1_base_type(const struct hlsl_type *type)
         case HLSL_CLASS_STRING:
             return D3DXPT_STRING;
 
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
+        case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_VOID:
             break;
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index d07d5adee70..6a1fb6bddb7 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -805,7 +805,7 @@ struct sm6_parser
     struct vkd3d_shader_dst_param *output_params;
     struct vkd3d_shader_dst_param *input_params;
     struct vkd3d_shader_dst_param *patch_constant_params;
-    uint32_t io_regs_declared[(VKD3DSPR_COUNT + 0x1f) / 0x20];
+    uint32_t io_regs_declared[VKD3D_BITMAP_SIZE(VKD3DSPR_COUNT)];
 
     struct sm6_function *functions;
     size_t function_count;
diff --git a/libs/vkd3d/libs/vkd3d-shader/fx.c b/libs/vkd3d/libs/vkd3d-shader/fx.c
index 98443797543..168378e6b42 100644
--- a/libs/vkd3d/libs/vkd3d-shader/fx.c
+++ b/libs/vkd3d/libs/vkd3d-shader/fx.c
@@ -222,7 +222,7 @@ static bool technique_matches_version(const struct hlsl_ir_var *var, const struc
 {
     const struct hlsl_type *type = var->data_type;
 
-    if (type->base_type != HLSL_TYPE_TECHNIQUE)
+    if (type->class != HLSL_CLASS_TECHNIQUE)
         return false;
 
     return type->e.version >= fx->min_technique_version && type->e.version <= fx->max_technique_version;
@@ -353,8 +353,6 @@ static const char * get_fx_4_type_name(const struct hlsl_type *type)
     {
         [HLSL_TYPE_PIXELSHADER]      = "PixelShader",
         [HLSL_TYPE_VERTEXSHADER]     = "VertexShader",
-        [HLSL_TYPE_RENDERTARGETVIEW] = "RenderTargetView",
-        [HLSL_TYPE_DEPTHSTENCILVIEW] = "DepthStencilView",
     };
     static const char * const texture_type_names[] =
     {
@@ -380,19 +378,30 @@ static const char * get_fx_4_type_name(const struct hlsl_type *type)
         [HLSL_SAMPLER_DIM_STRUCTURED_BUFFER] = "RWStructuredBuffer",
     };
 
-    if (type->class == HLSL_CLASS_TEXTURE)
-        return texture_type_names[type->sampler_dim];
+    switch (type->class)
+    {
+        case HLSL_CLASS_TEXTURE:
+            return texture_type_names[type->sampler_dim];
 
-    if (type->class == HLSL_CLASS_UAV)
-        return uav_type_names[type->sampler_dim];
+        case HLSL_CLASS_UAV:
+            return uav_type_names[type->sampler_dim];
+
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+            return "DepthStencilView";
+
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
+            return "RenderTargetView";
+
+        case HLSL_CLASS_OBJECT:
+            switch (type->base_type)
+            {
+                case HLSL_TYPE_PIXELSHADER:
+                case HLSL_TYPE_VERTEXSHADER:
+                    return object_type_names[type->base_type];
+                default:
+                    return type->name;
+            }
 
-    switch (type->base_type)
-    {
-        case HLSL_TYPE_PIXELSHADER:
-        case HLSL_TYPE_VERTEXSHADER:
-        case HLSL_TYPE_RENDERTARGETVIEW:
-        case HLSL_TYPE_DEPTHSTENCILVIEW:
-            return object_type_names[type->base_type];
         default:
             return type->name;
     }
@@ -426,7 +435,9 @@ static uint32_t write_fx_4_type(const struct hlsl_type *type, struct fx_write_co
             put_u32_unaligned(buffer, 1);
             break;
 
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
         case HLSL_CLASS_OBJECT:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
             put_u32_unaligned(buffer, 2);
@@ -437,6 +448,9 @@ static uint32_t write_fx_4_type(const struct hlsl_type *type, struct fx_write_co
             break;
 
         case HLSL_CLASS_ARRAY:
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_TECHNIQUE:
             vkd3d_unreachable();
 
         case HLSL_CLASS_SAMPLER:
@@ -510,21 +524,25 @@ static uint32_t write_fx_4_type(const struct hlsl_type *type, struct fx_write_co
 
         put_u32_unaligned(buffer, uav_type[type->sampler_dim]);
     }
+    else if (type->class == HLSL_CLASS_DEPTH_STENCIL_VIEW)
+    {
+        put_u32_unaligned(buffer, 20);
+    }
+    else if (type->class == HLSL_CLASS_RENDER_TARGET_VIEW)
+    {
+        put_u32_unaligned(buffer, 19);
+    }
     else if (type->class == HLSL_CLASS_OBJECT)
     {
         static const uint32_t object_type[] =
         {
             [HLSL_TYPE_PIXELSHADER]      = 5,
             [HLSL_TYPE_VERTEXSHADER]     = 6,
-            [HLSL_TYPE_RENDERTARGETVIEW] = 19,
-            [HLSL_TYPE_DEPTHSTENCILVIEW] = 20,
         };
 
         switch (type->base_type)
         {
-            case HLSL_TYPE_DEPTHSTENCILVIEW:
             case HLSL_TYPE_PIXELSHADER:
-            case HLSL_TYPE_RENDERTARGETVIEW:
             case HLSL_TYPE_VERTEXSHADER:
                 put_u32_unaligned(buffer, object_type[type->base_type]);
                 break;
@@ -533,11 +551,17 @@ static uint32_t write_fx_4_type(const struct hlsl_type *type, struct fx_write_co
                 return 0;
         }
     }
-    else /* Numeric type */
+    else if (hlsl_is_numeric_type(type))
     {
         numeric_desc = get_fx_4_numeric_type_description(type, fx);
         put_u32_unaligned(buffer, numeric_desc);
     }
+    else
+    {
+        FIXME("Type %u is not supported.\n", type->class);
+        set_status(fx, VKD3D_ERROR_NOT_IMPLEMENTED);
+        return 0;
+    }
 
     return offset;
 }
@@ -618,7 +642,7 @@ static void write_groups(struct fx_write_context *fx)
     {
         const struct hlsl_type *type = var->data_type;
 
-        if (type->base_type == HLSL_TYPE_EFFECT_GROUP)
+        if (type->class == HLSL_CLASS_EFFECT_GROUP)
             write_group(var, fx);
     }
 }
@@ -831,9 +855,17 @@ static bool is_type_supported_fx_2(struct hlsl_ctx *ctx, const struct hlsl_type
             hlsl_fixme(ctx, loc, "Write fx 2.0 parameter class %#x.", type->class);
             return false;
 
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
         case HLSL_CLASS_UAV:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_VOID:
             return false;
+
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_TECHNIQUE:
+            /* This cannot appear as an extern variable. */
+            break;
     }
 
     vkd3d_unreachable();
@@ -1011,6 +1043,7 @@ static void write_fx_4_object_variable(struct hlsl_ir_var *var, struct fx_write_
     /* Initializer */
     switch (type->class)
     {
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
             break;
@@ -1018,8 +1051,6 @@ static void write_fx_4_object_variable(struct hlsl_ir_var *var, struct fx_write_
         case HLSL_CLASS_OBJECT:
             switch (type->base_type)
             {
-                case HLSL_TYPE_RENDERTARGETVIEW:
-                    break;
                 case HLSL_TYPE_PIXELSHADER:
                 case HLSL_TYPE_VERTEXSHADER:
                     /* FIXME: write shader blobs, once parser support works. */
@@ -1118,6 +1149,7 @@ static bool is_object_variable(const struct hlsl_ir_var *var)
 
     switch (type->class)
     {
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_SAMPLER:
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
@@ -1128,7 +1160,6 @@ static bool is_object_variable(const struct hlsl_ir_var *var)
             {
                 case HLSL_TYPE_PIXELSHADER:
                 case HLSL_TYPE_VERTEXSHADER:
-                case HLSL_TYPE_RENDERTARGETVIEW:
                     return true;
                 default:
                     return false;
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 5dd80ff1c3f..4fc1493bdce 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -363,8 +363,13 @@ static void hlsl_type_calculate_reg_size(struct hlsl_ctx *ctx, struct hlsl_type
             type->reg_size[HLSL_REGSET_UAVS] = 1;
             break;
 
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_EFFECT_GROUP:
         case HLSL_CLASS_OBJECT:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_STRING:
+        case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_VOID:
             break;
     }
@@ -425,10 +430,12 @@ static bool type_is_single_component(const struct hlsl_type *type)
 {
     switch (type->class)
     {
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
         case HLSL_CLASS_SCALAR:
         case HLSL_CLASS_OBJECT:
         case HLSL_CLASS_SAMPLER:
         case HLSL_CLASS_STRING:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
             return true;
@@ -439,6 +446,9 @@ static bool type_is_single_component(const struct hlsl_type *type)
         case HLSL_CLASS_ARRAY:
             return false;
 
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_VOID:
             break;
     }
@@ -561,7 +571,9 @@ unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_ty
                 }
                 break;
 
+            case HLSL_CLASS_DEPTH_STENCIL_VIEW:
             case HLSL_CLASS_OBJECT:
+            case HLSL_CLASS_RENDER_TARGET_VIEW:
             case HLSL_CLASS_SAMPLER:
             case HLSL_CLASS_STRING:
             case HLSL_CLASS_TEXTURE:
@@ -569,6 +581,9 @@ unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_ty
                 assert(idx == 0);
                 break;
 
+            case HLSL_CLASS_EFFECT_GROUP:
+            case HLSL_CLASS_PASS:
+            case HLSL_CLASS_TECHNIQUE:
             case HLSL_CLASS_VOID:
                 vkd3d_unreachable();
         }
@@ -934,13 +949,18 @@ unsigned int hlsl_type_component_count(const struct hlsl_type *type)
         case HLSL_CLASS_ARRAY:
             return hlsl_type_component_count(type->e.array.type) * type->e.array.elements_count;
 
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
         case HLSL_CLASS_OBJECT:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_SAMPLER:
         case HLSL_CLASS_STRING:
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
             return 1;
 
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_VOID:
             break;
     }
@@ -997,9 +1017,9 @@ bool hlsl_types_are_equal(const struct hlsl_type *t1, const struct hlsl_type *t2
     if (t1->class == HLSL_CLASS_ARRAY)
         return t1->e.array.elements_count == t2->e.array.elements_count
                 && hlsl_types_are_equal(t1->e.array.type, t2->e.array.type);
-    if (t1->class == HLSL_CLASS_OBJECT)
+    if (t1->class == HLSL_CLASS_TECHNIQUE)
     {
-        if (t1->base_type == HLSL_TYPE_TECHNIQUE && t1->e.version != t2->e.version)
+        if (t1->e.version != t2->e.version)
             return false;
     }
 
@@ -1089,9 +1109,8 @@ struct hlsl_type *hlsl_type_clone(struct hlsl_ctx *ctx, struct hlsl_type *old,
             type->e.resource.format = old->e.resource.format;
             break;
 
-        case HLSL_CLASS_OBJECT:
-            if (type->base_type == HLSL_TYPE_TECHNIQUE)
-                type->e.version = old->e.version;
+        case HLSL_CLASS_TECHNIQUE:
+            type->e.version = old->e.version;
             break;
 
         default:
@@ -2355,9 +2374,14 @@ struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const stru
             }
             return string;
 
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_EFFECT_GROUP:
         case HLSL_CLASS_OBJECT:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_SAMPLER:
         case HLSL_CLASS_STRING:
+        case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_VOID:
             break;
     }
@@ -3533,12 +3557,8 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
         {"dword",           HLSL_CLASS_SCALAR, HLSL_TYPE_UINT,          1, 1},
         {"vector",          HLSL_CLASS_VECTOR, HLSL_TYPE_FLOAT,         4, 1},
         {"matrix",          HLSL_CLASS_MATRIX, HLSL_TYPE_FLOAT,         4, 4},
-        {"fxgroup",         HLSL_CLASS_OBJECT, HLSL_TYPE_EFFECT_GROUP,  1, 1},
-        {"pass",            HLSL_CLASS_OBJECT, HLSL_TYPE_PASS,          1, 1},
         {"pixelshader",     HLSL_CLASS_OBJECT, HLSL_TYPE_PIXELSHADER,   1, 1},
         {"vertexshader",    HLSL_CLASS_OBJECT, HLSL_TYPE_VERTEXSHADER,  1, 1},
-        {"RenderTargetView",HLSL_CLASS_OBJECT, HLSL_TYPE_RENDERTARGETVIEW, 1, 1},
-        {"DepthStencilView",HLSL_CLASS_OBJECT, HLSL_TYPE_DEPTHSTENCILVIEW, 1, 1},
     };
 
     static const struct
@@ -3650,6 +3670,10 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
     }
 
     ctx->builtin_types.Void = hlsl_new_simple_type(ctx, "void", HLSL_CLASS_VOID);
+    hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "DepthStencilView", HLSL_CLASS_DEPTH_STENCIL_VIEW));
+    hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "fxgroup", HLSL_CLASS_EFFECT_GROUP));
+    hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "pass", HLSL_CLASS_PASS));
+    hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "RenderTargetView", HLSL_CLASS_RENDER_TARGET_VIEW));
     hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "STRING", HLSL_CLASS_STRING));
     hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "texture", HLSL_CLASS_TEXTURE));
 
@@ -3662,7 +3686,7 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
 
     for (i = 0; i < ARRAY_SIZE(technique_types); ++i)
     {
-        type = hlsl_new_type(ctx, technique_types[i].name, HLSL_CLASS_OBJECT, HLSL_TYPE_TECHNIQUE, 1, 1);
+        type = hlsl_new_simple_type(ctx, technique_types[i].name, HLSL_CLASS_TECHNIQUE);
         type->e.version = technique_types[i].version;
         hlsl_scope_add_type(ctx->globals, type);
     }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index 5e3010c4353..1e5f0805152 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -79,8 +79,13 @@ enum hlsl_type_class
     HLSL_CLASS_STRUCT,
     HLSL_CLASS_ARRAY,
     HLSL_CLASS_OBJECT,
+    HLSL_CLASS_DEPTH_STENCIL_VIEW,
+    HLSL_CLASS_EFFECT_GROUP,
+    HLSL_CLASS_PASS,
+    HLSL_CLASS_RENDER_TARGET_VIEW,
     HLSL_CLASS_SAMPLER,
     HLSL_CLASS_STRING,
+    HLSL_CLASS_TECHNIQUE,
     HLSL_CLASS_TEXTURE,
     HLSL_CLASS_UAV,
     HLSL_CLASS_VOID,
@@ -97,11 +102,6 @@ enum hlsl_base_type
     HLSL_TYPE_LAST_SCALAR = HLSL_TYPE_BOOL,
     HLSL_TYPE_PIXELSHADER,
     HLSL_TYPE_VERTEXSHADER,
-    HLSL_TYPE_PASS,
-    HLSL_TYPE_RENDERTARGETVIEW,
-    HLSL_TYPE_DEPTHSTENCILVIEW,
-    HLSL_TYPE_TECHNIQUE,
-    HLSL_TYPE_EFFECT_GROUP,
 };
 
 enum hlsl_sampler_dim
@@ -145,8 +145,6 @@ struct hlsl_type
     enum hlsl_type_class class;
     /* If class is <= HLSL_CLASS_LAST_NUMERIC, then base_type is <= HLSL_TYPE_LAST_SCALAR.
      * If class is HLSL_CLASS_OBJECT, then base_type is > HLSL_TYPE_LAST_SCALAR.
-     * If class is HLSL_CLASS_OBJECT and base_type is HLSL_TYPE_TECHNIQUE, additional version
-     * field is used to distinguish between technique types.
      * Otherwise, base_type is not used. */
     enum hlsl_base_type base_type;
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index f99f322d8d1..0eed15c5a91 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -656,6 +656,16 @@ static unsigned int initializer_size(const struct parse_initializer *initializer
     return count;
 }
 
+static void cleanup_parse_attribute_list(struct parse_attribute_list *attr_list)
+{
+    unsigned int i = 0;
+
+    assert(attr_list);
+    for (i = 0; i < attr_list->count; ++i)
+        hlsl_free_attribute((struct hlsl_attribute *) attr_list->attrs[i]);
+    vkd3d_free(attr_list->attrs);
+}
+
 static void free_parse_initializer(struct parse_initializer *initializer)
 {
     destroy_block(initializer->instrs);
@@ -6033,11 +6043,7 @@ attribute_list:
             $$ = $1;
             if (!(new_array = vkd3d_realloc($$.attrs, ($$.count + 1) * sizeof(*$$.attrs))))
             {
-                unsigned int i;
-
-                for (i = 0; i < $$.count; ++i)
-                    hlsl_free_attribute((void *)$$.attrs[i]);
-                vkd3d_free($$.attrs);
+                cleanup_parse_attribute_list(&$$);
                 YYABORT;
             }
             $$.attrs = new_array;
@@ -6243,11 +6249,7 @@ func_prototype:
             }
             else
             {
-                unsigned int i;
-
-                for (i = 0; i < $1.count; ++i)
-                    hlsl_free_attribute((void *)$1.attrs[i]);
-                vkd3d_free($1.attrs);
+                cleanup_parse_attribute_list(&$1);
             }
             $$ = $2;
         }
@@ -7358,6 +7360,7 @@ selection_statement:
             {
                 destroy_block($6.then_block);
                 destroy_block($6.else_block);
+                cleanup_parse_attribute_list(&$1);
                 YYABORT;
             }
 
@@ -7365,10 +7368,12 @@ selection_statement:
             {
                 destroy_block($6.then_block);
                 destroy_block($6.else_block);
+                cleanup_parse_attribute_list(&$1);
                 YYABORT;
             }
             destroy_block($6.then_block);
             destroy_block($6.else_block);
+            cleanup_parse_attribute_list(&$1);
 
             $$ = $4;
             hlsl_block_add_instr($$, instr);
@@ -7391,21 +7396,25 @@ loop_statement:
         {
             $$ = create_loop(ctx, LOOP_WHILE, &$1, NULL, $5, NULL, $7, &@3);
             hlsl_pop_scope(ctx);
+            cleanup_parse_attribute_list(&$1);
         }
     | attribute_list_optional loop_scope_start KW_DO statement KW_WHILE '(' expr ')' ';'
         {
             $$ = create_loop(ctx, LOOP_DO_WHILE, &$1, NULL, $7, NULL, $4, &@3);
             hlsl_pop_scope(ctx);
+            cleanup_parse_attribute_list(&$1);
         }
     | attribute_list_optional loop_scope_start KW_FOR '(' expr_statement expr_statement expr_optional ')' statement
         {
             $$ = create_loop(ctx, LOOP_FOR, &$1, $5, $6, $7, $9, &@3);
             hlsl_pop_scope(ctx);
+            cleanup_parse_attribute_list(&$1);
         }
     | attribute_list_optional loop_scope_start KW_FOR '(' declaration expr_statement expr_optional ')' statement
         {
             $$ = create_loop(ctx, LOOP_FOR, &$1, $5, $6, $7, $9, &@3);
             hlsl_pop_scope(ctx);
+            cleanup_parse_attribute_list(&$1);
         }
 
 switch_statement:
@@ -7418,6 +7427,7 @@ switch_statement:
             {
                 destroy_switch_cases($8);
                 destroy_block($5);
+                cleanup_parse_attribute_list(&$1);
                 YYABORT;
             }
 
@@ -7428,6 +7438,7 @@ switch_statement:
             if (!s)
             {
                 destroy_block($5);
+                cleanup_parse_attribute_list(&$1);
                 YYABORT;
             }
 
@@ -7435,6 +7446,7 @@ switch_statement:
             hlsl_block_add_instr($$, s);
 
             hlsl_pop_scope(ctx);
+            cleanup_parse_attribute_list(&$1);
         }
 
 switch_case:
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index f6cccfe8bea..a6d6b336b40 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -1638,7 +1638,12 @@ static bool copy_propagation_transform_load(struct hlsl_ctx *ctx,
              * matrices yet. */
             return false;
 
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_STRING:
+        case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_VOID:
             vkd3d_unreachable();
     }
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index 1f8d60c62ac..59b74c065d8 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -2917,8 +2917,7 @@ static enum vkd3d_result vsir_block_init(struct vsir_block *block, unsigned int
     if (block_count > SIZE_MAX - (sizeof(*block->dominates) * CHAR_BIT - 1))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    block_count = align(block_count, sizeof(*block->dominates) * CHAR_BIT);
-    byte_count = block_count / CHAR_BIT;
+    byte_count = VKD3D_BITMAP_SIZE(block_count) * sizeof(*block->dominates);
 
     assert(label);
     memset(block, 0, sizeof(*block));
@@ -3098,6 +3097,8 @@ struct vsir_cfg
 {
     struct vkd3d_shader_message_context *message_context;
     struct vsir_program *program;
+    size_t function_begin;
+    size_t function_end;
     struct vsir_block *blocks;
     struct vsir_block *entry;
     size_t block_count;
@@ -3342,25 +3343,19 @@ static void vsir_cfg_dump_structured_program(struct vsir_cfg *cfg)
 }
 
 static enum vkd3d_result vsir_cfg_init(struct vsir_cfg *cfg, struct vsir_program *program,
-        struct vkd3d_shader_message_context *message_context, struct vsir_cfg_emit_target *target)
+        struct vkd3d_shader_message_context *message_context, struct vsir_cfg_emit_target *target,
+        size_t *pos)
 {
     struct vsir_block *current_block = NULL;
     enum vkd3d_result ret;
     size_t i;
 
-    if (program->shader_version.type == VKD3D_SHADER_TYPE_HULL)
-    {
-        FIXME("Hull shaders are not supported.\n");
-        vkd3d_shader_error(message_context, NULL, VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED,
-                "The structurizer does not support hull shaders.");
-        return VKD3D_ERROR_INVALID_SHADER;
-    }
-
     memset(cfg, 0, sizeof(*cfg));
     cfg->message_context = message_context;
     cfg->program = program;
     cfg->block_count = program->block_count;
     cfg->target = target;
+    cfg->function_begin = *pos;
 
     vsir_block_list_init(&cfg->order);
 
@@ -3370,9 +3365,10 @@ static enum vkd3d_result vsir_cfg_init(struct vsir_cfg *cfg, struct vsir_program
     if (TRACE_ON())
         vkd3d_string_buffer_init(&cfg->debug_buffer);
 
-    for (i = 0; i < program->instructions.count; ++i)
+    for (i = *pos; i < program->instructions.count; ++i)
     {
         struct vkd3d_shader_instruction *instruction = &program->instructions.elements[i];
+        bool finish = false;
 
         switch (instruction->handler_idx)
         {
@@ -3404,11 +3400,24 @@ static enum vkd3d_result vsir_cfg_init(struct vsir_cfg *cfg, struct vsir_program
                 current_block = NULL;
                 break;
 
+            case VKD3DSIH_HS_CONTROL_POINT_PHASE:
+            case VKD3DSIH_HS_FORK_PHASE:
+            case VKD3DSIH_HS_JOIN_PHASE:
+                assert(!current_block);
+                finish = true;
+                break;
+
             default:
                 break;
         }
+
+        if (finish)
+            break;
     }
 
+    *pos = i;
+    cfg->function_end = *pos;
+
     for (i = 0; i < cfg->block_count; ++i)
     {
         struct vsir_block *block = &cfg->blocks[i];
@@ -4881,12 +4890,13 @@ static enum vkd3d_result vsir_cfg_emit_structured_program(struct vsir_cfg *cfg)
 }
 
 static enum vkd3d_result vsir_program_structurize_function(struct vsir_program *program,
-        struct vkd3d_shader_message_context *message_context, struct vsir_cfg_emit_target *target)
+        struct vkd3d_shader_message_context *message_context, struct vsir_cfg_emit_target *target,
+        size_t *pos)
 {
     enum vkd3d_result ret;
     struct vsir_cfg cfg;
 
-    if ((ret = vsir_cfg_init(&cfg, program, message_context, target)) < 0)
+    if ((ret = vsir_cfg_init(&cfg, program, message_context, target, pos)) < 0)
         return ret;
 
     vsir_cfg_compute_dominators(&cfg);
@@ -4919,7 +4929,7 @@ static enum vkd3d_result vsir_program_structurize(struct vsir_program *program,
 {
     struct vsir_cfg_emit_target target = {0};
     enum vkd3d_result ret;
-    unsigned int i;
+    size_t i;
 
     target.jump_target_temp_idx = program->temp_count;
     target.temp_count = program->temp_count + 1;
@@ -4927,19 +4937,41 @@ static enum vkd3d_result vsir_program_structurize(struct vsir_program *program,
     if (!reserve_instructions(&target.instructions, &target.ins_capacity, program->instructions.count))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    /* Copy declarations until the first block. */
-    for (i = 0; i < program->instructions.count; ++i)
+    for (i = 0; i < program->instructions.count;)
     {
         struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
 
-        if (ins->handler_idx == VKD3DSIH_LABEL)
-            break;
+        switch (ins->handler_idx)
+        {
+            case VKD3DSIH_LABEL:
+                assert(program->shader_version.type != VKD3D_SHADER_TYPE_HULL);
+                TRACE("Structurizing a non-hull shader.\n");
+                if ((ret = vsir_program_structurize_function(program, message_context,
+                        &target, &i)) < 0)
+                    goto fail;
+                assert(i == program->instructions.count);
+                break;
 
-        target.instructions[target.ins_count++] = *ins;
-    }
+            case VKD3DSIH_HS_CONTROL_POINT_PHASE:
+            case VKD3DSIH_HS_FORK_PHASE:
+            case VKD3DSIH_HS_JOIN_PHASE:
+                assert(program->shader_version.type == VKD3D_SHADER_TYPE_HULL);
+                TRACE("Structurizing phase %u of a hull shader.\n", ins->handler_idx);
+                target.instructions[target.ins_count++] = *ins;
+                ++i;
+                if ((ret = vsir_program_structurize_function(program, message_context,
+                        &target, &i)) < 0)
+                    goto fail;
+                break;
 
-    if ((ret = vsir_program_structurize_function(program, message_context, &target)) < 0)
-        goto fail;
+            default:
+                if (!reserve_instructions(&target.instructions, &target.ins_capacity, target.ins_count + 1))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+                target.instructions[target.ins_count++] = *ins;
+                ++i;
+                break;
+        }
+    }
 
     vkd3d_free(program->instructions.elements);
     program->instructions.elements = target.instructions;
@@ -5001,6 +5033,9 @@ static enum vkd3d_result vsir_cfg_materialize_undominated_ssas_to_temps(struct v
         struct vsir_block *block = &cfg->blocks[i];
         struct vkd3d_shader_instruction *ins;
 
+        if (block->label == 0)
+            continue;
+
         for (ins = block->begin; ins <= block->end; ++ins)
         {
             for (j = 0; j < ins->dst_count; ++j)
@@ -5016,6 +5051,9 @@ static enum vkd3d_result vsir_cfg_materialize_undominated_ssas_to_temps(struct v
         struct vsir_block *block = &cfg->blocks[i];
         struct vkd3d_shader_instruction *ins;
 
+        if (block->label == 0)
+            continue;
+
         for (ins = block->begin; ins <= block->end; ++ins)
         {
             for (j = 0; j < ins->src_count; ++j)
@@ -5028,7 +5066,7 @@ static enum vkd3d_result vsir_cfg_materialize_undominated_ssas_to_temps(struct v
 
     TRACE("Emitting temps for %u values with undominated usage.\n", alloc.next_temp_idx - program->temp_count);
 
-    for (i = 0; i < program->instructions.count; ++i)
+    for (i = cfg->function_begin; i < cfg->function_end; ++i)
     {
         struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
 
@@ -5047,13 +5085,14 @@ done:
     return VKD3D_OK;
 }
 
-static enum vkd3d_result vsir_program_materialize_undominated_ssas_to_temps(struct vsir_program *program,
-        struct vkd3d_shader_message_context *message_context)
+static enum vkd3d_result vsir_program_materialize_undominated_ssas_to_temps_in_function(
+        struct vsir_program *program, struct vkd3d_shader_message_context *message_context,
+        size_t *pos)
 {
     enum vkd3d_result ret;
     struct vsir_cfg cfg;
 
-    if ((ret = vsir_cfg_init(&cfg, program, message_context, NULL)) < 0)
+    if ((ret = vsir_cfg_init(&cfg, program, message_context, NULL, pos)) < 0)
         return ret;
 
     vsir_cfg_compute_dominators(&cfg);
@@ -5065,6 +5104,47 @@ static enum vkd3d_result vsir_program_materialize_undominated_ssas_to_temps(stru
     return ret;
 }
 
+static enum vkd3d_result vsir_program_materialize_undominated_ssas_to_temps(struct vsir_program *program,
+        struct vkd3d_shader_message_context *message_context)
+{
+    enum vkd3d_result ret;
+    size_t i;
+
+    for (i = 0; i < program->instructions.count;)
+    {
+        struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
+
+        switch (ins->handler_idx)
+        {
+            case VKD3DSIH_LABEL:
+                assert(program->shader_version.type != VKD3D_SHADER_TYPE_HULL);
+                TRACE("Materializing undominated SSAs in a non-hull shader.\n");
+                if ((ret = vsir_program_materialize_undominated_ssas_to_temps_in_function(
+                        program, message_context, &i)) < 0)
+                    return ret;
+                assert(i == program->instructions.count);
+                break;
+
+            case VKD3DSIH_HS_CONTROL_POINT_PHASE:
+            case VKD3DSIH_HS_FORK_PHASE:
+            case VKD3DSIH_HS_JOIN_PHASE:
+                assert(program->shader_version.type == VKD3D_SHADER_TYPE_HULL);
+                TRACE("Materializing undominated SSAs in phase %u of a hull shader.\n", ins->handler_idx);
+                ++i;
+                if ((ret = vsir_program_materialize_undominated_ssas_to_temps_in_function(
+                        program, message_context, &i)) < 0)
+                    return ret;
+                break;
+
+            default:
+                ++i;
+                break;
+        }
+    }
+
+    return VKD3D_OK;
+}
+
 struct validation_context
 {
     struct vkd3d_shader_message_context *message_context;
@@ -5890,7 +5970,8 @@ static void vsir_validate_instruction(struct validation_context *ctx)
                 unsigned int value_idx = 2 * i;
                 unsigned int label_idx = 2 * i + 1;
 
-                if (!register_is_constant(&instruction->src[value_idx].reg) && !register_is_ssa(&instruction->src[value_idx].reg))
+                if (!register_is_constant_or_undef(&instruction->src[value_idx].reg)
+                        && !register_is_ssa(&instruction->src[value_idx].reg))
                     validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
                             "Invalid value register for incoming %zu of type %#x in PHI instruction, "
                             "expected SSA, IMMCONST or IMMCONST64.", i, instruction->src[value_idx].reg.type);
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index 6ee06c02d74..708ab6268a7 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -3006,10 +3006,15 @@ static D3D_SHADER_VARIABLE_CLASS sm4_class(const struct hlsl_type *type)
             return D3D_SVC_VECTOR;
 
         case HLSL_CLASS_ARRAY:
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_EFFECT_GROUP:
         case HLSL_CLASS_STRUCT:
         case HLSL_CLASS_OBJECT:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_SAMPLER:
         case HLSL_CLASS_STRING:
+        case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_VOID:
-- 
2.43.0

