From 0ecf5a7422b7001bee116ec98919724ffb0ec8b3 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 9 Aug 2024 07:52:46 +1000
Subject: [PATCH] Updated vkd3d to b23874dad600ec777c0bbe6ecc7aa3f5020476d1.

---
 libs/vkd3d/include/private/vkd3d_common.h     |  70 ++-
 libs/vkd3d/libs/vkd3d-common/debug.c          |  13 +-
 libs/vkd3d/libs/vkd3d-shader/checksum.c       |   2 +-
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c        |   2 +-
 libs/vkd3d/libs/vkd3d-shader/d3dbc.c          |  82 ++-
 libs/vkd3d/libs/vkd3d-shader/dxbc.c           |   6 +-
 libs/vkd3d/libs/vkd3d-shader/dxil.c           |  46 +-
 libs/vkd3d/libs/vkd3d-shader/fx.c             | 486 ++++++++++++++----
 libs/vkd3d/libs/vkd3d-shader/glsl.c           | 196 ++++++-
 libs/vkd3d/libs/vkd3d-shader/hlsl.c           | 225 ++++++--
 libs/vkd3d/libs/vkd3d-shader/hlsl.h           |  55 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.l           | 127 ++++-
 libs/vkd3d/libs/vkd3d-shader/hlsl.y           | 125 ++++-
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c   | 384 +++++++++++---
 .../libs/vkd3d-shader/hlsl_constant_ops.c     | 110 ++--
 libs/vkd3d/libs/vkd3d-shader/ir.c             | 108 ++--
 libs/vkd3d/libs/vkd3d-shader/preproc.h        |   2 +-
 libs/vkd3d/libs/vkd3d-shader/preproc.l        |   4 +-
 libs/vkd3d/libs/vkd3d-shader/preproc.y        |   2 +-
 libs/vkd3d/libs/vkd3d-shader/spirv.c          | 180 ++++---
 libs/vkd3d/libs/vkd3d-shader/tpf.c            | 152 +++---
 .../libs/vkd3d-shader/vkd3d_shader_main.c     |  12 +-
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |  10 +-
 libs/vkd3d/libs/vkd3d/cache.c                 |   9 +-
 libs/vkd3d/libs/vkd3d/command.c               | 396 +++++++-------
 libs/vkd3d/libs/vkd3d/device.c                |  24 +-
 libs/vkd3d/libs/vkd3d/resource.c              |  42 +-
 libs/vkd3d/libs/vkd3d/state.c                 | 187 +++++--
 libs/vkd3d/libs/vkd3d/utils.c                 |   4 +-
 libs/vkd3d/libs/vkd3d/vkd3d_main.c            |   8 +-
 libs/vkd3d/libs/vkd3d/vkd3d_private.h         |   8 +-
 31 files changed, 2151 insertions(+), 926 deletions(-)

diff --git a/libs/vkd3d/include/private/vkd3d_common.h b/libs/vkd3d/include/private/vkd3d_common.h
index e7b25602ec0..c62dc00415f 100644
--- a/libs/vkd3d/include/private/vkd3d_common.h
+++ b/libs/vkd3d/include/private/vkd3d_common.h
@@ -46,6 +46,12 @@
 
 #define STATIC_ASSERT(e) extern void __VKD3D_STATIC_ASSERT__(int [(e) ? 1 : -1])
 
+#define VKD3D_ASSERT(cond) \
+        do { \
+            if (!(cond)) \
+                ERR("Failed assertion: %s\n", #cond); \
+        } while (0)
+
 #define MEMBER_SIZE(t, m) sizeof(((t *)0)->m)
 
 #define VKD3D_MAKE_TAG(ch0, ch1, ch2, ch3) \
@@ -102,17 +108,11 @@ static inline uint64_t align(uint64_t addr, size_t alignment)
 # define VKD3D_UNREACHABLE (void)0
 #endif  /* __GNUC__ */
 
-VKD3D_NORETURN static inline void vkd3d_unreachable_(const char *filename, unsigned int line)
-{
-    fprintf(stderr, "%s:%u: Aborting, reached unreachable code.\n", filename, line);
-    abort();
-}
-
-#ifdef NDEBUG
-#define vkd3d_unreachable() VKD3D_UNREACHABLE
-#else
-#define vkd3d_unreachable() vkd3d_unreachable_(__FILE__, __LINE__)
-#endif
+#define vkd3d_unreachable() \
+        do { \
+            ERR("%s:%u: Unreachable code reached.\n", __FILE__, __LINE__); \
+            VKD3D_UNREACHABLE; \
+        } while (0)
 
 #ifdef VKD3D_NO_TRACE_MESSAGES
 #define TRACE(args...) do { } while (0)
@@ -122,11 +122,19 @@ VKD3D_NORETURN static inline void vkd3d_unreachable_(const char *filename, unsig
 #ifdef VKD3D_NO_DEBUG_MESSAGES
 #define WARN(args...) do { } while (0)
 #define FIXME(args...) do { } while (0)
+#define WARN_ON() (false)
+#define FIXME_ONCE(args...) do { } while (0)
+#endif
+
+#ifdef VKD3D_NO_ERROR_MESSAGES
+#define ERR(args...) do { } while (0)
+#define MESSAGE(args...) do { } while (0)
 #endif
 
 enum vkd3d_dbg_level
 {
     VKD3D_DBG_LEVEL_NONE,
+    VKD3D_DBG_LEVEL_MESSAGE,
     VKD3D_DBG_LEVEL_ERR,
     VKD3D_DBG_LEVEL_FIXME,
     VKD3D_DBG_LEVEL_WARN,
@@ -147,7 +155,7 @@ const char *debugstr_w(const WCHAR *wstr, size_t wchar_size);
 #define VKD3D_DBG_LOG(level) \
         do { \
         const enum vkd3d_dbg_level vkd3d_dbg_level = VKD3D_DBG_LEVEL_##level; \
-        VKD3D_DBG_PRINTF
+        VKD3D_DBG_PRINTF_##level
 
 #define VKD3D_DBG_LOG_ONCE(first_time_level, level) \
         do { \
@@ -155,24 +163,50 @@ const char *debugstr_w(const WCHAR *wstr, size_t wchar_size);
         const enum vkd3d_dbg_level vkd3d_dbg_level = vkd3d_dbg_next_time \
         ? VKD3D_DBG_LEVEL_##level : VKD3D_DBG_LEVEL_##first_time_level; \
         vkd3d_dbg_next_time = true; \
-        VKD3D_DBG_PRINTF
+        VKD3D_DBG_PRINTF_##level
 
 #define VKD3D_DBG_PRINTF(...) \
         vkd3d_dbg_printf(vkd3d_dbg_level, __FUNCTION__, __VA_ARGS__); } while (0)
 
+#define VKD3D_DBG_PRINTF_TRACE(...) VKD3D_DBG_PRINTF(__VA_ARGS__)
+#define VKD3D_DBG_PRINTF_WARN(...) VKD3D_DBG_PRINTF(__VA_ARGS__)
+#define VKD3D_DBG_PRINTF_FIXME(...) VKD3D_DBG_PRINTF(__VA_ARGS__)
+#define VKD3D_DBG_PRINTF_MESSAGE(...) VKD3D_DBG_PRINTF(__VA_ARGS__)
+
+#ifdef VKD3D_ABORT_ON_ERR
+#define VKD3D_DBG_PRINTF_ERR(...) \
+        vkd3d_dbg_printf(vkd3d_dbg_level, __FUNCTION__, __VA_ARGS__); \
+        abort(); \
+        } while (0)
+#else
+#define VKD3D_DBG_PRINTF_ERR(...) VKD3D_DBG_PRINTF(__VA_ARGS__)
+#endif
+
+/* Used by vkd3d_unreachable(). */
+#ifdef VKD3D_CROSSTEST
+#undef ERR
+#define ERR(...) do { fprintf(stderr, __VA_ARGS__); abort(); } while (0)
+#endif
+
 #ifndef TRACE
-#define TRACE VKD3D_DBG_LOG(TRACE)
+#define TRACE   VKD3D_DBG_LOG(TRACE)
 #endif
 
 #ifndef WARN
-#define WARN  VKD3D_DBG_LOG(WARN)
+#define WARN    VKD3D_DBG_LOG(WARN)
 #endif
 
 #ifndef FIXME
-#define FIXME VKD3D_DBG_LOG(FIXME)
+#define FIXME   VKD3D_DBG_LOG(FIXME)
 #endif
 
-#define ERR   VKD3D_DBG_LOG(ERR)
+#ifndef ERR
+#define ERR     VKD3D_DBG_LOG(ERR)
+#endif
+
+#ifndef MESSAGE
+#define MESSAGE VKD3D_DBG_LOG(MESSAGE)
+#endif
 
 #ifndef TRACE_ON
 #define TRACE_ON() (vkd3d_dbg_get_level() == VKD3D_DBG_LEVEL_TRACE)
@@ -182,7 +216,9 @@ const char *debugstr_w(const WCHAR *wstr, size_t wchar_size);
 #define WARN_ON() (vkd3d_dbg_get_level() >= VKD3D_DBG_LEVEL_WARN)
 #endif
 
+#ifndef FIXME_ONCE
 #define FIXME_ONCE VKD3D_DBG_LOG_ONCE(FIXME, WARN)
+#endif
 
 #define VKD3D_DEBUG_ENV_NAME(name) const char *const vkd3d_dbg_env_name = name
 
diff --git a/libs/vkd3d/libs/vkd3d-common/debug.c b/libs/vkd3d/libs/vkd3d-common/debug.c
index 4523fc997ef..4bfc19bd9a1 100644
--- a/libs/vkd3d/libs/vkd3d-common/debug.c
+++ b/libs/vkd3d/libs/vkd3d-common/debug.c
@@ -45,11 +45,12 @@ extern const char *const vkd3d_dbg_env_name;
 
 static const char *const debug_level_names[] =
 {
-    [VKD3D_DBG_LEVEL_NONE ] = "none",
-    [VKD3D_DBG_LEVEL_ERR  ] = "err",
-    [VKD3D_DBG_LEVEL_FIXME] = "fixme",
-    [VKD3D_DBG_LEVEL_WARN ] = "warn",
-    [VKD3D_DBG_LEVEL_TRACE] = "trace",
+    [VKD3D_DBG_LEVEL_NONE ] =   "none",
+    [VKD3D_DBG_LEVEL_MESSAGE] = "message",
+    [VKD3D_DBG_LEVEL_ERR  ] =   "err",
+    [VKD3D_DBG_LEVEL_FIXME] =   "fixme",
+    [VKD3D_DBG_LEVEL_WARN ] =   "warn",
+    [VKD3D_DBG_LEVEL_TRACE] =   "trace",
 };
 
 enum vkd3d_dbg_level vkd3d_dbg_get_level(void)
@@ -104,8 +105,6 @@ void vkd3d_dbg_printf(enum vkd3d_dbg_level level, const char *function, const ch
     if (vkd3d_dbg_get_level() < level)
         return;
 
-    assert(level < ARRAY_SIZE(debug_level_names));
-
 #ifdef _WIN32
     vkd3d_dbg_output("vkd3d:%04lx:%s:%s ", GetCurrentThreadId(), debug_level_names[level], function);
 #elif HAVE_GETTID
diff --git a/libs/vkd3d/libs/vkd3d-shader/checksum.c b/libs/vkd3d/libs/vkd3d-shader/checksum.c
index 0910729a0e9..d9560628c77 100644
--- a/libs/vkd3d/libs/vkd3d-shader/checksum.c
+++ b/libs/vkd3d/libs/vkd3d-shader/checksum.c
@@ -288,7 +288,7 @@ void vkd3d_compute_dxbc_checksum(const void *dxbc, size_t size, uint32_t checksu
     const uint8_t *ptr = dxbc;
     struct md5_ctx ctx;
 
-    assert(size > DXBC_CHECKSUM_SKIP_BYTE_COUNT);
+    VKD3D_ASSERT(size > DXBC_CHECKSUM_SKIP_BYTE_COUNT);
     ptr += DXBC_CHECKSUM_SKIP_BYTE_COUNT;
     size -= DXBC_CHECKSUM_SKIP_BYTE_COUNT;
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index 8a3eb5a367a..2c2f0c43ece 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -1919,7 +1919,7 @@ static void shader_dump_icb(struct vkd3d_d3d_asm_compiler *compiler,
     }
     else
     {
-        assert(icb->component_count == VKD3D_VEC4_SIZE);
+        VKD3D_ASSERT(icb->component_count == VKD3D_VEC4_SIZE);
         for (i = 0; i < icb->element_count; ++i)
         {
             shader_print_hex_literal(compiler, "    {", icb->data[4 * i + 0], "");
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index 492ad9b69fb..a4c038a233a 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -757,7 +757,7 @@ static void record_constant_register(struct vkd3d_shader_sm1_parser *sm1,
     {
         /* d3d shaders have a maximum of 8192 constants; we should not overrun
          * this array. */
-        assert((index / 32) <= ARRAY_SIZE(sm1->constants[set].def_mask));
+        VKD3D_ASSERT((index / 32) <= ARRAY_SIZE(sm1->constants[set].def_mask));
         bitmap_set(sm1->constants[set].def_mask, index);
     }
 }
@@ -1492,7 +1492,7 @@ D3DXPARAMETER_CLASS hlsl_sm1_class(const struct hlsl_type *type)
         case HLSL_CLASS_ARRAY:
             return hlsl_sm1_class(type->e.array.type);
         case HLSL_CLASS_MATRIX:
-            assert(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
+            VKD3D_ASSERT(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
             if (type->modifiers & HLSL_MODIFIER_COLUMN_MAJOR)
                 return D3DXPC_MATRIX_COLUMNS;
             else
@@ -1519,6 +1519,10 @@ D3DXPARAMETER_CLASS hlsl_sm1_class(const struct hlsl_type *type)
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_VOID:
         case HLSL_CLASS_CONSTANT_BUFFER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             break;
     }
 
@@ -1618,6 +1622,10 @@ D3DXPARAMETER_TYPE hlsl_sm1_base_type(const struct hlsl_type *type)
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_VOID:
         case HLSL_CLASS_CONSTANT_BUFFER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             break;
     }
 
@@ -1910,7 +1918,7 @@ static bool is_inconsequential_instr(const struct sm1_instruction *instr)
 
 static void write_sm1_dst_register(struct vkd3d_bytecode_buffer *buffer, const struct sm1_dst_register *reg)
 {
-    assert(reg->writemask);
+    VKD3D_ASSERT(reg->writemask);
     put_u32(buffer, (1u << 31) | sm1_encode_register_type(reg->type) | reg->mod | (reg->writemask << 16) | reg->reg);
 }
 
@@ -2090,7 +2098,7 @@ static void d3dbc_write_cast(struct d3dbc_compiler *d3dbc, const struct hlsl_ir_
     struct hlsl_ctx *ctx = d3dbc->ctx;
 
     /* Narrowing casts were already lowered. */
-    assert(src_type->dimx == dst_type->dimx);
+    VKD3D_ASSERT(src_type->dimx == dst_type->dimx);
 
     switch (dst_type->e.numeric.type)
     {
@@ -2204,7 +2212,7 @@ static void d3dbc_write_semantic_dcl(struct d3dbc_compiler *d3dbc,
     else
     {
         ret = hlsl_sm1_usage_from_semantic(element->semantic_name, element->semantic_index, &usage, &usage_idx);
-        assert(ret);
+        VKD3D_ASSERT(ret);
         reg.type = output ? VKD3DSPR_OUTPUT : VKD3DSPR_INPUT;
         reg.reg = element->register_index;
     }
@@ -2348,8 +2356,8 @@ static void d3dbc_write_constant(struct d3dbc_compiler *d3dbc, const struct hlsl
         .src_count = 1,
     };
 
-    assert(instr->reg.allocated);
-    assert(constant->reg.allocated);
+    VKD3D_ASSERT(instr->reg.allocated);
+    VKD3D_ASSERT(constant->reg.allocated);
     sm1_map_src_swizzle(&sm1_instr.srcs[0], sm1_instr.dst.writemask);
     d3dbc_write_instruction(d3dbc, &sm1_instr);
 }
@@ -2374,12 +2382,40 @@ static void d3dbc_write_per_component_unary_op(struct d3dbc_compiler *d3dbc,
 static void d3dbc_write_sincos(struct d3dbc_compiler *d3dbc, enum hlsl_ir_expr_op op,
         const struct hlsl_reg *dst, const struct hlsl_reg *src)
 {
+    struct sm1_instruction instr =
+    {
+        .opcode = D3DSIO_SINCOS,
+
+        .dst.type = VKD3DSPR_TEMP,
+        .dst.writemask = dst->writemask,
+        .dst.reg = dst->id,
+        .has_dst = 1,
+
+        .srcs[0].type = VKD3DSPR_TEMP,
+        .srcs[0].swizzle = hlsl_swizzle_from_writemask(src->writemask),
+        .srcs[0].reg = src->id,
+        .src_count = 1,
+    };
+
     if (op == HLSL_OP1_COS_REDUCED)
-        assert(dst->writemask == VKD3DSP_WRITEMASK_0);
+        VKD3D_ASSERT(dst->writemask == VKD3DSP_WRITEMASK_0);
     else /* HLSL_OP1_SIN_REDUCED */
-        assert(dst->writemask == VKD3DSP_WRITEMASK_1);
+        VKD3D_ASSERT(dst->writemask == VKD3DSP_WRITEMASK_1);
+
+    if (d3dbc->ctx->profile->major_version < 3)
+    {
+        instr.src_count = 3;
+
+        instr.srcs[1].type = VKD3DSPR_CONST;
+        instr.srcs[1].swizzle = hlsl_swizzle_from_writemask(VKD3DSP_WRITEMASK_ALL);
+        instr.srcs[1].reg = d3dbc->ctx->d3dsincosconst1.id;
+
+        instr.srcs[2].type = VKD3DSPR_CONST;
+        instr.srcs[2].swizzle = hlsl_swizzle_from_writemask(VKD3DSP_WRITEMASK_ALL);
+        instr.srcs[2].reg = d3dbc->ctx->d3dsincosconst2.id;
+    }
 
-    d3dbc_write_unary_op(d3dbc, D3DSIO_SINCOS, dst, src, 0, 0);
+    d3dbc_write_instruction(d3dbc, &instr);
 }
 
 static void d3dbc_write_expr(struct d3dbc_compiler *d3dbc, const struct hlsl_ir_node *instr)
@@ -2391,7 +2427,7 @@ static void d3dbc_write_expr(struct d3dbc_compiler *d3dbc, const struct hlsl_ir_
     struct hlsl_ir_node *arg3 = expr->operands[2].node;
     struct hlsl_ctx *ctx = d3dbc->ctx;
 
-    assert(instr->reg.allocated);
+    VKD3D_ASSERT(instr->reg.allocated);
 
     if (expr->op == HLSL_OP1_REINTERPRET)
     {
@@ -2534,7 +2570,7 @@ static void d3dbc_write_if(struct d3dbc_compiler *d3dbc, const struct hlsl_ir_no
     struct sm1_instruction sm1_ifc, sm1_else, sm1_endif;
 
     condition = iff->condition.node;
-    assert(condition->data_type->dimx == 1 && condition->data_type->dimy == 1);
+    VKD3D_ASSERT(condition->data_type->dimx == 1 && condition->data_type->dimy == 1);
 
     sm1_ifc = (struct sm1_instruction)
     {
@@ -2616,11 +2652,11 @@ static void d3dbc_write_load(struct d3dbc_compiler *d3dbc, const struct hlsl_ir_
         .src_count = 1,
     };
 
-    assert(instr->reg.allocated);
+    VKD3D_ASSERT(instr->reg.allocated);
 
     if (load->src.var->is_uniform)
     {
-        assert(reg.allocated);
+        VKD3D_ASSERT(reg.allocated);
         sm1_instr.srcs[0].type = VKD3DSPR_CONST;
     }
     else if (load->src.var->is_input_semantic)
@@ -2628,7 +2664,7 @@ static void d3dbc_write_load(struct d3dbc_compiler *d3dbc, const struct hlsl_ir_
         if (!hlsl_sm1_register_from_semantic(&d3dbc->program->shader_version, load->src.var->semantic.name,
                 load->src.var->semantic.index, false, &sm1_instr.srcs[0].type, &sm1_instr.srcs[0].reg))
         {
-            assert(reg.allocated);
+            VKD3D_ASSERT(reg.allocated);
             sm1_instr.srcs[0].type = VKD3DSPR_INPUT;
             sm1_instr.srcs[0].reg = reg.id;
         }
@@ -2706,7 +2742,7 @@ static void d3dbc_write_resource_load(struct d3dbc_compiler *d3dbc, const struct
             return;
     }
 
-    assert(instr->reg.allocated);
+    VKD3D_ASSERT(instr->reg.allocated);
 
     d3dbc_write_instruction(d3dbc, &sm1_instr);
 }
@@ -2733,12 +2769,6 @@ static void d3dbc_write_store(struct d3dbc_compiler *d3dbc, const struct hlsl_ir
         .src_count = 1,
     };
 
-    if (store->lhs.var->data_type->class == HLSL_CLASS_MATRIX)
-    {
-        hlsl_fixme(ctx, &instr->loc, "Lower matrix writemasks.");
-        return;
-    }
-
     if (store->lhs.var->is_output_semantic)
     {
         if (version->type == VKD3D_SHADER_TYPE_PIXEL && version->major == 1)
@@ -2749,7 +2779,7 @@ static void d3dbc_write_store(struct d3dbc_compiler *d3dbc, const struct hlsl_ir
         else if (!hlsl_sm1_register_from_semantic(&d3dbc->program->shader_version, store->lhs.var->semantic.name,
                 store->lhs.var->semantic.index, true, &sm1_instr.dst.type, &sm1_instr.dst.reg))
         {
-            assert(reg.allocated);
+            VKD3D_ASSERT(reg.allocated);
             sm1_instr.dst.type = VKD3DSPR_OUTPUT;
             sm1_instr.dst.reg = reg.id;
         }
@@ -2757,7 +2787,7 @@ static void d3dbc_write_store(struct d3dbc_compiler *d3dbc, const struct hlsl_ir
             sm1_instr.dst.writemask = (1u << store->lhs.var->data_type->dimx) - 1;
     }
     else
-        assert(reg.allocated);
+        VKD3D_ASSERT(reg.allocated);
 
     sm1_map_src_swizzle(&sm1_instr.srcs[0], sm1_instr.dst.writemask);
     d3dbc_write_instruction(d3dbc, &sm1_instr);
@@ -2783,8 +2813,8 @@ static void d3dbc_write_swizzle(struct d3dbc_compiler *d3dbc, const struct hlsl_
         .src_count = 1,
     };
 
-    assert(instr->reg.allocated);
-    assert(val->reg.allocated);
+    VKD3D_ASSERT(instr->reg.allocated);
+    VKD3D_ASSERT(val->reg.allocated);
     sm1_map_src_swizzle(&sm1_instr.srcs[0], sm1_instr.dst.writemask);
     d3dbc_write_instruction(d3dbc, &sm1_instr);
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxbc.c b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
index 4b9f67235aa..184788dc57e 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
@@ -29,7 +29,7 @@ void dxbc_writer_add_section(struct dxbc_writer *dxbc, uint32_t tag, const void
 {
     struct vkd3d_shader_dxbc_section_desc *section;
 
-    assert(dxbc->section_count < ARRAY_SIZE(dxbc->sections));
+    VKD3D_ASSERT(dxbc->section_count < ARRAY_SIZE(dxbc->sections));
 
     section = &dxbc->sections[dxbc->section_count++];
     section->tag = tag;
@@ -983,7 +983,7 @@ static int shader_parse_root_signature(const struct vkd3d_shader_code *data,
     {
         struct vkd3d_shader_root_signature_desc1 *v_1_1 = &desc->u.v_1_1;
 
-        assert(version == VKD3D_SHADER_ROOT_SIGNATURE_VERSION_1_1);
+        VKD3D_ASSERT(version == VKD3D_SHADER_ROOT_SIGNATURE_VERSION_1_1);
 
         v_1_1->parameter_count = count;
         if (v_1_1->parameter_count)
@@ -1777,7 +1777,7 @@ int vkd3d_shader_convert_root_signature(struct vkd3d_shader_versioned_root_signa
     }
     else
     {
-        assert(version == VKD3D_SHADER_ROOT_SIGNATURE_VERSION_1_1);
+        VKD3D_ASSERT(version == VKD3D_SHADER_ROOT_SIGNATURE_VERSION_1_1);
         ret = convert_root_signature_to_v1_1(dst, src);
     }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index bf581928a9e..2a0bbe1a625 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -941,7 +941,7 @@ static uint32_t sm6_parser_read_bits(struct sm6_parser *sm6, unsigned int length
     if (!length)
         return 0;
 
-    assert(length < 32);
+    VKD3D_ASSERT(length < 32);
 
     if (sm6_parser_is_end(sm6))
     {
@@ -949,7 +949,7 @@ static uint32_t sm6_parser_read_bits(struct sm6_parser *sm6, unsigned int length
         return 0;
     }
 
-    assert(sm6->bitpos < 32);
+    VKD3D_ASSERT(sm6->bitpos < 32);
     bits = *sm6->ptr >> sm6->bitpos;
     l = 32 - sm6->bitpos;
     if (l <= length)
@@ -1208,7 +1208,7 @@ static enum vkd3d_result sm6_parser_add_global_abbrev(struct sm6_parser *sm6)
     struct dxil_global_abbrev *global_abbrev;
     enum vkd3d_result ret;
 
-    assert(block->id == BLOCKINFO_BLOCK);
+    VKD3D_ASSERT(block->id == BLOCKINFO_BLOCK);
 
     if (!vkd3d_array_reserve((void **)&sm6->abbrevs, &sm6->abbrev_capacity, sm6->abbrev_count + 1, sizeof(*sm6->abbrevs))
             || !(global_abbrev = vkd3d_malloc(sizeof(*global_abbrev) + count * sizeof(global_abbrev->abbrev.operands[0]))))
@@ -1477,7 +1477,7 @@ static enum vkd3d_result dxil_block_init(struct dxil_block *block, const struct
             if (sm6->abbrevs[i]->block_id == block->id)
                 block->abbrevs[abbrev_count++] = &sm6->abbrevs[i]->abbrev;
 
-        assert(abbrev_count == block->abbrev_count);
+        VKD3D_ASSERT(abbrev_count == block->abbrev_count);
     }
 
     if ((ret = dxil_block_read(block, sm6)) < 0)
@@ -1555,7 +1555,7 @@ static char *dxil_record_to_string(const struct dxil_record *record, unsigned in
     unsigned int i;
     char *str;
 
-    assert(offset <= record->operand_count);
+    VKD3D_ASSERT(offset <= record->operand_count);
     if (!(str = vkd3d_calloc(record->operand_count - offset + 1, 1)))
     {
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
@@ -1843,7 +1843,7 @@ static enum vkd3d_result sm6_parser_type_table_init(struct sm6_parser *sm6)
         ++sm6->type_count;
     }
 
-    assert(sm6->type_count == type_count);
+    VKD3D_ASSERT(sm6->type_count == type_count);
 
     if (struct_name)
     {
@@ -2216,13 +2216,13 @@ static inline bool sm6_value_is_function_dcl(const struct sm6_value *value)
 
 static inline bool sm6_value_is_dx_intrinsic_dcl(const struct sm6_value *fn)
 {
-    assert(sm6_value_is_function_dcl(fn));
+    VKD3D_ASSERT(sm6_value_is_function_dcl(fn));
     return fn->u.function.is_prototype && !strncmp(fn->u.function.name, "dx.op.", 6);
 }
 
 static inline struct sm6_value *sm6_parser_get_current_value(const struct sm6_parser *sm6)
 {
-    assert(sm6->value_count < sm6->value_capacity);
+    VKD3D_ASSERT(sm6->value_count < sm6->value_capacity);
     return &sm6->values[sm6->value_count];
 }
 
@@ -3404,7 +3404,7 @@ static struct vkd3d_shader_instruction *sm6_parser_add_instruction(struct sm6_pa
         enum vkd3d_shader_opcode handler_idx)
 {
     struct vkd3d_shader_instruction *ins = sm6_parser_require_space(sm6, 1);
-    assert(ins);
+    VKD3D_ASSERT(ins);
     vsir_instruction_init(ins, &sm6->p.location, handler_idx);
     ++sm6->p.program->instructions.count;
     return ins;
@@ -3651,7 +3651,7 @@ static const struct vkd3d_shader_immediate_constant_buffer *resolve_forward_init
 {
     const struct sm6_value *value;
 
-    assert(index);
+    VKD3D_ASSERT(index);
     --index;
     if (!(value = sm6_parser_get_value_safe(sm6, index)) || (!sm6_value_is_icb(value) && !sm6_value_is_undef(value)))
     {
@@ -3895,7 +3895,7 @@ static void sm6_parser_init_signature(struct sm6_parser *sm6, const struct shade
         if (e->register_count > 1 || (is_patch_constant && vsir_sysval_semantic_is_tess_factor(e->sysval_semantic)))
             param->reg.idx[count++].offset = 0;
 
-        assert(count < ARRAY_SIZE(param->reg.idx));
+        VKD3D_ASSERT(count < ARRAY_SIZE(param->reg.idx));
         param->reg.idx[count++].offset = i;
         param->reg.idx_count = count;
     }
@@ -4866,10 +4866,10 @@ static void sm6_parser_emit_dx_cbuffer_load(struct sm6_parser *sm6, enum dx_intr
         return;
     src_param_init_vector_from_reg(src_param, &buffer->u.handle.reg);
     register_index_address_init(&src_param->reg.idx[2], operands[1], sm6);
-    assert(src_param->reg.idx_count == 3);
+    VKD3D_ASSERT(src_param->reg.idx_count == 3);
 
     type = sm6_type_get_scalar_type(dst->type, 0);
-    assert(type);
+    VKD3D_ASSERT(type);
     src_param->reg.data_type = vkd3d_data_type_from_sm6_type(type);
     if (data_type_is_64_bit(src_param->reg.data_type))
         src_param->swizzle = vsir_swizzle_64_from_32(src_param->swizzle);
@@ -5342,7 +5342,7 @@ static void sm6_parser_emit_dx_load_input(struct sm6_parser *sm6, enum dx_intrin
 
     if (!is_patch_constant && !operands[3]->is_undefined)
     {
-        assert(src_param->reg.idx_count > count);
+        VKD3D_ASSERT(src_param->reg.idx_count > count);
         register_index_address_init(&src_param->reg.idx[count], operands[3], sm6);
     }
 
@@ -6400,7 +6400,7 @@ static bool sm6_parser_validate_dx_op(struct sm6_parser *sm6, enum dx_intrinsic_
 
     info = &sm6_dx_op_table[op];
 
-    assert(info->ret_type[0]);
+    VKD3D_ASSERT(info->ret_type[0]);
     if (!sm6_parser_validate_operand_type(sm6, dst, info->ret_type[0], NULL, true))
     {
         WARN("Failed to validate return type for dx intrinsic id %u, '%s'.\n", op, name);
@@ -6605,7 +6605,7 @@ static enum vkd3d_shader_opcode sm6_map_cast_op(uint64_t code, const struct sm6_
             else if (to->u.width > from->u.width)
             {
                 op = (code == CAST_ZEXT) ? VKD3DSIH_UTOU : VKD3DSIH_ITOI;
-                assert(from->u.width == 1 || to->u.width == 64);
+                VKD3D_ASSERT(from->u.width == 1 || to->u.width == 64);
                 is_valid = from_int && to_int;
             }
             break;
@@ -7141,7 +7141,7 @@ static void sm6_parser_emit_load(struct sm6_parser *sm6, const struct dxil_recor
 
     if (ptr->structure_stride)
     {
-        assert(ptr->u.reg.type == VKD3DSPR_GROUPSHAREDMEM);
+        VKD3D_ASSERT(ptr->u.reg.type == VKD3DSPR_GROUPSHAREDMEM);
         vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_LD_STRUCTURED);
 
         if (!(src_params = instruction_src_params_alloc(ins, 3, sm6)))
@@ -7324,7 +7324,7 @@ static void sm6_parser_emit_store(struct sm6_parser *sm6, const struct dxil_reco
 
     if (ptr->structure_stride)
     {
-        assert(ptr->u.reg.type == VKD3DSPR_GROUPSHAREDMEM);
+        VKD3D_ASSERT(ptr->u.reg.type == VKD3DSPR_GROUPSHAREDMEM);
         vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_STORE_STRUCTURED);
 
         if (!(src_params = instruction_src_params_alloc(ins, 3, sm6)))
@@ -7380,7 +7380,7 @@ static void sm6_parser_emit_switch(struct sm6_parser *sm6, const struct dxil_rec
     if (!(src = sm6_parser_get_value_by_ref(sm6, record, type, &i))
             || !sm6_value_validate_is_register(src, sm6))
         return;
-    assert(i == 2);
+    VKD3D_ASSERT(i == 2);
 
     if (src->type != type)
     {
@@ -7690,7 +7690,7 @@ static void metadata_attachment_record_apply(const struct dxil_record *record, e
                 "Ignoring a nested metadata attachment.");
     }
 
-    assert(record->operand_count & 1);
+    VKD3D_ASSERT(record->operand_count & 1);
     for (i = 1; i < record->operand_count; i += 2)
     {
         if (!(m = sm6_parser_find_metadata_kind(sm6, record->operands[i])))
@@ -8053,7 +8053,7 @@ static void sm6_block_emit_terminator(const struct sm6_block *block, struct sm6_
                 switch_case = &block->terminator.cases[i];
                 if (!(case_block = switch_case->block))
                 {
-                    assert(sm6->p.failed);
+                    VKD3D_ASSERT(sm6->p.failed);
                     continue;
                 }
                 if (switch_case->is_default)
@@ -8122,7 +8122,7 @@ static void sm6_block_emit_phi(const struct sm6_block *block, struct sm6_parser
             if (incoming_block)
                 vsir_src_param_init_label(&src_params[index + 1], incoming_block->id);
             else
-                assert(sm6->p.failed);
+                VKD3D_ASSERT(sm6->p.failed);
         }
 
         dst_param_init(dst_param);
@@ -10541,7 +10541,7 @@ int dxil_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t co
     uint32_t *byte_code = NULL;
     int ret;
 
-    ERR("Creating a DXIL parser. This is unsupported; you get to keep all the pieces if it breaks.\n");
+    MESSAGE("Creating a DXIL parser. This is unsupported; you get to keep all the pieces if it breaks.\n");
 
     dxbc_desc.is_dxil = true;
     if ((ret = shader_extract_from_dxbc(&compile_info->source, message_context, compile_info->source_name,
diff --git a/libs/vkd3d/libs/vkd3d-shader/fx.c b/libs/vkd3d/libs/vkd3d-shader/fx.c
index 15a518c07db..e3ebbafb3f4 100644
--- a/libs/vkd3d/libs/vkd3d-shader/fx.c
+++ b/libs/vkd3d/libs/vkd3d-shader/fx.c
@@ -56,36 +56,80 @@ static void string_storage_destroy(struct rb_entry *entry, void *context)
     vkd3d_free(string_entry);
 }
 
-struct state_block_function_info
+struct function_component
+{
+    const char *name;
+    bool lhs_has_index;
+    unsigned int lhs_index;
+};
+
+static const struct state_block_function_info
 {
     const char *name;
     unsigned int min_args, max_args;
+    const struct function_component components[3];
+    unsigned int min_profile;
+}
+function_info[] =
+{
+    {"SetBlendState",        3, 3, { { "AB_BlendFactor" }, { "AB_SampleMask" }, { "BlendState" } }, 4 },
+    {"SetDepthStencilState", 2, 2, { { "DS_StencilRef" }, { "DepthStencilState" } }, 4 },
+    {"SetRasterizerState",   1, 1, { { "RasterizerState" } }, 4 },
+    {"SetVertexShader",      1, 1, { { "VertexShader" } }, 4 },
+    {"SetDomainShader",      1, 1, { { "DomainShader" } }, 5 },
+    {"SetHullShader",        1, 1, { { "HullShader" } }, 5 },
+    {"SetGeometryShader",    1, 1, { { "GeometryShader" } }, 4 },
+    {"SetPixelShader",       1, 1, { { "PixelShader" } }, 4 },
+    {"SetComputeShader",     1, 1, { { "ComputeShader" } }, 4 },
+    {"OMSetRenderTargets",   2, 9, { {0} }, 4 },
 };
 
 static const struct state_block_function_info *get_state_block_function_info(const char *name)
 {
-    static const struct state_block_function_info valid_functions[] =
-    {
-        {"SetBlendState",        3, 3},
-        {"SetDepthStencilState", 2, 2},
-        {"SetRasterizerState",   1, 1},
-        {"SetVertexShader",      1, 1},
-        {"SetDomainShader",      1, 1},
-        {"SetHullShader",        1, 1},
-        {"SetGeometryShader",    1, 1},
-        {"SetPixelShader",       1, 1},
-        {"SetComputeShader",     1, 1},
-        {"OMSetRenderTargets",   2, 9},
-    };
-
-    for (unsigned int i = 0; i < ARRAY_SIZE(valid_functions); ++i)
+    for (unsigned int i = 0; i < ARRAY_SIZE(function_info); ++i)
     {
-        if (!strcmp(name, valid_functions[i].name))
-            return &valid_functions[i];
+        if (!strcmp(name, function_info[i].name))
+            return &function_info[i];
     }
     return NULL;
 }
 
+static void add_function_component(struct function_component **components, const char *name,
+        bool lhs_has_index, unsigned int lhs_index)
+{
+    struct function_component *comp = *components;
+
+    comp->name = name;
+    comp->lhs_has_index = lhs_has_index;
+    comp->lhs_index = lhs_index;
+
+    *components = *components + 1;
+}
+
+static void get_state_block_function_components(const struct state_block_function_info *info,
+        struct function_component *components, unsigned int comp_count)
+{
+    unsigned int i;
+
+    assert(comp_count <= info->max_args);
+
+    if (info->min_args == info->max_args)
+    {
+        const struct function_component *c = info->components;
+        for (i = 0; i < comp_count; ++i, ++c)
+            add_function_component(&components, c->name, c->lhs_has_index, c->lhs_index);
+        return;
+    }
+
+    if (!strcmp(info->name, "OMSetRenderTargets"))
+    {
+        for (i = 0; i < comp_count - 2; ++i)
+            add_function_component(&components, "RenderTargetView", true, i + 1);
+        add_function_component(&components, "DepthStencilView", false, 0);
+        add_function_component(&components, "RenderTargetView", true, 0);
+    }
+}
+
 bool hlsl_validate_state_block_entry(struct hlsl_ctx *ctx, struct hlsl_state_block_entry *entry,
         const struct vkd3d_shader_location *loc)
 {
@@ -189,9 +233,6 @@ static uint32_t write_string(const char *string, struct fx_write_context *fx)
 
 static void write_pass(struct hlsl_ir_var *var, struct fx_write_context *fx)
 {
-    if (var->state_block_count && var->state_blocks[0]->count)
-        hlsl_fixme(fx->ctx, &var->loc, "Write pass assignments.");
-
     fx->ops->write_pass(var, fx);
 }
 
@@ -230,6 +271,8 @@ static void write_fx_4_annotations(struct hlsl_scope *scope, struct fx_write_con
 static uint32_t write_fx_4_type(const struct hlsl_type *type, struct fx_write_context *fx);
 static const char * get_fx_4_type_name(const struct hlsl_type *type);
 static void write_fx_4_annotation(struct hlsl_ir_var *var, struct fx_write_context *fx);
+static void write_fx_4_state_block(struct hlsl_ir_var *var, unsigned int block_index,
+        uint32_t count_offset, struct fx_write_context *fx);
 
 static uint32_t write_type(const struct hlsl_type *type, struct fx_write_context *fx)
 {
@@ -238,7 +281,7 @@ static uint32_t write_type(const struct hlsl_type *type, struct fx_write_context
     unsigned int elements_count;
     const char *name;
 
-    assert(fx->ctx->profile->major_version >= 4);
+    VKD3D_ASSERT(fx->ctx->profile->major_version >= 4);
 
     if (type->class == HLSL_CLASS_ARRAY)
     {
@@ -374,15 +417,14 @@ static uint32_t write_fx_4_string(const char *string, struct fx_write_context *f
 static void write_fx_4_pass(struct hlsl_ir_var *var, struct fx_write_context *fx)
 {
     struct vkd3d_bytecode_buffer *buffer = &fx->structured;
-    uint32_t name_offset;
+    uint32_t name_offset, count_offset;
 
     name_offset = write_string(var->name, fx);
     put_u32(buffer, name_offset);
-    put_u32(buffer, 0); /* Assignment count. */
+    count_offset = put_u32(buffer, 0);
 
     write_fx_4_annotations(var->annotations, fx);
-
-    /* TODO: assignments */
+    write_fx_4_state_block(var, 0, count_offset, fx);
 }
 
 static void write_fx_2_pass(struct hlsl_ir_var *var, struct fx_write_context *fx)
@@ -398,6 +440,9 @@ static void write_fx_2_pass(struct hlsl_ir_var *var, struct fx_write_context *fx
     /* TODO: annotations */
     /* TODO: assignments */
 
+    if (var->state_block_count && var->state_blocks[0]->count)
+        hlsl_fixme(fx->ctx, &var->loc, "Write pass assignments.");
+
     /* For some reason every pass adds to the total shader object count. */
     fx->shader_count++;
 }
@@ -587,6 +632,10 @@ static uint32_t write_fx_4_type(const struct hlsl_type *type, struct fx_write_co
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_VERTEX_SHADER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             put_u32_unaligned(buffer, 2);
             break;
 
@@ -710,6 +759,18 @@ static uint32_t write_fx_4_type(const struct hlsl_type *type, struct fx_write_co
         numeric_desc = get_fx_4_numeric_type_description(type, fx);
         put_u32_unaligned(buffer, numeric_desc);
     }
+    else if (type->class == HLSL_CLASS_COMPUTE_SHADER)
+    {
+        put_u32_unaligned(buffer, 28);
+    }
+    else if (type->class == HLSL_CLASS_HULL_SHADER)
+    {
+        put_u32_unaligned(buffer, 29);
+    }
+    else if (type->class == HLSL_CLASS_DOMAIN_SHADER)
+    {
+        put_u32_unaligned(buffer, 30);
+    }
     else
     {
         FIXME("Type %u is not supported.\n", type->class);
@@ -870,7 +931,7 @@ static uint32_t write_fx_2_parameter(const struct hlsl_type *type, const char *n
             const struct hlsl_struct_field *field = &type->e.record.fields[i];
 
             /* Validated in check_invalid_object_fields(). */
-            assert(hlsl_is_numeric_type(field->type));
+            VKD3D_ASSERT(hlsl_is_numeric_type(field->type));
             write_fx_2_parameter(field->type, field->name, &field->semantic, fx);
         }
     }
@@ -1013,6 +1074,10 @@ static bool is_type_supported_fx_2(struct hlsl_ctx *ctx, const struct hlsl_type
         case HLSL_CLASS_RASTERIZER_STATE:
         case HLSL_CLASS_RENDER_TARGET_VIEW:
         case HLSL_CLASS_VOID:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             return false;
 
         case HLSL_CLASS_EFFECT_GROUP:
@@ -1330,11 +1395,8 @@ static void write_fx_4_state_assignment(const struct hlsl_ir_var *var, struct hl
     struct hlsl_ctx *ctx = fx->ctx;
     struct hlsl_ir_node *value = entry->args->node;
 
-    if (entry->lhs_has_index)
-        hlsl_fixme(ctx, &var->loc, "Unsupported assignment to array element.");
-
     put_u32(buffer, entry->name_id);
-    put_u32(buffer, 0); /* TODO: destination index */
+    put_u32(buffer, entry->lhs_index);
     type_offset = put_u32(buffer, 0);
     rhs_offset = put_u32(buffer, 0);
 
@@ -1348,6 +1410,17 @@ static void write_fx_4_state_assignment(const struct hlsl_ir_var *var, struct hl
             assignment_type = 1;
             break;
         }
+        case HLSL_IR_LOAD:
+        {
+            struct hlsl_ir_load *l = hlsl_ir_load(value);
+
+            if (l->src.path_len)
+                hlsl_fixme(ctx, &var->loc, "Indexed access in RHS values is not implemented.");
+
+            value_offset = write_fx_4_string(l->src.var->name, fx);
+            assignment_type = 2;
+            break;
+        }
         default:
             hlsl_fixme(ctx, &var->loc, "Unsupported assignment type for state %s.", entry->name);
     }
@@ -1424,8 +1497,59 @@ enum state_property_component_type
     FX_FLOAT,
     FX_UINT,
     FX_UINT8,
+    FX_DEPTHSTENCIL,
+    FX_RASTERIZER,
+    FX_DOMAINSHADER,
+    FX_HULLSHADER,
+    FX_COMPUTESHADER,
+    FX_TEXTURE,
+    FX_DEPTHSTENCILVIEW,
+    FX_RENDERTARGETVIEW,
 };
 
+static inline bool is_object_fx_type(enum state_property_component_type type)
+{
+    switch (type)
+    {
+        case FX_DEPTHSTENCIL:
+        case FX_RASTERIZER:
+        case FX_DOMAINSHADER:
+        case FX_HULLSHADER:
+        case FX_COMPUTESHADER:
+        case FX_TEXTURE:
+        case FX_RENDERTARGETVIEW:
+        case FX_DEPTHSTENCILVIEW:
+            return true;
+        default:
+            return false;
+    }
+}
+
+static inline enum hlsl_type_class hlsl_type_class_from_fx_type(enum state_property_component_type type)
+{
+    switch (type)
+    {
+        case FX_DEPTHSTENCIL:
+            return HLSL_CLASS_DEPTH_STENCIL_STATE;
+        case FX_RASTERIZER:
+            return HLSL_CLASS_RASTERIZER_STATE;
+        case FX_DOMAINSHADER:
+            return HLSL_CLASS_DOMAIN_SHADER;
+        case FX_HULLSHADER:
+            return HLSL_CLASS_HULL_SHADER;
+        case FX_COMPUTESHADER:
+            return HLSL_CLASS_COMPUTE_SHADER;
+        case FX_TEXTURE:
+            return HLSL_CLASS_TEXTURE;
+        case FX_RENDERTARGETVIEW:
+            return HLSL_CLASS_RENDER_TARGET_VIEW;
+        case FX_DEPTHSTENCILVIEW:
+            return HLSL_CLASS_DEPTH_STENCIL_VIEW;
+        default:
+            vkd3d_unreachable();
+    }
+}
+
 static inline enum hlsl_base_type hlsl_type_from_fx_type(enum state_property_component_type type)
 {
     switch (type)
@@ -1546,48 +1670,61 @@ static void resolve_fx_4_state_block_values(struct hlsl_ir_var *var, struct hlsl
         enum hlsl_type_class class;
         enum state_property_component_type type;
         unsigned int dimx;
+        unsigned int array_size;
         uint32_t id;
         const struct rhs_named_value *values;
     }
     states[] =
     {
-        { "FillMode",              HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 12, fill_values },
-        { "CullMode",              HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 13, cull_values },
-        { "FrontCounterClockwise", HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 14 },
-        { "DepthBias",             HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 15 },
-        { "DepthBiasClamp",        HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_FLOAT, 1, 16 },
-        { "SlopeScaledDepthBias",  HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_FLOAT, 1, 17 },
-        { "DepthClipEnable",       HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 18 },
-        { "ScissorEnable",         HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 19 },
-        { "MultisampleEnable",     HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 20 },
-        { "AntializedLineEnable",  HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 21 },
-
-        { "DepthEnable",               HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 22 },
-        { "DepthWriteMask",            HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 23, depth_write_mask_values },
-        { "DepthFunc",                 HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 24, comparison_values },
-        { "StencilEnable",             HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 25 },
-        { "StencilReadMask",           HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT8, 1, 26 },
-        { "StencilWriteMask",          HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT8, 1, 27 },
-        { "FrontFaceStencilFail",      HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 28, stencil_op_values },
-        { "FrontFaceStencilDepthFail", HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 29, stencil_op_values },
-        { "FrontFaceStencilPass",      HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 30, stencil_op_values },
-        { "FrontFaceStencilFunc",      HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 31, comparison_values },
-        { "BackFaceStencilFail",       HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 32, stencil_op_values },
-        { "BackFaceStencilDepthFail",  HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 33, stencil_op_values },
-        { "BackFaceStencilPass",       HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 34, stencil_op_values },
-        { "BackFaceStencilFunc",       HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 35, comparison_values },
-
-        { "Filter",         HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 45, filter_values },
-        { "AddressU",       HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 46, address_values },
-        { "AddressV",       HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 47, address_values },
-        { "AddressW",       HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 48, address_values },
-        { "MipLODBias",     HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_FLOAT,   1, 49 },
-        { "MaxAnisotropy",  HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 50 },
-        { "ComparisonFunc", HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 51, compare_func_values },
-        { "BorderColor",    HLSL_CLASS_SAMPLER, HLSL_CLASS_VECTOR,  FX_FLOAT,   4, 52 },
-        { "MinLOD",         HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_FLOAT,   1, 53 },
-        { "MaxLOD",         HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_FLOAT,   1, 54 },
-        /* TODO: "Texture" field */
+        { "RasterizerState",       HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_RASTERIZER, 1, 1, 0 },
+        { "DepthStencilState",     HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_DEPTHSTENCIL, 1, 1, 1 },
+
+        { "RenderTargetView",      HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_RENDERTARGETVIEW, 1, 8, 3 },
+        { "DepthStencilView",      HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_DEPTHSTENCILVIEW, 1, 1, 4 },
+
+        { "DS_StencilRef",         HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_UINT, 1, 1, 9 },
+
+        { "FillMode",              HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 12, fill_values },
+        { "CullMode",              HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 13, cull_values },
+        { "FrontCounterClockwise", HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 1, 14 },
+        { "DepthBias",             HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 15 },
+        { "DepthBiasClamp",        HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 16 },
+        { "SlopeScaledDepthBias",  HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 17 },
+        { "DepthClipEnable",       HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 1, 18 },
+        { "ScissorEnable",         HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 1, 19 },
+        { "MultisampleEnable",     HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 1, 20 },
+        { "AntializedLineEnable",  HLSL_CLASS_RASTERIZER_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 1, 21 },
+
+        { "DepthEnable",               HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 1, 22 },
+        { "DepthWriteMask",            HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 23, depth_write_mask_values },
+        { "DepthFunc",                 HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 24, comparison_values },
+        { "StencilEnable",             HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_BOOL,  1, 1, 25 },
+        { "StencilReadMask",           HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT8, 1, 1, 26 },
+        { "StencilWriteMask",          HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT8, 1, 1, 27 },
+        { "FrontFaceStencilFail",      HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 28, stencil_op_values },
+        { "FrontFaceStencilDepthFail", HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 29, stencil_op_values },
+        { "FrontFaceStencilPass",      HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 30, stencil_op_values },
+        { "FrontFaceStencilFunc",      HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 31, comparison_values },
+        { "BackFaceStencilFail",       HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 32, stencil_op_values },
+        { "BackFaceStencilDepthFail",  HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 33, stencil_op_values },
+        { "BackFaceStencilPass",       HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 34, stencil_op_values },
+        { "BackFaceStencilFunc",       HLSL_CLASS_DEPTH_STENCIL_STATE, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 35, comparison_values },
+
+        { "Filter",         HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 1, 45, filter_values },
+        { "AddressU",       HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 1, 46, address_values },
+        { "AddressV",       HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 1, 47, address_values },
+        { "AddressW",       HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 1, 48, address_values },
+        { "MipLODBias",     HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_FLOAT,   1, 1, 49 },
+        { "MaxAnisotropy",  HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 1, 50 },
+        { "ComparisonFunc", HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_UINT,    1, 1, 51, compare_func_values },
+        { "BorderColor",    HLSL_CLASS_SAMPLER, HLSL_CLASS_VECTOR,  FX_FLOAT,   4, 1, 52 },
+        { "MinLOD",         HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_FLOAT,   1, 1, 53 },
+        { "MaxLOD",         HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_FLOAT,   1, 1, 54 },
+        { "Texture",        HLSL_CLASS_SAMPLER, HLSL_CLASS_SCALAR,  FX_TEXTURE, 1, 1, 55 },
+
+        { "HullShader",     HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_HULLSHADER,    1, 1, 56 },
+        { "DomainShader",   HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_DOMAINSHADER,  1, 1, 57 },
+        { "ComputeShader",  HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_COMPUTESHADER, 1, 1, 58 },
     };
     const struct hlsl_type *type = hlsl_get_multiarray_element_type(var->data_type);
     struct replace_state_context replace_context;
@@ -1596,6 +1733,7 @@ static void resolve_fx_4_state_block_values(struct hlsl_ir_var *var, struct hlsl
     const struct state *state = NULL;
     struct hlsl_ctx *ctx = fx->ctx;
     enum hlsl_base_type base_type;
+    struct hlsl_ir_load *load;
     unsigned int i;
 
     for (i = 0; i < ARRAY_SIZE(states); ++i)
@@ -1621,6 +1759,27 @@ static void resolve_fx_4_state_block_values(struct hlsl_ir_var *var, struct hlsl
         return;
     }
 
+    if (entry->lhs_has_index && state->array_size == 1)
+    {
+        hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX, "Can't use array-style access for non-array state %s.",
+                entry->name);
+        return;
+    }
+
+    if (!entry->lhs_has_index && state->array_size > 1)
+    {
+        hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX, "Expected array index for array state %s.",
+                entry->name);
+        return;
+    }
+
+    if (entry->lhs_has_index && (state->array_size <= entry->lhs_index))
+    {
+        hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX, "Invalid element index %u for the state %s[%u].",
+                entry->lhs_index, state->name, state->array_size);
+        return;
+    }
+
     entry->name_id = state->id;
 
     replace_context.values = state->values;
@@ -1632,6 +1791,32 @@ static void resolve_fx_4_state_block_values(struct hlsl_ir_var *var, struct hlsl
 
     /* Now cast and run folding again. */
 
+    if (is_object_fx_type(state->type))
+    {
+        node = entry->args->node;
+
+        switch (node->type)
+        {
+            case HLSL_IR_LOAD:
+                load = hlsl_ir_load(node);
+
+                if (load->src.path_len)
+                    hlsl_fixme(ctx, &ctx->location, "Arrays are not supported for RHS.");
+
+                if (load->src.var->data_type->class != hlsl_type_class_from_fx_type(state->type))
+                {
+                    hlsl_error(ctx, &ctx->location, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX, "Type mismatch for the %s state value",
+                            entry->name);
+                }
+
+                break;
+            default:
+                hlsl_fixme(ctx, &ctx->location, "Unhandled node type for object-typed field.");
+        }
+
+        return;
+    }
+
     base_type = hlsl_type_from_fx_type(state->type);
     switch (state->class)
     {
@@ -1676,40 +1861,138 @@ static void resolve_fx_4_state_block_values(struct hlsl_ir_var *var, struct hlsl
     }
 }
 
-static void write_fx_4_state_object_initializer(struct hlsl_ir_var *var, struct fx_write_context *fx)
+static unsigned int decompose_fx_4_state_block(struct hlsl_ir_var *var, struct hlsl_state_block *block,
+        unsigned int entry_index, struct fx_write_context *fx)
 {
-    uint32_t elements_count = hlsl_get_multiarray_size(var->data_type), i, j;
-    struct vkd3d_bytecode_buffer *buffer = &fx->structured;
-    uint32_t count_offset, count;
+    struct hlsl_state_block_entry *entry = block->entries[entry_index];
+    const struct state_block_function_info *info;
+    struct function_component components[9];
+    struct hlsl_ctx *ctx = fx->ctx;
+    unsigned int i;
 
-    for (i = 0; i < elements_count; ++i)
+    if (!entry->is_function_call)
+        return 1;
+
+    if (!(info = get_state_block_function_info(entry->name)))
+        return 1;
+
+    if (info->min_profile > ctx->profile->major_version)
     {
-        struct hlsl_state_block *block;
+        hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_STATE_BLOCK_ENTRY,
+                "State %s is not supported for this profile.", entry->name);
+        return 1;
+    }
 
-        count_offset = put_u32(buffer, 0);
+    /* For single argument case simply replace the name. */
+    if (info->min_args == info->max_args && info->min_args == 1)
+    {
+        vkd3d_free(entry->name);
+        entry->name = hlsl_strdup(ctx, info->components[0].name);
+        return 1;
+    }
+
+    if (!vkd3d_array_reserve((void **)&block->entries, &block->capacity, block->count + entry->args_count - 1,
+            sizeof(*block->entries)))
+        return 1;
+    if (entry_index != block->count - 1)
+    {
+        memmove(&block->entries[entry_index + entry->args_count], &block->entries[entry_index + 1],
+                (block->count - entry_index - 1) * sizeof(*block->entries));
+    }
+    block->count += entry->args_count - 1;
+
+    get_state_block_function_components(info, components, entry->args_count);
+
+    for (i = 0; i < entry->args_count; ++i)
+    {
+        const struct function_component *comp = &components[i];
+        unsigned int arg_index = (i + 1) % entry->args_count;
+        block->entries[entry_index + i] = clone_stateblock_entry(ctx, entry, comp->name,
+                comp->lhs_has_index, comp->lhs_index, arg_index);
+    }
+    hlsl_free_state_block_entry(entry);
+
+    return entry->args_count;
+}
+
+static void write_fx_4_state_block(struct hlsl_ir_var *var, unsigned int block_index,
+        uint32_t count_offset, struct fx_write_context *fx)
+{
+    struct vkd3d_bytecode_buffer *buffer = &fx->structured;
+    struct hlsl_state_block *block;
+    uint32_t i, count = 0;
+
+    if (var->state_blocks)
+    {
+        block = var->state_blocks[block_index];
 
-        count = 0;
-        if (var->state_blocks)
+        for (i = 0; i < block->count;)
         {
-            block = var->state_blocks[i];
+            i += decompose_fx_4_state_block(var, block, i, fx);
+        }
 
-            for (j = 0; j < block->count; ++j)
-            {
-                struct hlsl_state_block_entry *entry = block->entries[j];
+        for (i = 0; i < block->count; ++i)
+        {
+            struct hlsl_state_block_entry *entry = block->entries[i];
 
-                /* Skip if property is reassigned later. This will use the last assignment. */
-                if (state_block_contains_state(entry->name, j + 1, block))
-                    continue;
+            /* Skip if property is reassigned later. This will use the last assignment. */
+            if (state_block_contains_state(entry->name, i + 1, block))
+                continue;
 
-                /* Resolve special constant names and property names. */
-                resolve_fx_4_state_block_values(var, entry, fx);
+            /* Resolve special constant names and property names. */
+            resolve_fx_4_state_block_values(var, entry, fx);
 
-                write_fx_4_state_assignment(var, entry, fx);
-                ++count;
-            }
+            write_fx_4_state_assignment(var, entry, fx);
+            ++count;
         }
+    }
+
+    set_u32(buffer, count_offset, count);
+}
+
+static void write_fx_4_state_object_initializer(struct hlsl_ir_var *var, struct fx_write_context *fx)
+{
+    uint32_t elements_count = hlsl_get_multiarray_size(var->data_type), i;
+    struct vkd3d_bytecode_buffer *buffer = &fx->structured;
+    uint32_t count_offset;
+
+    for (i = 0; i < elements_count; ++i)
+    {
+        count_offset = put_u32(buffer, 0);
+
+        write_fx_4_state_block(var, i, count_offset, fx);
+    }
+}
+
+static void write_fx_4_shader_initializer(struct hlsl_ir_var *var, struct fx_write_context *fx)
+{
+    struct vkd3d_bytecode_buffer *buffer = &fx->structured;
+    uint32_t elements_count = hlsl_get_multiarray_size(var->data_type);
+    unsigned int i;
+
+    /* FIXME: write shader blobs, once parser support works. */
+    for (i = 0; i < elements_count; ++i)
+        put_u32(buffer, 0);
+}
+
+static void write_fx_5_shader_initializer(struct hlsl_ir_var *var, struct fx_write_context *fx)
+{
+    struct vkd3d_bytecode_buffer *buffer = &fx->structured;
+    uint32_t elements_count = hlsl_get_multiarray_size(var->data_type);
+    unsigned int i;
 
-        set_u32(buffer, count_offset, count);
+    /* FIXME: write shader blobs, once parser support works. */
+    for (i = 0; i < elements_count; ++i)
+    {
+        put_u32(buffer, 0); /* Blob offset */
+        put_u32(buffer, 0); /* SODecl[0] offset */
+        put_u32(buffer, 0); /* SODecl[1] offset */
+        put_u32(buffer, 0); /* SODecl[2] offset */
+        put_u32(buffer, 0); /* SODecl[3] offset */
+        put_u32(buffer, 0); /* SODecl count */
+        put_u32(buffer, 0); /* Rasterizer stream */
+        put_u32(buffer, 0); /* Interface bindings count */
+        put_u32(buffer, 0); /* Interface initializer offset */
     }
 }
 
@@ -1719,7 +2002,7 @@ static void write_fx_4_object_variable(struct hlsl_ir_var *var, struct fx_write_
     uint32_t elements_count = hlsl_get_multiarray_size(var->data_type);
     struct vkd3d_bytecode_buffer *buffer = &fx->structured;
     uint32_t semantic_offset, bind_point = ~0u;
-    uint32_t name_offset, type_offset, i;
+    uint32_t name_offset, type_offset;
     struct hlsl_ctx *ctx = fx->ctx;
 
     if (var->reg_reservation.reg_type)
@@ -1756,9 +2039,14 @@ static void write_fx_4_object_variable(struct hlsl_ir_var *var, struct fx_write_
 
         case HLSL_CLASS_PIXEL_SHADER:
         case HLSL_CLASS_VERTEX_SHADER:
-            /* FIXME: write shader blobs, once parser support works. */
-            for (i = 0; i < elements_count; ++i)
-                put_u32(buffer, 0);
+            write_fx_4_shader_initializer(var, fx);
+            fx->shader_count += elements_count;
+            break;
+
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+            write_fx_5_shader_initializer(var, fx);
             fx->shader_count += elements_count;
             break;
 
@@ -1782,8 +2070,8 @@ static void write_fx_4_object_variable(struct hlsl_ir_var *var, struct fx_write_
             break;
 
         default:
-            hlsl_fixme(ctx, &ctx->location, "Writing initializer for object type %u is not implemented.",
-                    type->e.numeric.type);
+            hlsl_fixme(ctx, &ctx->location, "Writing initializer for object class %u is not implemented.",
+                    type->class);
     }
 
     write_fx_4_annotations(var->annotations, fx);
@@ -1883,6 +2171,12 @@ static bool is_supported_object_variable(const struct hlsl_ctx *ctx, const struc
         case HLSL_CLASS_SAMPLER:
         case HLSL_CLASS_TEXTURE:
             return true;
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+            if (ctx->profile->major_version < 5)
+                return false;
+            return true;
         case HLSL_CLASS_UAV:
             if (ctx->profile->major_version < 5)
                 return false;
diff --git a/libs/vkd3d/libs/vkd3d-shader/glsl.c b/libs/vkd3d/libs/vkd3d-shader/glsl.c
index 8725724a239..10e12ea56f2 100644
--- a/libs/vkd3d/libs/vkd3d-shader/glsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/glsl.c
@@ -18,10 +18,23 @@
 
 #include "vkd3d_shader_private.h"
 
+struct glsl_src
+{
+    struct vkd3d_string_buffer *str;
+};
+
+struct glsl_dst
+{
+    const struct vkd3d_shader_dst_param *vsir;
+    struct vkd3d_string_buffer *register_name;
+    struct vkd3d_string_buffer *mask;
+};
+
 struct vkd3d_glsl_generator
 {
     struct vsir_program *program;
-    struct vkd3d_string_buffer buffer;
+    struct vkd3d_string_buffer_cache string_buffers;
+    struct vkd3d_string_buffer *buffer;
     struct vkd3d_shader_location location;
     struct vkd3d_shader_message_context *message_context;
     unsigned int indent;
@@ -45,18 +58,149 @@ static void shader_glsl_print_indent(struct vkd3d_string_buffer *buffer, unsigne
     vkd3d_string_buffer_printf(buffer, "%*s", 4 * indent, "");
 }
 
+static void shader_glsl_print_register_name(struct vkd3d_string_buffer *buffer,
+        struct vkd3d_glsl_generator *gen, const struct vkd3d_shader_register *reg)
+{
+    switch (reg->type)
+    {
+        case VKD3DSPR_TEMP:
+            vkd3d_string_buffer_printf(buffer, "r[%u]", reg->idx[0].offset);
+            break;
+
+        default:
+            vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
+                    "Internal compiler error: Unhandled register type %#x.", reg->type);
+            vkd3d_string_buffer_printf(buffer, "<unrecognised register %#x>", reg->type);
+            break;
+    }
+}
+
+static void shader_glsl_print_swizzle(struct vkd3d_string_buffer *buffer, uint32_t swizzle, uint32_t mask)
+{
+    const char swizzle_chars[] = "xyzw";
+    unsigned int i;
+
+    vkd3d_string_buffer_printf(buffer, ".");
+    for (i = 0; i < VKD3D_VEC4_SIZE; ++i)
+    {
+        if (mask & (VKD3DSP_WRITEMASK_0 << i))
+            vkd3d_string_buffer_printf(buffer, "%c", swizzle_chars[vsir_swizzle_get_component(swizzle, i)]);
+    }
+}
+
+static void shader_glsl_print_write_mask(struct vkd3d_string_buffer *buffer, uint32_t write_mask)
+{
+    vkd3d_string_buffer_printf(buffer, ".");
+    if (write_mask & VKD3DSP_WRITEMASK_0)
+        vkd3d_string_buffer_printf(buffer, "x");
+    if (write_mask & VKD3DSP_WRITEMASK_1)
+        vkd3d_string_buffer_printf(buffer, "y");
+    if (write_mask & VKD3DSP_WRITEMASK_2)
+        vkd3d_string_buffer_printf(buffer, "z");
+    if (write_mask & VKD3DSP_WRITEMASK_3)
+        vkd3d_string_buffer_printf(buffer, "w");
+}
+
+static void glsl_src_cleanup(struct glsl_src *src, struct vkd3d_string_buffer_cache *cache)
+{
+    vkd3d_string_buffer_release(cache, src->str);
+}
+
+static void glsl_src_init(struct glsl_src *glsl_src, struct vkd3d_glsl_generator *gen,
+        const struct vkd3d_shader_src_param *vsir_src, uint32_t mask)
+{
+    const struct vkd3d_shader_register *reg = &vsir_src->reg;
+
+    glsl_src->str = vkd3d_string_buffer_get(&gen->string_buffers);
+
+    if (reg->non_uniform)
+        vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
+                "Internal compiler error: Unhandled 'non-uniform' modifer.");
+    if (vsir_src->modifiers)
+        vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
+                "Internal compiler error: Unhandled source modifier(s) %#x.", vsir_src->modifiers);
+
+    shader_glsl_print_register_name(glsl_src->str, gen, reg);
+    if (reg->dimension == VSIR_DIMENSION_VEC4)
+        shader_glsl_print_swizzle(glsl_src->str, vsir_src->swizzle, mask);
+}
+
+static void glsl_dst_cleanup(struct glsl_dst *dst, struct vkd3d_string_buffer_cache *cache)
+{
+    vkd3d_string_buffer_release(cache, dst->mask);
+    vkd3d_string_buffer_release(cache, dst->register_name);
+}
+
+static uint32_t glsl_dst_init(struct glsl_dst *glsl_dst, struct vkd3d_glsl_generator *gen,
+        const struct vkd3d_shader_instruction *ins, const struct vkd3d_shader_dst_param *vsir_dst)
+{
+    uint32_t write_mask = vsir_dst->write_mask;
+
+    if (ins->flags & VKD3DSI_PRECISE_XYZW)
+        vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
+                "Internal compiler error: Unhandled 'precise' modifer.");
+    if (vsir_dst->reg.non_uniform)
+        vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
+                "Internal compiler error: Unhandled 'non-uniform' modifer.");
+
+    glsl_dst->vsir = vsir_dst;
+    glsl_dst->register_name = vkd3d_string_buffer_get(&gen->string_buffers);
+    glsl_dst->mask = vkd3d_string_buffer_get(&gen->string_buffers);
+
+    shader_glsl_print_register_name(glsl_dst->register_name, gen, &vsir_dst->reg);
+    shader_glsl_print_write_mask(glsl_dst->mask, write_mask);
+
+    return write_mask;
+}
+
+static void VKD3D_PRINTF_FUNC(3, 4) shader_glsl_print_assignment(
+        struct vkd3d_glsl_generator *gen, struct glsl_dst *dst, const char *format, ...)
+{
+    va_list args;
+
+    if (dst->vsir->shift)
+        vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
+                "Internal compiler error: Unhandled destination shift %#x.", dst->vsir->shift);
+    if (dst->vsir->modifiers)
+        vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
+                "Internal compiler error: Unhandled destination modifier(s) %#x.", dst->vsir->modifiers);
+
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "%s%s = ", dst->register_name->buffer, dst->mask->buffer);
+
+    va_start(args, format);
+    vkd3d_string_buffer_vprintf(gen->buffer, format, args);
+    va_end(args);
+
+    vkd3d_string_buffer_printf(gen->buffer, ";\n");
+}
+
 static void shader_glsl_unhandled(struct vkd3d_glsl_generator *gen, const struct vkd3d_shader_instruction *ins)
 {
-    shader_glsl_print_indent(&gen->buffer, gen->indent);
-    vkd3d_string_buffer_printf(&gen->buffer, "/* <unhandled instruction %#x> */\n", ins->opcode);
+    shader_glsl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "/* <unhandled instruction %#x> */\n", ins->opcode);
     vkd3d_glsl_compiler_error(gen, VKD3D_SHADER_ERROR_GLSL_INTERNAL,
             "Internal compiler error: Unhandled instruction %#x.", ins->opcode);
 }
 
-static void shader_glsl_ret(struct vkd3d_glsl_generator *generator,
-        const struct vkd3d_shader_instruction *ins)
+static void shader_glsl_mov(struct vkd3d_glsl_generator *gen, const struct vkd3d_shader_instruction *ins)
+{
+    struct glsl_src src;
+    struct glsl_dst dst;
+    uint32_t mask;
+
+    mask = glsl_dst_init(&dst, gen, ins, &ins->dst[0]);
+    glsl_src_init(&src, gen, &ins->src[0], mask);
+
+    shader_glsl_print_assignment(gen, &dst, "%s", src.str->buffer);
+
+    glsl_src_cleanup(&src, &gen->string_buffers);
+    glsl_dst_cleanup(&dst, &gen->string_buffers);
+}
+
+static void shader_glsl_ret(struct vkd3d_glsl_generator *gen, const struct vkd3d_shader_instruction *ins)
 {
-    const struct vkd3d_shader_version *version = &generator->program->shader_version;
+    const struct vkd3d_shader_version *version = &gen->program->shader_version;
 
     /*
     * TODO: Implement in_subroutine
@@ -64,45 +208,59 @@ static void shader_glsl_ret(struct vkd3d_glsl_generator *generator,
     */
     if (version->major >= 4)
     {
-        shader_glsl_print_indent(&generator->buffer, generator->indent);
-        vkd3d_string_buffer_printf(&generator->buffer, "return;\n");
+        shader_glsl_print_indent(gen->buffer, gen->indent);
+        vkd3d_string_buffer_printf(gen->buffer, "return;\n");
     }
 }
 
-static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *generator,
-        const struct vkd3d_shader_instruction *instruction)
+static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *gen,
+        const struct vkd3d_shader_instruction *ins)
 {
-    generator->location = instruction->location;
+    gen->location = ins->location;
 
-    switch (instruction->opcode)
+    switch (ins->opcode)
     {
         case VKD3DSIH_DCL_INPUT:
         case VKD3DSIH_DCL_OUTPUT:
         case VKD3DSIH_DCL_OUTPUT_SIV:
         case VKD3DSIH_NOP:
             break;
+        case VKD3DSIH_MOV:
+            shader_glsl_mov(gen, ins);
+            break;
         case VKD3DSIH_RET:
-            shader_glsl_ret(generator, instruction);
+            shader_glsl_ret(gen, ins);
             break;
         default:
-            shader_glsl_unhandled(generator, instruction);
+            shader_glsl_unhandled(gen, ins);
             break;
     }
 }
 
+static void shader_glsl_generate_declarations(struct vkd3d_glsl_generator *gen)
+{
+    const struct vsir_program *program = gen->program;
+    struct vkd3d_string_buffer *buffer = gen->buffer;
+
+    if (program->temp_count)
+        vkd3d_string_buffer_printf(buffer, "vec4 r[%u];\n\n", program->temp_count);
+}
+
 static int vkd3d_glsl_generator_generate(struct vkd3d_glsl_generator *gen, struct vkd3d_shader_code *out)
 {
     const struct vkd3d_shader_instruction_array *instructions = &gen->program->instructions;
-    struct vkd3d_string_buffer *buffer = &gen->buffer;
+    struct vkd3d_string_buffer *buffer = gen->buffer;
     unsigned int i;
     void *code;
 
-    ERR("Generating a GLSL shader. This is unsupported; you get to keep all the pieces if it breaks.\n");
+    MESSAGE("Generating a GLSL shader. This is unsupported; you get to keep all the pieces if it breaks.\n");
 
     vkd3d_string_buffer_printf(buffer, "#version 440\n\n");
 
     vkd3d_string_buffer_printf(buffer, "/* Generated by %s. */\n\n", vkd3d_shader_get_version(NULL, NULL));
 
+    shader_glsl_generate_declarations(gen);
+
     vkd3d_string_buffer_printf(buffer, "void main()\n{\n");
 
     ++gen->indent;
@@ -132,7 +290,8 @@ static int vkd3d_glsl_generator_generate(struct vkd3d_glsl_generator *gen, struc
 
 static void vkd3d_glsl_generator_cleanup(struct vkd3d_glsl_generator *gen)
 {
-    vkd3d_string_buffer_cleanup(&gen->buffer);
+    vkd3d_string_buffer_release(&gen->string_buffers, gen->buffer);
+    vkd3d_string_buffer_cache_cleanup(&gen->string_buffers);
 }
 
 static void vkd3d_glsl_generator_init(struct vkd3d_glsl_generator *gen,
@@ -140,7 +299,8 @@ static void vkd3d_glsl_generator_init(struct vkd3d_glsl_generator *gen,
 {
     memset(gen, 0, sizeof(*gen));
     gen->program = program;
-    vkd3d_string_buffer_init(&gen->buffer);
+    vkd3d_string_buffer_cache_init(&gen->string_buffers);
+    gen->buffer = vkd3d_string_buffer_get(&gen->string_buffers);
     gen->message_context = message_context;
 }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 1526d7b02a9..7f85195382d 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -134,7 +134,7 @@ struct hlsl_ir_var *hlsl_get_var(struct hlsl_scope *scope, const char *name)
     return hlsl_get_var(scope->upper, name);
 }
 
-static void free_state_block_entry(struct hlsl_state_block_entry *entry)
+void hlsl_free_state_block_entry(struct hlsl_state_block_entry *entry)
 {
     unsigned int i;
 
@@ -151,9 +151,9 @@ void hlsl_free_state_block(struct hlsl_state_block *state_block)
 {
     unsigned int k;
 
-    assert(state_block);
+    VKD3D_ASSERT(state_block);
     for (k = 0; k < state_block->count; ++k)
-        free_state_block_entry(state_block->entries[k]);
+        hlsl_free_state_block_entry(state_block->entries[k]);
     vkd3d_free(state_block->entries);
     vkd3d_free(state_block);
 }
@@ -381,6 +381,10 @@ static void hlsl_type_calculate_reg_size(struct hlsl_ctx *ctx, struct hlsl_type
         case HLSL_CLASS_VERTEX_SHADER:
         case HLSL_CLASS_VOID:
         case HLSL_CLASS_CONSTANT_BUFFER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             break;
     }
 }
@@ -451,6 +455,10 @@ static bool type_is_single_component(const struct hlsl_type *type)
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_VERTEX_SHADER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             return true;
 
         case HLSL_CLASS_VECTOR:
@@ -482,13 +490,13 @@ static unsigned int traverse_path_from_component_index(struct hlsl_ctx *ctx,
     struct hlsl_type *type = *type_ptr;
     unsigned int index = *index_ptr;
 
-    assert(!type_is_single_component(type));
-    assert(index < hlsl_type_component_count(type));
+    VKD3D_ASSERT(!type_is_single_component(type));
+    VKD3D_ASSERT(index < hlsl_type_component_count(type));
 
     switch (type->class)
     {
         case HLSL_CLASS_VECTOR:
-            assert(index < type->dimx);
+            VKD3D_ASSERT(index < type->dimx);
             *type_ptr = hlsl_get_scalar_type(ctx, type->e.numeric.type);
             *index_ptr = 0;
             return index;
@@ -498,7 +506,7 @@ static unsigned int traverse_path_from_component_index(struct hlsl_ctx *ctx,
             unsigned int y = index / type->dimx, x = index % type->dimx;
             bool row_major = hlsl_type_is_row_major(type);
 
-            assert(index < type->dimx * type->dimy);
+            VKD3D_ASSERT(index < type->dimx * type->dimy);
             *type_ptr = hlsl_get_vector_type(ctx, type->e.numeric.type, row_major ? type->dimx : type->dimy);
             *index_ptr = row_major ? x : y;
             return row_major ? y : x;
@@ -512,7 +520,7 @@ static unsigned int traverse_path_from_component_index(struct hlsl_ctx *ctx,
             *type_ptr = type->e.array.type;
             *index_ptr = index % elem_comp_count;
             array_index = index / elem_comp_count;
-            assert(array_index < type->e.array.elements_count);
+            VKD3D_ASSERT(array_index < type->e.array.elements_count);
             return array_index;
         }
 
@@ -603,7 +611,11 @@ unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_ty
             case HLSL_CLASS_TEXTURE:
             case HLSL_CLASS_UAV:
             case HLSL_CLASS_VERTEX_SHADER:
-                assert(idx == 0);
+            case HLSL_CLASS_COMPUTE_SHADER:
+            case HLSL_CLASS_DOMAIN_SHADER:
+            case HLSL_CLASS_HULL_SHADER:
+            case HLSL_CLASS_GEOMETRY_SHADER:
+                VKD3D_ASSERT(idx == 0);
                 break;
 
             case HLSL_CLASS_EFFECT_GROUP:
@@ -658,9 +670,9 @@ bool hlsl_init_deref_from_index_chain(struct hlsl_ctx *ctx, struct hlsl_deref *d
     deref->rel_offset.node = NULL;
     deref->const_offset = 0;
 
-    assert(chain);
+    VKD3D_ASSERT(chain);
     if (chain->type == HLSL_IR_INDEX)
-        assert(!hlsl_index_is_noncontiguous(hlsl_ir_index(chain)));
+        VKD3D_ASSERT(!hlsl_index_is_noncontiguous(hlsl_ir_index(chain)));
 
     /* Find the length of the index chain */
     chain_len = 0;
@@ -707,7 +719,7 @@ bool hlsl_init_deref_from_index_chain(struct hlsl_ctx *ctx, struct hlsl_deref *d
         chain_len++;
         ptr = index->val.node;
     }
-    assert(deref->path_len == load->src.path_len + chain_len);
+    VKD3D_ASSERT(deref->path_len == load->src.path_len + chain_len);
 
     return true;
 }
@@ -717,7 +729,7 @@ struct hlsl_type *hlsl_deref_get_type(struct hlsl_ctx *ctx, const struct hlsl_de
     struct hlsl_type *type;
     unsigned int i;
 
-    assert(deref);
+    VKD3D_ASSERT(deref);
 
     if (hlsl_deref_is_lowered(deref))
         return deref->data_type;
@@ -772,7 +784,7 @@ static bool init_deref_from_component_index(struct hlsl_ctx *ctx, struct hlsl_bl
         hlsl_src_from_node(&deref->path[deref_path_len++], c);
     }
 
-    assert(deref_path_len == deref->path_len);
+    VKD3D_ASSERT(deref_path_len == deref->path_len);
 
     return true;
 }
@@ -780,7 +792,7 @@ static bool init_deref_from_component_index(struct hlsl_ctx *ctx, struct hlsl_bl
 struct hlsl_type *hlsl_get_element_type_from_path_index(struct hlsl_ctx *ctx, const struct hlsl_type *type,
         struct hlsl_ir_node *idx)
 {
-    assert(idx);
+    VKD3D_ASSERT(idx);
 
     switch (type->class)
     {
@@ -800,7 +812,7 @@ struct hlsl_type *hlsl_get_element_type_from_path_index(struct hlsl_ctx *ctx, co
         {
             struct hlsl_ir_constant *c = hlsl_ir_constant(idx);
 
-            assert(c->value.u[0].u < type->e.record.field_count);
+            VKD3D_ASSERT(c->value.u[0].u < type->e.record.field_count);
             return type->e.record.fields[c->value.u[0].u].type;
         }
 
@@ -1003,6 +1015,10 @@ unsigned int hlsl_type_component_count(const struct hlsl_type *type)
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_VERTEX_SHADER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             return 1;
 
         case HLSL_CLASS_EFFECT_GROUP:
@@ -1090,6 +1106,10 @@ bool hlsl_types_are_equal(const struct hlsl_type *t1, const struct hlsl_type *t2
         case HLSL_CLASS_STRING:
         case HLSL_CLASS_VERTEX_SHADER:
         case HLSL_CLASS_VOID:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             return true;
     }
 
@@ -1310,7 +1330,7 @@ bool hlsl_copy_deref(struct hlsl_ctx *ctx, struct hlsl_deref *deref, const struc
     if (!other)
         return true;
 
-    assert(!hlsl_deref_is_lowered(other));
+    VKD3D_ASSERT(!hlsl_deref_is_lowered(other));
 
     if (!init_deref(ctx, deref, other->var, other->path_len))
         return false;
@@ -1367,8 +1387,8 @@ struct hlsl_ir_node *hlsl_new_store_index(struct hlsl_ctx *ctx, const struct hls
     struct hlsl_ir_store *store;
     unsigned int i;
 
-    assert(lhs);
-    assert(!hlsl_deref_is_lowered(lhs));
+    VKD3D_ASSERT(lhs);
+    VKD3D_ASSERT(!hlsl_deref_is_lowered(lhs));
 
     if (!(store = hlsl_alloc(ctx, sizeof(*store))))
         return NULL;
@@ -1439,7 +1459,7 @@ struct hlsl_ir_node *hlsl_new_constant(struct hlsl_ctx *ctx, struct hlsl_type *t
 {
     struct hlsl_ir_constant *c;
 
-    assert(type->class <= HLSL_CLASS_VECTOR);
+    VKD3D_ASSERT(type->class <= HLSL_CLASS_VECTOR);
 
     if (!(c = hlsl_alloc(ctx, sizeof(*c))))
         return NULL;
@@ -1484,6 +1504,24 @@ struct hlsl_ir_node *hlsl_new_uint_constant(struct hlsl_ctx *ctx, unsigned int n
     return hlsl_new_constant(ctx, hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), &value, loc);
 }
 
+struct hlsl_ir_node *hlsl_new_string_constant(struct hlsl_ctx *ctx, const char *str,
+        const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_string_constant *s;
+
+    if (!(s = hlsl_alloc(ctx, sizeof(*s))))
+        return NULL;
+
+    init_node(&s->node, HLSL_IR_STRING_CONSTANT, ctx->builtin_types.string, loc);
+
+    if (!(s->string = hlsl_strdup(ctx, str)))
+    {
+        hlsl_free_instr(&s->node);
+        return NULL;
+    }
+    return &s->node;
+}
+
 struct hlsl_ir_node *hlsl_new_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
         struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS],
         struct hlsl_type *data_type, const struct vkd3d_shader_location *loc)
@@ -1513,7 +1551,7 @@ struct hlsl_ir_node *hlsl_new_binary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_exp
 {
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {arg1, arg2};
 
-    assert(hlsl_types_are_equal(arg1->data_type, arg2->data_type));
+    VKD3D_ASSERT(hlsl_types_are_equal(arg1->data_type, arg2->data_type));
     return hlsl_new_expr(ctx, op, operands, arg1->data_type, &arg1->loc);
 }
 
@@ -1522,8 +1560,8 @@ struct hlsl_ir_node *hlsl_new_ternary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_ex
 {
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {arg1, arg2, arg3};
 
-    assert(hlsl_types_are_equal(arg1->data_type, arg2->data_type));
-    assert(hlsl_types_are_equal(arg1->data_type, arg3->data_type));
+    VKD3D_ASSERT(hlsl_types_are_equal(arg1->data_type, arg2->data_type));
+    VKD3D_ASSERT(hlsl_types_are_equal(arg1->data_type, arg3->data_type));
     return hlsl_new_expr(ctx, op, operands, arg1->data_type, &arg1->loc);
 }
 
@@ -1585,7 +1623,7 @@ struct hlsl_ir_load *hlsl_new_load_index(struct hlsl_ctx *ctx, const struct hlsl
     struct hlsl_type *type;
     unsigned int i;
 
-    assert(!hlsl_deref_is_lowered(deref));
+    VKD3D_ASSERT(!hlsl_deref_is_lowered(deref));
 
     type = hlsl_deref_get_type(ctx, deref);
     if (idx)
@@ -1614,7 +1652,7 @@ struct hlsl_ir_load *hlsl_new_load_parent(struct hlsl_ctx *ctx, const struct hls
     /* This deref can only exists temporarily because it is not the real owner of its members. */
     struct hlsl_deref tmp_deref;
 
-    assert(deref->path_len >= 1);
+    VKD3D_ASSERT(deref->path_len >= 1);
 
     tmp_deref = *deref;
     tmp_deref.path_len = deref->path_len - 1;
@@ -1719,7 +1757,7 @@ struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, uint32_t s, unsigned
 
     if (!(swizzle = hlsl_alloc(ctx, sizeof(*swizzle))))
         return NULL;
-    assert(hlsl_is_numeric_type(val->data_type));
+    VKD3D_ASSERT(hlsl_is_numeric_type(val->data_type));
     if (components == 1)
         type = hlsl_get_scalar_type(ctx, val->data_type->e.numeric.type);
     else
@@ -1893,7 +1931,7 @@ static bool clone_deref(struct hlsl_ctx *ctx, struct clone_instr_map *map,
 {
     unsigned int i;
 
-    assert(!hlsl_deref_is_lowered(src));
+    VKD3D_ASSERT(!hlsl_deref_is_lowered(src));
 
     if (!init_deref(ctx, dst, src->var, src->path_len))
         return false;
@@ -2039,6 +2077,11 @@ static struct hlsl_ir_node *clone_resource_store(struct hlsl_ctx *ctx,
     return &dst->node;
 }
 
+static struct hlsl_ir_node *clone_string_constant(struct hlsl_ctx *ctx, struct hlsl_ir_string_constant *src)
+{
+    return hlsl_new_string_constant(ctx, src->string, &src->node.loc);
+}
+
 static struct hlsl_ir_node *clone_store(struct hlsl_ctx *ctx, struct clone_instr_map *map, struct hlsl_ir_store *src)
 {
     struct hlsl_ir_store *dst;
@@ -2081,6 +2124,43 @@ static struct hlsl_ir_node *clone_stateblock_constant(struct hlsl_ctx *ctx,
     return hlsl_new_stateblock_constant(ctx, constant->name, &constant->node.loc);
 }
 
+struct hlsl_state_block_entry *clone_stateblock_entry(struct hlsl_ctx *ctx,
+        struct hlsl_state_block_entry *src, const char *name, bool lhs_has_index,
+        unsigned int lhs_index, unsigned int arg_index)
+{
+    struct hlsl_state_block_entry *entry;
+    struct clone_instr_map map = { 0 };
+
+    if (!(entry = hlsl_alloc(ctx, sizeof(*entry))))
+        return NULL;
+    entry->name = hlsl_strdup(ctx, name);
+    entry->lhs_has_index = lhs_has_index;
+    entry->lhs_index = lhs_index;
+    if (!(entry->instrs = hlsl_alloc(ctx, sizeof(*entry->instrs))))
+    {
+        hlsl_free_state_block_entry(entry);
+        return NULL;
+    }
+
+    entry->args_count = 1;
+    if (!(entry->args = hlsl_alloc(ctx, sizeof(*entry->args) * entry->args_count)))
+    {
+        hlsl_free_state_block_entry(entry);
+        return NULL;
+    }
+
+    hlsl_block_init(entry->instrs);
+    if (!clone_block(ctx, entry->instrs, src->instrs, &map))
+    {
+        hlsl_free_state_block_entry(entry);
+        return NULL;
+    }
+    clone_src(&map, entry->args, &src->args[arg_index]);
+    vkd3d_free(map.instrs);
+
+    return entry;
+}
+
 void hlsl_free_ir_switch_case(struct hlsl_ir_switch_case *c)
 {
     hlsl_block_cleanup(&c->body);
@@ -2168,6 +2248,9 @@ static struct hlsl_ir_node *clone_instr(struct hlsl_ctx *ctx,
         case HLSL_IR_RESOURCE_STORE:
             return clone_resource_store(ctx, map, hlsl_ir_resource_store(instr));
 
+        case HLSL_IR_STRING_CONSTANT:
+            return clone_string_constant(ctx, hlsl_ir_string_constant(instr));
+
         case HLSL_IR_STORE:
             return clone_store(ctx, map, hlsl_ir_store(instr));
 
@@ -2296,7 +2379,7 @@ void hlsl_pop_scope(struct hlsl_ctx *ctx)
 {
     struct hlsl_scope *prev_scope = ctx->cur_scope->upper;
 
-    assert(prev_scope);
+    VKD3D_ASSERT(prev_scope);
     TRACE("Popping current scope.\n");
     ctx->cur_scope = prev_scope;
 }
@@ -2374,17 +2457,17 @@ struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const stru
     switch (type->class)
     {
         case HLSL_CLASS_SCALAR:
-            assert(type->e.numeric.type < ARRAY_SIZE(base_types));
+            VKD3D_ASSERT(type->e.numeric.type < ARRAY_SIZE(base_types));
             vkd3d_string_buffer_printf(string, "%s", base_types[type->e.numeric.type]);
             return string;
 
         case HLSL_CLASS_VECTOR:
-            assert(type->e.numeric.type < ARRAY_SIZE(base_types));
+            VKD3D_ASSERT(type->e.numeric.type < ARRAY_SIZE(base_types));
             vkd3d_string_buffer_printf(string, "%s%u", base_types[type->e.numeric.type], type->dimx);
             return string;
 
         case HLSL_CLASS_MATRIX:
-            assert(type->e.numeric.type < ARRAY_SIZE(base_types));
+            VKD3D_ASSERT(type->e.numeric.type < ARRAY_SIZE(base_types));
             vkd3d_string_buffer_printf(string, "%s%ux%u", base_types[type->e.numeric.type], type->dimy, type->dimx);
             return string;
 
@@ -2422,15 +2505,15 @@ struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const stru
                 return string;
             }
 
-            assert(hlsl_is_numeric_type(type->e.resource.format));
-            assert(type->e.resource.format->e.numeric.type < ARRAY_SIZE(base_types));
+            VKD3D_ASSERT(hlsl_is_numeric_type(type->e.resource.format));
+            VKD3D_ASSERT(type->e.resource.format->e.numeric.type < ARRAY_SIZE(base_types));
             if (type->sampler_dim == HLSL_SAMPLER_DIM_BUFFER)
             {
                 vkd3d_string_buffer_printf(string, "Buffer");
             }
             else
             {
-                assert(type->sampler_dim < ARRAY_SIZE(dimensions));
+                VKD3D_ASSERT(type->sampler_dim < ARRAY_SIZE(dimensions));
                 vkd3d_string_buffer_printf(string, "Texture%s", dimensions[type->sampler_dim]);
             }
             if ((inner_string = hlsl_type_to_string(ctx, type->e.resource.format)))
@@ -2475,6 +2558,10 @@ struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const stru
         case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_VERTEX_SHADER:
         case HLSL_CLASS_VOID:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             break;
     }
 
@@ -2571,19 +2658,21 @@ const char *hlsl_node_type_to_string(enum hlsl_ir_node_type type)
 {
     static const char * const names[] =
     {
-        [HLSL_IR_CALL          ] = "HLSL_IR_CALL",
-        [HLSL_IR_CONSTANT      ] = "HLSL_IR_CONSTANT",
-        [HLSL_IR_EXPR          ] = "HLSL_IR_EXPR",
-        [HLSL_IR_IF            ] = "HLSL_IR_IF",
-        [HLSL_IR_INDEX         ] = "HLSL_IR_INDEX",
-        [HLSL_IR_LOAD          ] = "HLSL_IR_LOAD",
-        [HLSL_IR_LOOP          ] = "HLSL_IR_LOOP",
-        [HLSL_IR_JUMP          ] = "HLSL_IR_JUMP",
-        [HLSL_IR_RESOURCE_LOAD ] = "HLSL_IR_RESOURCE_LOAD",
-        [HLSL_IR_RESOURCE_STORE] = "HLSL_IR_RESOURCE_STORE",
-        [HLSL_IR_STORE         ] = "HLSL_IR_STORE",
-        [HLSL_IR_SWITCH        ] = "HLSL_IR_SWITCH",
-        [HLSL_IR_SWIZZLE       ] = "HLSL_IR_SWIZZLE",
+        [HLSL_IR_CALL           ] = "HLSL_IR_CALL",
+        [HLSL_IR_CONSTANT       ] = "HLSL_IR_CONSTANT",
+        [HLSL_IR_EXPR           ] = "HLSL_IR_EXPR",
+        [HLSL_IR_IF             ] = "HLSL_IR_IF",
+        [HLSL_IR_INDEX          ] = "HLSL_IR_INDEX",
+        [HLSL_IR_LOAD           ] = "HLSL_IR_LOAD",
+        [HLSL_IR_LOOP           ] = "HLSL_IR_LOOP",
+        [HLSL_IR_JUMP           ] = "HLSL_IR_JUMP",
+        [HLSL_IR_RESOURCE_LOAD  ] = "HLSL_IR_RESOURCE_LOAD",
+        [HLSL_IR_RESOURCE_STORE ] = "HLSL_IR_RESOURCE_STORE",
+        [HLSL_IR_STRING_CONSTANT] = "HLSL_IR_STRING_CONSTANT",
+        [HLSL_IR_STORE          ] = "HLSL_IR_STORE",
+        [HLSL_IR_SWITCH         ] = "HLSL_IR_SWITCH",
+        [HLSL_IR_SWIZZLE        ] = "HLSL_IR_SWIZZLE",
+        [HLSL_IR_STATEBLOCK_CONSTANT] = "HLSL_IR_STATEBLOCK_CONSTANT",
     };
 
     if (type >= ARRAY_SIZE(names))
@@ -2602,7 +2691,7 @@ const char *hlsl_jump_type_to_string(enum hlsl_ir_jump_type type)
         [HLSL_IR_JUMP_RETURN]      = "HLSL_IR_JUMP_RETURN",
     };
 
-    assert(type < ARRAY_SIZE(names));
+    VKD3D_ASSERT(type < ARRAY_SIZE(names));
     return names[type];
 }
 
@@ -2692,7 +2781,7 @@ const char *debug_hlsl_writemask(unsigned int writemask)
     char string[5];
     unsigned int i = 0, pos = 0;
 
-    assert(!(writemask & ~VKD3DSP_WRITEMASK_ALL));
+    VKD3D_ASSERT(!(writemask & ~VKD3DSP_WRITEMASK_ALL));
 
     while (writemask)
     {
@@ -2711,7 +2800,7 @@ const char *debug_hlsl_swizzle(uint32_t swizzle, unsigned int size)
     char string[5];
     unsigned int i;
 
-    assert(size <= ARRAY_SIZE(components));
+    VKD3D_ASSERT(size <= ARRAY_SIZE(components));
     for (i = 0; i < size; ++i)
         string[i] = components[hlsl_swizzle_get_component(swizzle, i)];
     string[size] = 0;
@@ -2808,6 +2897,7 @@ const char *debug_hlsl_expr_op(enum hlsl_ir_expr_op op)
         [HLSL_OP1_DSY_COARSE]   = "dsy_coarse",
         [HLSL_OP1_DSY_FINE]     = "dsy_fine",
         [HLSL_OP1_EXP2]         = "exp2",
+        [HLSL_OP1_F16TOF32]     = "f16tof32",
         [HLSL_OP1_FLOOR]        = "floor",
         [HLSL_OP1_FRACT]        = "fract",
         [HLSL_OP1_LOG2]         = "log2",
@@ -2935,7 +3025,7 @@ static void dump_ir_resource_load(struct vkd3d_string_buffer *buffer, const stru
         [HLSL_RESOURCE_RESINFO] = "resinfo",
     };
 
-    assert(load->load_type < ARRAY_SIZE(type_names));
+    VKD3D_ASSERT(load->load_type < ARRAY_SIZE(type_names));
     vkd3d_string_buffer_printf(buffer, "%s(resource = ", type_names[load->load_type]);
     dump_deref(buffer, &load->resource);
     vkd3d_string_buffer_printf(buffer, ", sampler = ");
@@ -2989,6 +3079,11 @@ static void dump_ir_resource_store(struct vkd3d_string_buffer *buffer, const str
     vkd3d_string_buffer_printf(buffer, ")");
 }
 
+static void dump_ir_string(struct vkd3d_string_buffer *buffer, const struct hlsl_ir_string_constant *string)
+{
+    vkd3d_string_buffer_printf(buffer, "\"%s\"", debugstr_a(string->string));
+}
+
 static void dump_ir_store(struct vkd3d_string_buffer *buffer, const struct hlsl_ir_store *store)
 {
     vkd3d_string_buffer_printf(buffer, "= (");
@@ -3108,6 +3203,10 @@ static void dump_instr(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer,
             dump_ir_resource_store(buffer, hlsl_ir_resource_store(instr));
             break;
 
+        case HLSL_IR_STRING_CONSTANT:
+            dump_ir_string(buffer, hlsl_ir_string_constant(instr));
+            break;
+
         case HLSL_IR_STORE:
             dump_ir_store(buffer, hlsl_ir_store(instr));
             break;
@@ -3177,8 +3276,8 @@ void hlsl_replace_node(struct hlsl_ir_node *old, struct hlsl_ir_node *new)
 {
     struct hlsl_src *src, *next;
 
-    assert(old->data_type->dimx == new->data_type->dimx);
-    assert(old->data_type->dimy == new->data_type->dimy);
+    VKD3D_ASSERT(old->data_type->dimx == new->data_type->dimx);
+    VKD3D_ASSERT(old->data_type->dimy == new->data_type->dimy);
 
     LIST_FOR_EACH_ENTRY_SAFE(src, next, &old->uses, struct hlsl_src, entry)
     {
@@ -3286,6 +3385,12 @@ static void free_ir_resource_load(struct hlsl_ir_resource_load *load)
     vkd3d_free(load);
 }
 
+static void free_ir_string_constant(struct hlsl_ir_string_constant *string)
+{
+    vkd3d_free(string->string);
+    vkd3d_free(string);
+}
+
 static void free_ir_resource_store(struct hlsl_ir_resource_store *store)
 {
     hlsl_cleanup_deref(&store->resource);
@@ -3330,7 +3435,7 @@ static void free_ir_stateblock_constant(struct hlsl_ir_stateblock_constant *cons
 
 void hlsl_free_instr(struct hlsl_ir_node *node)
 {
-    assert(list_empty(&node->uses));
+    VKD3D_ASSERT(list_empty(&node->uses));
 
     switch (node->type)
     {
@@ -3370,6 +3475,10 @@ void hlsl_free_instr(struct hlsl_ir_node *node)
             free_ir_resource_load(hlsl_ir_resource_load(node));
             break;
 
+        case HLSL_IR_STRING_CONSTANT:
+            free_ir_string_constant(hlsl_ir_string_constant(node));
+            break;
+
         case HLSL_IR_RESOURCE_STORE:
             free_ir_resource_store(hlsl_ir_resource_store(node));
             break;
@@ -3813,6 +3922,7 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
         ctx->builtin_types.sampler[bt] = type;
     }
 
+    ctx->builtin_types.string = hlsl_new_simple_type(ctx, "STRING", HLSL_CLASS_STRING);
     ctx->builtin_types.Void = hlsl_new_simple_type(ctx, "void", HLSL_CLASS_VOID);
     hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "DepthStencilView", HLSL_CLASS_DEPTH_STENCIL_VIEW));
     hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "DepthStencilState", HLSL_CLASS_DEPTH_STENCIL_STATE));
@@ -3821,9 +3931,12 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
     hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "pixelshader", HLSL_CLASS_PIXEL_SHADER));
     hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "RasterizerState", HLSL_CLASS_RASTERIZER_STATE));
     hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "RenderTargetView", HLSL_CLASS_RENDER_TARGET_VIEW));
-    hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "STRING", HLSL_CLASS_STRING));
     hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "texture", HLSL_CLASS_TEXTURE));
     hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "vertexshader", HLSL_CLASS_VERTEX_SHADER));
+    hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "ComputeShader", HLSL_CLASS_COMPUTE_SHADER));
+    hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "DomainShader", HLSL_CLASS_DOMAIN_SHADER));
+    hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "HullShader", HLSL_CLASS_HULL_SHADER));
+    hlsl_scope_add_type(ctx->globals, hlsl_new_simple_type(ctx, "GeometryShader", HLSL_CLASS_GEOMETRY_SHADER));
 
     for (i = 0; i < ARRAY_SIZE(effect_types); ++i)
     {
@@ -4154,6 +4267,7 @@ struct hlsl_ir_function_decl *hlsl_compile_internal_function(struct hlsl_ctx *ct
     /* Save and restore everything that matters.
      * Note that saving the scope stack is hard, and shouldn't be necessary. */
 
+    hlsl_push_scope(ctx);
     ctx->scanner = NULL;
     ctx->internal_func_name = internal_name->buffer;
     ctx->cur_function = NULL;
@@ -4161,6 +4275,7 @@ struct hlsl_ir_function_decl *hlsl_compile_internal_function(struct hlsl_ctx *ct
     ctx->scanner = saved_scanner;
     ctx->internal_func_name = saved_internal_func_name;
     ctx->cur_function = saved_cur_function;
+    hlsl_pop_scope(ctx);
     if (ret)
     {
         ERR("Failed to compile intrinsic, error %u.\n", ret);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index 4411546e269..7e8cd774ae2 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -91,6 +91,10 @@ enum hlsl_type_class
     HLSL_CLASS_TEXTURE,
     HLSL_CLASS_UAV,
     HLSL_CLASS_VERTEX_SHADER,
+    HLSL_CLASS_COMPUTE_SHADER,
+    HLSL_CLASS_DOMAIN_SHADER,
+    HLSL_CLASS_HULL_SHADER,
+    HLSL_CLASS_GEOMETRY_SHADER,
     HLSL_CLASS_CONSTANT_BUFFER,
     HLSL_CLASS_VOID,
 };
@@ -306,6 +310,7 @@ enum hlsl_ir_node_type
     HLSL_IR_JUMP,
     HLSL_IR_RESOURCE_LOAD,
     HLSL_IR_RESOURCE_STORE,
+    HLSL_IR_STRING_CONSTANT,
     HLSL_IR_STORE,
     HLSL_IR_SWIZZLE,
     HLSL_IR_SWITCH,
@@ -653,6 +658,7 @@ enum hlsl_ir_expr_op
     HLSL_OP1_DSY_COARSE,
     HLSL_OP1_DSY_FINE,
     HLSL_OP1_EXP2,
+    HLSL_OP1_F16TOF32,
     HLSL_OP1_FLOOR,
     HLSL_OP1_FRACT,
     HLSL_OP1_LOG2,
@@ -838,6 +844,12 @@ struct hlsl_ir_constant
     struct hlsl_reg reg;
 };
 
+struct hlsl_ir_string_constant
+{
+    struct hlsl_ir_node node;
+    char *string;
+};
+
 /* Stateblock constants are undeclared values found on state blocks or technique passes descriptions,
  *   that do not concern regular pixel, vertex, or compute shaders, except for parsing. */
 struct hlsl_ir_stateblock_constant
@@ -984,6 +996,7 @@ struct hlsl_ctx
         /* matrix[HLSL_TYPE_FLOAT][1][3] is a float4x2, i.e. dimx = 2, dimy = 4 */
         struct hlsl_type *matrix[HLSL_TYPE_LAST_SCALAR + 1][4][4];
         struct hlsl_type *sampler[HLSL_SAMPLER_DIM_LAST_SAMPLER + 1];
+        struct hlsl_type *string;
         struct hlsl_type *Void;
     } builtin_types;
 
@@ -1001,6 +1014,8 @@ struct hlsl_ctx
         } *regs;
         size_t count, size;
     } constant_defs;
+    /* 'c' registers where the constants expected by SM2 sincos are stored. */
+    struct hlsl_reg d3dsincosconst1, d3dsincosconst2;
     /* Number of temp. registers required for the shader to run, i.e. the largest temp register
      *   index that will be used in the output bytecode (+1). */
     uint32_t temp_count;
@@ -1047,85 +1062,91 @@ struct hlsl_resource_load_params
 
 static inline struct hlsl_ir_call *hlsl_ir_call(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_CALL);
+    VKD3D_ASSERT(node->type == HLSL_IR_CALL);
     return CONTAINING_RECORD(node, struct hlsl_ir_call, node);
 }
 
 static inline struct hlsl_ir_constant *hlsl_ir_constant(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_CONSTANT);
+    VKD3D_ASSERT(node->type == HLSL_IR_CONSTANT);
     return CONTAINING_RECORD(node, struct hlsl_ir_constant, node);
 }
 
+static inline struct hlsl_ir_string_constant *hlsl_ir_string_constant(const struct hlsl_ir_node *node)
+{
+    VKD3D_ASSERT(node->type == HLSL_IR_STRING_CONSTANT);
+    return CONTAINING_RECORD(node, struct hlsl_ir_string_constant, node);
+}
+
 static inline struct hlsl_ir_expr *hlsl_ir_expr(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_EXPR);
+    VKD3D_ASSERT(node->type == HLSL_IR_EXPR);
     return CONTAINING_RECORD(node, struct hlsl_ir_expr, node);
 }
 
 static inline struct hlsl_ir_if *hlsl_ir_if(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_IF);
+    VKD3D_ASSERT(node->type == HLSL_IR_IF);
     return CONTAINING_RECORD(node, struct hlsl_ir_if, node);
 }
 
 static inline struct hlsl_ir_jump *hlsl_ir_jump(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_JUMP);
+    VKD3D_ASSERT(node->type == HLSL_IR_JUMP);
     return CONTAINING_RECORD(node, struct hlsl_ir_jump, node);
 }
 
 static inline struct hlsl_ir_load *hlsl_ir_load(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_LOAD);
+    VKD3D_ASSERT(node->type == HLSL_IR_LOAD);
     return CONTAINING_RECORD(node, struct hlsl_ir_load, node);
 }
 
 static inline struct hlsl_ir_loop *hlsl_ir_loop(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_LOOP);
+    VKD3D_ASSERT(node->type == HLSL_IR_LOOP);
     return CONTAINING_RECORD(node, struct hlsl_ir_loop, node);
 }
 
 static inline struct hlsl_ir_resource_load *hlsl_ir_resource_load(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_RESOURCE_LOAD);
+    VKD3D_ASSERT(node->type == HLSL_IR_RESOURCE_LOAD);
     return CONTAINING_RECORD(node, struct hlsl_ir_resource_load, node);
 }
 
 static inline struct hlsl_ir_resource_store *hlsl_ir_resource_store(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_RESOURCE_STORE);
+    VKD3D_ASSERT(node->type == HLSL_IR_RESOURCE_STORE);
     return CONTAINING_RECORD(node, struct hlsl_ir_resource_store, node);
 }
 
 static inline struct hlsl_ir_store *hlsl_ir_store(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_STORE);
+    VKD3D_ASSERT(node->type == HLSL_IR_STORE);
     return CONTAINING_RECORD(node, struct hlsl_ir_store, node);
 }
 
 static inline struct hlsl_ir_swizzle *hlsl_ir_swizzle(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_SWIZZLE);
+    VKD3D_ASSERT(node->type == HLSL_IR_SWIZZLE);
     return CONTAINING_RECORD(node, struct hlsl_ir_swizzle, node);
 }
 
 static inline struct hlsl_ir_index *hlsl_ir_index(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_INDEX);
+    VKD3D_ASSERT(node->type == HLSL_IR_INDEX);
     return CONTAINING_RECORD(node, struct hlsl_ir_index, node);
 }
 
 static inline struct hlsl_ir_switch *hlsl_ir_switch(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_SWITCH);
+    VKD3D_ASSERT(node->type == HLSL_IR_SWITCH);
     return CONTAINING_RECORD(node, struct hlsl_ir_switch, node);
 }
 
 static inline struct hlsl_ir_stateblock_constant *hlsl_ir_stateblock_constant(const struct hlsl_ir_node *node)
 {
-    assert(node->type == HLSL_IR_STATEBLOCK_CONSTANT);
+    VKD3D_ASSERT(node->type == HLSL_IR_STATEBLOCK_CONSTANT);
     return CONTAINING_RECORD(node, struct hlsl_ir_stateblock_constant, node);
 }
 
@@ -1306,6 +1327,9 @@ void hlsl_dump_var_default_values(const struct hlsl_ir_var *var);
 
 bool hlsl_validate_state_block_entry(struct hlsl_ctx *ctx, struct hlsl_state_block_entry *entry,
         const struct vkd3d_shader_location *loc);
+struct hlsl_state_block_entry *clone_stateblock_entry(struct hlsl_ctx *ctx,
+        struct hlsl_state_block_entry *src, const char *name, bool lhs_has_index,
+        unsigned int lhs_index, unsigned int arg_index);
 
 void hlsl_run_const_passes(struct hlsl_ctx *ctx, struct hlsl_block *body);
 int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func,
@@ -1329,6 +1353,7 @@ void hlsl_free_attribute(struct hlsl_attribute *attr);
 void hlsl_free_instr(struct hlsl_ir_node *node);
 void hlsl_free_instr_list(struct list *list);
 void hlsl_free_state_block(struct hlsl_state_block *state_block);
+void hlsl_free_state_block_entry(struct hlsl_state_block_entry *state_block_entry);
 void hlsl_free_type(struct hlsl_type *type);
 void hlsl_free_var(struct hlsl_ir_var *decl);
 
@@ -1412,6 +1437,8 @@ struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, uint32_t s, unsigned
         struct hlsl_ir_node *val, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_stateblock_constant(struct hlsl_ctx *ctx, const char *name,
         struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_new_string_constant(struct hlsl_ctx *ctx, const char *str,
+        const struct vkd3d_shader_location *loc);
 struct hlsl_ir_var *hlsl_new_synthetic_var(struct hlsl_ctx *ctx, const char *template,
         struct hlsl_type *type, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_var *hlsl_new_synthetic_var_named(struct hlsl_ctx *ctx, const char *name,
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.l b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
index 55993dac2b4..b4db142f6c2 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.l
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
@@ -29,6 +29,8 @@
 
 static void update_location(struct hlsl_ctx *ctx, YYLTYPE *loc);
 
+static void apply_escape_sequences(char *str);
+
 #define YY_USER_ACTION update_location(yyget_extra(yyscanner), yyget_lloc(yyscanner));
 
 %}
@@ -53,7 +55,7 @@ RESERVED4               typename|union|using|virtual
 
 WS                      [ \t]
 NEWLINE                 (\n)|(\r\n)
-STRING                  \"[^\"]*\"
+STRING                  \"([^\"\\]|\\.)*\"
 IDENTIFIER              [A-Za-z_][A-Za-z0-9_]*
 
 ANY                     (.)
@@ -208,6 +210,16 @@ while                   {return KW_WHILE;               }
                                 return NEW_IDENTIFIER;
                         }
 
+{STRING}                {
+                            struct hlsl_ctx *ctx = yyget_extra(yyscanner);
+                            char *string = hlsl_strdup(ctx, yytext + 1);
+
+                            string[strlen(string) - 1] = 0;
+                            apply_escape_sequences(string);
+                            yylval->name = string;
+                            return STRING;
+                        }
+
 [0-9]*\.[0-9]+([eE][+-]?[0-9]+)?[h|H|f|F]? {
                             yylval->floatval = atof(yytext);
                             return C_FLOAT;
@@ -292,6 +304,7 @@ while                   {return KW_WHILE;               }
 
                             BEGIN(pp_ignore);
                             string[strlen(string) - 1] = 0;
+                            apply_escape_sequences(string);
                             yylval->name = string;
                             return STRING;
                         }
@@ -341,3 +354,115 @@ int hlsl_lexer_compile(struct hlsl_ctx *ctx, const struct vkd3d_shader_code *hls
     yylex_destroy(ctx->scanner);
     return ret;
 }
+
+static void apply_escape_sequences(char *str)
+{
+    unsigned int i = 0, k = 0, r;
+
+    while (str[i])
+    {
+        unsigned char v = 0;
+
+        if (str[i] != '\\')
+        {
+            str[k++] = str[i];
+            ++i;
+            continue;
+        }
+
+        ++i;
+        VKD3D_ASSERT(str[i]);
+
+        if ('0' <= str[i] && str[i] <= '7')
+        {
+            /* octal, up to 3 digits. */
+            for (r = 0; r < 3; ++r)
+            {
+                char c = str[i];
+
+                if ('0' <= c && c <= '7')
+                {
+                    v = v << 3;
+                    v += c - '0';
+                    ++i;
+                }
+                else
+                    break;
+            }
+            str[k++] = v;
+            continue;
+        }
+
+        if (str[i] == 'x')
+        {
+            bool number = false;
+
+            /* hexadecimal */
+            ++i;
+            while (1)
+            {
+                char c = str[i];
+
+                if ('0' <= c && c <= '9')
+                {
+                    v = v << 4;
+                    v += c - '0';
+                    number = true;
+                    ++i;
+                }
+                else if ('a' <= c && c <= 'f')
+                {
+                    v = v << 4;
+                    v += c - 'a' + 10;
+                    number = true;
+                    ++i;
+                }
+                else if ('A' <= c && c <= 'F')
+                {
+                    v = v << 4;
+                    v += c - 'A' + 10;
+                    number = true;
+                    ++i;
+                }
+                else
+                    break;
+            }
+            if (number)
+                str[k++] = v;
+            else
+                str[k++] = 'x';
+            continue;
+        }
+
+        switch (str[i])
+        {
+            case 'a':
+                str[k++] = '\a';
+                break;
+            case 'b':
+                str[k++] = '\b';
+                break;
+            case 'f':
+                str[k++] = '\f';
+                break;
+            case 'n':
+                str[k++] = '\n';
+                break;
+            case 'r':
+                str[k++] = '\r';
+                break;
+            case 't':
+                str[k++] = '\t';
+                break;
+            case 'v':
+                str[k++] = '\v';
+                break;
+
+            default:
+                str[k++] = str[i];
+                break;
+        }
+        ++i;
+    }
+    str[k++] = '\0';
+}
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index 312eaec8a73..30bd53d0c49 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -344,11 +344,11 @@ static struct hlsl_ir_node *add_cast(struct hlsl_ctx *ctx, struct hlsl_block *bl
         broadcast = hlsl_is_numeric_type(src_type) && src_type->dimx == 1 && src_type->dimy == 1;
         matrix_cast = !broadcast && dst_comp_count != src_comp_count
                 && src_type->class == HLSL_CLASS_MATRIX && dst_type->class == HLSL_CLASS_MATRIX;
-        assert(src_comp_count >= dst_comp_count || broadcast);
+        VKD3D_ASSERT(src_comp_count >= dst_comp_count || broadcast);
         if (matrix_cast)
         {
-            assert(dst_type->dimx <= src_type->dimx);
-            assert(dst_type->dimy <= src_type->dimy);
+            VKD3D_ASSERT(dst_type->dimx <= src_type->dimx);
+            VKD3D_ASSERT(dst_type->dimy <= src_type->dimy);
         }
 
         if (!(var = hlsl_new_synthetic_var(ctx, "cast", dst_type, loc)))
@@ -590,6 +590,7 @@ static union hlsl_constant_value_component evaluate_static_expression(struct hls
         {
             case HLSL_IR_CONSTANT:
             case HLSL_IR_EXPR:
+            case HLSL_IR_STRING_CONSTANT:
             case HLSL_IR_SWIZZLE:
             case HLSL_IR_LOAD:
             case HLSL_IR_INDEX:
@@ -633,6 +634,10 @@ static union hlsl_constant_value_component evaluate_static_expression(struct hls
         constant = hlsl_ir_constant(node);
         ret = constant->value.u[0];
     }
+    else if (node->type == HLSL_IR_STRING_CONSTANT)
+    {
+        hlsl_fixme(ctx, &node->loc, "Evaluate string constants as static expressions.");
+    }
     else
     {
         hlsl_error(ctx, &node->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
@@ -755,7 +760,7 @@ static void cleanup_parse_attribute_list(struct parse_attribute_list *attr_list)
 {
     unsigned int i = 0;
 
-    assert(attr_list);
+    VKD3D_ASSERT(attr_list);
     for (i = 0; i < attr_list->count; ++i)
         hlsl_free_attribute((struct hlsl_attribute *) attr_list->attrs[i]);
     vkd3d_free(attr_list->attrs);
@@ -915,7 +920,7 @@ static bool add_record_access(struct hlsl_ctx *ctx, struct hlsl_block *block, st
 {
     struct hlsl_ir_node *index, *c;
 
-    assert(idx < record->data_type->e.record.field_count);
+    VKD3D_ASSERT(idx < record->data_type->e.record.field_count);
 
     if (!(c = hlsl_new_uint_constant(ctx, idx, loc)))
         return false;
@@ -1045,7 +1050,7 @@ static void free_parse_variable_def(struct parse_variable_def *v)
     vkd3d_free(v->arrays.sizes);
     vkd3d_free(v->name);
     hlsl_cleanup_semantic(&v->semantic);
-    assert(!v->state_blocks);
+    VKD3D_ASSERT(!v->state_blocks);
     vkd3d_free(v);
 }
 
@@ -1056,7 +1061,7 @@ static bool gen_struct_fields(struct hlsl_ctx *ctx, struct parse_fields *fields,
     size_t i = 0;
 
     if (type->class == HLSL_CLASS_MATRIX)
-        assert(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
+        VKD3D_ASSERT(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
 
     memset(fields, 0, sizeof(*fields));
     fields->count = list_count(defs);
@@ -1199,7 +1204,7 @@ static bool add_func_parameter(struct hlsl_ctx *ctx, struct hlsl_func_parameters
     struct hlsl_ir_var *var;
 
     if (param->type->class == HLSL_CLASS_MATRIX)
-        assert(param->type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
+        VKD3D_ASSERT(param->type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
 
     if ((param->modifiers & HLSL_STORAGE_OUT) && (param->modifiers & HLSL_STORAGE_UNIFORM))
         hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_MODIFIER,
@@ -2028,7 +2033,7 @@ static struct hlsl_ir_node *add_assignment(struct hlsl_ctx *ctx, struct hlsl_blo
     {
         enum hlsl_ir_expr_op op = op_from_assignment(assign_op);
 
-        assert(op);
+        VKD3D_ASSERT(op);
         if (!(rhs = add_binary_arithmetic_expr(ctx, block, op, lhs, rhs, &rhs->loc)))
             return NULL;
     }
@@ -2055,7 +2060,7 @@ static struct hlsl_ir_node *add_assignment(struct hlsl_ctx *ctx, struct hlsl_blo
             struct hlsl_ir_node *new_swizzle;
             uint32_t s = swizzle->swizzle;
 
-            assert(!matrix_writemask);
+            VKD3D_ASSERT(!matrix_writemask);
 
             if (swizzle->val.node->data_type->class == HLSL_CLASS_MATRIX)
             {
@@ -2111,7 +2116,7 @@ static struct hlsl_ir_node *add_assignment(struct hlsl_ctx *ctx, struct hlsl_blo
             return NULL;
 
         resource_type = hlsl_deref_get_type(ctx, &resource_deref);
-        assert(resource_type->class == HLSL_CLASS_TEXTURE || resource_type->class == HLSL_CLASS_UAV);
+        VKD3D_ASSERT(resource_type->class == HLSL_CLASS_TEXTURE || resource_type->class == HLSL_CLASS_UAV);
 
         if (resource_type->class != HLSL_CLASS_UAV)
             hlsl_error(ctx, &lhs->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
@@ -2123,9 +2128,9 @@ static struct hlsl_ir_node *add_assignment(struct hlsl_ctx *ctx, struct hlsl_blo
             hlsl_error(ctx, &lhs->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_WRITEMASK,
                     "Resource store expressions must write to all components.");
 
-        assert(coords->data_type->class == HLSL_CLASS_VECTOR);
-        assert(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
-        assert(coords->data_type->dimx == dim_count);
+        VKD3D_ASSERT(coords->data_type->class == HLSL_CLASS_VECTOR);
+        VKD3D_ASSERT(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
+        VKD3D_ASSERT(coords->data_type->dimx == dim_count);
 
         if (!(store = hlsl_new_resource_store(ctx, &resource_deref, coords, rhs, &lhs->loc)))
         {
@@ -2177,7 +2182,7 @@ static struct hlsl_ir_node *add_assignment(struct hlsl_ctx *ctx, struct hlsl_blo
         struct hlsl_ir_node *mat = row->val.node;
         unsigned int i, k = 0;
 
-        assert(!matrix_writemask);
+        VKD3D_ASSERT(!matrix_writemask);
 
         for (i = 0; i < mat->data_type->dimx; ++i)
         {
@@ -2450,10 +2455,10 @@ static void declare_var(struct hlsl_ctx *ctx, struct parse_variable_def *v)
     char *var_name;
     unsigned int i;
 
-    assert(basic_type);
+    VKD3D_ASSERT(basic_type);
 
     if (basic_type->class == HLSL_CLASS_MATRIX)
-        assert(basic_type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
+        VKD3D_ASSERT(basic_type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
 
     type = basic_type;
 
@@ -2858,7 +2863,7 @@ static bool add_user_call(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *fu
     struct hlsl_ir_node *call;
     unsigned int i, j;
 
-    assert(args->args_count <= func->parameters.count);
+    VKD3D_ASSERT(args->args_count <= func->parameters.count);
 
     for (i = 0; i < args->args_count; ++i)
     {
@@ -2892,7 +2897,7 @@ static bool add_user_call(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *fu
         unsigned int comp_count = hlsl_type_component_count(param->data_type);
         struct hlsl_deref param_deref;
 
-        assert(param->default_values);
+        VKD3D_ASSERT(param->default_values);
 
         hlsl_init_simple_deref_from_var(&param_deref, param);
 
@@ -3065,6 +3070,19 @@ static bool elementwise_intrinsic_float_convert_args(struct hlsl_ctx *ctx,
     return convert_args(ctx, params, type, loc);
 }
 
+static bool elementwise_intrinsic_uint_convert_args(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_type *type;
+
+    if (!(type = elementwise_intrinsic_get_common_type(ctx, params, loc)))
+        return false;
+
+    type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_UINT, type->dimx, type->dimy);
+
+    return convert_args(ctx, params, type, loc);
+}
+
 static bool intrinsic_abs(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
@@ -3770,6 +3788,21 @@ static bool intrinsic_faceforward(struct hlsl_ctx *ctx,
     return add_user_call(ctx, func, params, loc);
 }
 
+static bool intrinsic_f16tof32(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {0};
+    struct hlsl_type *type;
+
+    if (!elementwise_intrinsic_uint_convert_args(ctx, params, loc))
+        return false;
+
+    type = convert_numeric_type(ctx, params->args[0]->data_type, HLSL_TYPE_FLOAT);
+
+    operands[0] = params->args[0];
+    return add_expr(ctx, params->instrs, HLSL_OP1_F16TOF32, operands, type, loc);
+}
+
 static bool intrinsic_floor(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
@@ -4063,12 +4096,12 @@ static bool intrinsic_mul(struct hlsl_ctx *ctx,
     }
     else if (vect_count == 1)
     {
-        assert(matrix_type->dimx == 1 || matrix_type->dimy == 1);
+        VKD3D_ASSERT(matrix_type->dimx == 1 || matrix_type->dimy == 1);
         ret_type = hlsl_get_vector_type(ctx, base, matrix_type->dimx * matrix_type->dimy);
     }
     else
     {
-        assert(matrix_type->dimx == 1 && matrix_type->dimy == 1);
+        VKD3D_ASSERT(matrix_type->dimx == 1 && matrix_type->dimy == 1);
         ret_type = hlsl_get_scalar_type(ctx, base);
     }
 
@@ -4242,7 +4275,7 @@ static bool intrinsic_refract(struct hlsl_ctx *ctx,
         return false;
     }
 
-    assert(params->args_count == 3);
+    VKD3D_ASSERT(params->args_count == 3);
     mut_params = *params;
     mut_params.args_count = 2;
     if (!(res_type = elementwise_intrinsic_get_common_type(ctx, &mut_params, loc)))
@@ -4870,6 +4903,7 @@ intrinsic_functions[] =
     {"dot",                                 2, true,  intrinsic_dot},
     {"exp",                                 1, true,  intrinsic_exp},
     {"exp2",                                1, true,  intrinsic_exp2},
+    {"f16tof32",                            1, true,  intrinsic_f16tof32},
     {"faceforward",                         3, true,  intrinsic_faceforward},
     {"floor",                               1, true,  intrinsic_floor},
     {"fmod",                                2, true,  intrinsic_fmod},
@@ -5101,7 +5135,7 @@ static bool add_ternary(struct hlsl_ctx *ctx, struct hlsl_block *block,
         common_type = first->data_type;
     }
 
-    assert(cond->data_type->e.numeric.type == HLSL_TYPE_BOOL);
+    VKD3D_ASSERT(cond->data_type->e.numeric.type == HLSL_TYPE_BOOL);
 
     args[0] = cond;
     args[1] = first;
@@ -6601,7 +6635,7 @@ func_declaration:
 
                 if (!$1.first)
                 {
-                    assert(decl->parameters.count == $1.parameters.count);
+                    VKD3D_ASSERT(decl->parameters.count == $1.parameters.count);
 
                     for (i = 0; i < $1.parameters.count; ++i)
                     {
@@ -6716,7 +6750,7 @@ func_prototype_no_attrs:
                  * brittle and ugly.
                  */
 
-                assert($5.count == params->count);
+                VKD3D_ASSERT($5.count == params->count);
                 for (i = 0; i < params->count; ++i)
                 {
                     struct hlsl_ir_var *orig_param = params->vars[i];
@@ -7304,6 +7338,10 @@ type_no_void:
             validate_uav_type(ctx, $1, $3, &@3);
             $$ = hlsl_new_uav_type(ctx, $1, $3, true);
         }
+    | KW_STRING
+        {
+            $$ = ctx->builtin_types.string;
+        }
     | TYPE_IDENTIFIER
         {
             $$ = hlsl_get_type(ctx->cur_scope, $1, true, true);
@@ -7368,6 +7406,22 @@ type_no_void:
         {
             $$ = hlsl_get_type(ctx->cur_scope, "PixelShader", true, true);
         }
+    | KW_COMPUTESHADER
+        {
+            $$ = hlsl_get_type(ctx->cur_scope, "ComputeShader", true, true);
+        }
+    | KW_DOMAINSHADER
+        {
+            $$ = hlsl_get_type(ctx->cur_scope, "DomainShader", true, true);
+        }
+    | KW_HULLSHADER
+        {
+            $$ = hlsl_get_type(ctx->cur_scope, "HullShader", true, true);
+        }
+    | KW_GEOMETRYSHADER
+        {
+            $$ = hlsl_get_type(ctx->cur_scope, "GeometryShader", true, true);
+        }
     | KW_CONSTANTBUFFER '<' type '>'
         {
             if ($3->class != HLSL_CLASS_STRUCT)
@@ -7483,10 +7537,10 @@ variables_def_typed:
         {
             struct parse_variable_def *head_def;
 
-            assert(!list_empty($1));
+            VKD3D_ASSERT(!list_empty($1));
             head_def = LIST_ENTRY(list_head($1), struct parse_variable_def, entry);
 
-            assert(head_def->basic_type);
+            VKD3D_ASSERT(head_def->basic_type);
             $3->basic_type = head_def->basic_type;
             $3->modifiers = head_def->modifiers;
             $3->modifiers_loc = head_def->modifiers_loc;
@@ -8252,6 +8306,23 @@ primary_expr:
                 YYABORT;
             }
         }
+    | STRING
+        {
+            struct hlsl_ir_node *c;
+
+            if (!(c = hlsl_new_string_constant(ctx, $1, &@1)))
+            {
+                vkd3d_free($1);
+                YYABORT;
+            }
+            vkd3d_free($1);
+
+            if (!($$ = make_block(ctx, c)))
+            {
+                hlsl_free_instr(c);
+                YYABORT;
+            }
+        }
     | VAR_IDENTIFIER
         {
             struct hlsl_ir_load *load;
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index 26386c0b8df..049461cdb7d 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -53,7 +53,7 @@ static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, str
 
             if (regset == HLSL_REGSET_NUMERIC)
             {
-                assert(size % 4 == 0);
+                VKD3D_ASSERT(size % 4 == 0);
                 size /= 4;
             }
 
@@ -76,7 +76,7 @@ static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, str
 
             if (regset == HLSL_REGSET_NUMERIC)
             {
-                assert(*offset_component == 0);
+                VKD3D_ASSERT(*offset_component == 0);
                 *offset_component = field_offset % 4;
                 field_offset /= 4;
             }
@@ -121,7 +121,7 @@ static struct hlsl_ir_node *new_offset_instr_from_deref(struct hlsl_ctx *ctx, st
         return NULL;
     hlsl_block_add_instr(block, offset);
 
-    assert(deref->var);
+    VKD3D_ASSERT(deref->var);
     type = deref->var->data_type;
 
     for (i = 0; i < deref->path_len; ++i)
@@ -154,8 +154,8 @@ static bool replace_deref_path_with_offset(struct hlsl_ctx *ctx, struct hlsl_der
     struct hlsl_block block;
     struct hlsl_type *type;
 
-    assert(deref->var);
-    assert(!hlsl_deref_is_lowered(deref));
+    VKD3D_ASSERT(deref->var);
+    VKD3D_ASSERT(!hlsl_deref_is_lowered(deref));
 
     type = hlsl_deref_get_type(ctx, deref);
 
@@ -222,8 +222,8 @@ static void prepend_uniform_copy(struct hlsl_ctx *ctx, struct hlsl_block *block,
     if (temp->default_values)
     {
         /* Transfer default values from the temp to the uniform. */
-        assert(!uniform->default_values);
-        assert(hlsl_type_component_count(temp->data_type) == hlsl_type_component_count(uniform->data_type));
+        VKD3D_ASSERT(!uniform->default_values);
+        VKD3D_ASSERT(hlsl_type_component_count(temp->data_type) == hlsl_type_component_count(uniform->data_type));
         uniform->default_values = temp->default_values;
         temp->default_values = NULL;
     }
@@ -399,7 +399,7 @@ static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, s
         }
         else
         {
-            assert(i == 0);
+            VKD3D_ASSERT(i == 0);
 
             if (!(store = hlsl_new_store_index(ctx, &lhs->src, NULL, cast, 0, &var->loc)))
                 return;
@@ -532,7 +532,7 @@ static void append_output_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, s
         }
         else
         {
-            assert(i == 0);
+            VKD3D_ASSERT(i == 0);
 
             if (!(load = hlsl_new_load_index(ctx, &rhs->src, NULL, &var->loc)))
                 return;
@@ -927,7 +927,7 @@ static bool lower_return(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *fun
     if (return_instr)
     {
         /* If we're in a loop, we should have used "break" instead. */
-        assert(!in_loop);
+        VKD3D_ASSERT(!in_loop);
 
         /* Iterate in reverse, to avoid use-after-free when unlinking sources from
          * the "uses" list. */
@@ -949,7 +949,7 @@ static bool lower_return(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *fun
         struct hlsl_ir_load *load;
 
         /* If we're in a loop, we should have used "break" instead. */
-        assert(!in_loop);
+        VKD3D_ASSERT(!in_loop);
 
         if (tail == &cf_instr->entry)
             return has_early_return;
@@ -1008,7 +1008,7 @@ static struct hlsl_ir_node *add_zero_mipmap_level(struct hlsl_ctx *ctx, struct h
     struct hlsl_deref coords_deref;
     struct hlsl_ir_var *coords;
 
-    assert(dim_count < 4);
+    VKD3D_ASSERT(dim_count < 4);
 
     if (!(coords = hlsl_new_synthetic_var(ctx, "coords",
             hlsl_get_vector_type(ctx, HLSL_TYPE_UINT, dim_count + 1), loc)))
@@ -1109,9 +1109,9 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         struct hlsl_resource_load_params params = {0};
         struct hlsl_ir_node *resource_load;
 
-        assert(coords->data_type->class == HLSL_CLASS_VECTOR);
-        assert(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
-        assert(coords->data_type->dimx == dim_count);
+        VKD3D_ASSERT(coords->data_type->class == HLSL_CLASS_VECTOR);
+        VKD3D_ASSERT(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
+        VKD3D_ASSERT(coords->data_type->dimx == dim_count);
 
         if (!(coords = add_zero_mipmap_level(ctx, coords, &instr->loc)))
             return false;
@@ -1141,7 +1141,7 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         struct hlsl_deref row_deref;
         unsigned int i;
 
-        assert(!hlsl_type_is_row_major(mat->data_type));
+        VKD3D_ASSERT(!hlsl_type_is_row_major(mat->data_type));
 
         if (!(var = hlsl_new_synthetic_var(ctx, "row", instr->data_type, &instr->loc)))
             return false;
@@ -1378,7 +1378,7 @@ static struct copy_propagation_value *copy_propagation_get_value(const struct co
             unsigned int component_count = hlsl_type_component_count(var->data_type);
             struct copy_propagation_value *value;
 
-            assert(component < component_count);
+            VKD3D_ASSERT(component < component_count);
             value = copy_propagation_get_value_at_time(&var_def->traces[component], time);
 
             if (!value)
@@ -1411,7 +1411,7 @@ static struct copy_propagation_var_def *copy_propagation_create_var_def(struct h
     var_def->var = var;
 
     res = rb_put(&state->var_defs, var, &var_def->entry);
-    assert(!res);
+    VKD3D_ASSERT(!res);
 
     return var_def;
 }
@@ -1420,7 +1420,7 @@ static void copy_propagation_trace_record_value(struct hlsl_ctx *ctx,
         struct copy_propagation_component_trace *trace, struct hlsl_ir_node *node,
         unsigned int component, unsigned int time)
 {
-    assert(!trace->record_count || trace->records[trace->record_count - 1].timestamp < time);
+    VKD3D_ASSERT(!trace->record_count || trace->records[trace->record_count - 1].timestamp < time);
 
     if (!hlsl_array_reserve(ctx, (void **)&trace->records, &trace->record_capacity,
             trace->record_count + 1, sizeof(trace->records[0])))
@@ -1449,7 +1449,7 @@ static void copy_propagation_invalidate_variable(struct hlsl_ctx *ctx, struct co
             /* Don't add an invalidate record if it is already present. */
             if (trace->record_count && trace->records[trace->record_count - 1].timestamp == time)
             {
-                assert(!trace->records[trace->record_count - 1].node);
+                VKD3D_ASSERT(!trace->records[trace->record_count - 1].node);
                 continue;
             }
 
@@ -1638,9 +1638,16 @@ static bool copy_propagation_transform_load(struct hlsl_ctx *ctx,
         case HLSL_CLASS_PIXEL_SHADER:
         case HLSL_CLASS_RASTERIZER_STATE:
         case HLSL_CLASS_SAMPLER:
+        case HLSL_CLASS_STRING:
         case HLSL_CLASS_TEXTURE:
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_VERTEX_SHADER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             break;
 
         case HLSL_CLASS_MATRIX:
@@ -1651,11 +1658,8 @@ static bool copy_propagation_transform_load(struct hlsl_ctx *ctx,
              * matrices yet. */
             return false;
 
-        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
         case HLSL_CLASS_EFFECT_GROUP:
         case HLSL_CLASS_PASS:
-        case HLSL_CLASS_RENDER_TARGET_VIEW:
-        case HLSL_CLASS_STRING:
         case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_VOID:
             vkd3d_unreachable();
@@ -1697,11 +1701,11 @@ static bool copy_propagation_transform_object_load(struct hlsl_ctx *ctx,
 
     if (!hlsl_component_index_range_from_deref(ctx, deref, &start, &count))
         return false;
-    assert(count == 1);
+    VKD3D_ASSERT(count == 1);
 
     if (!(value = copy_propagation_get_value(state, deref->var, start, time)))
         return false;
-    assert(value->component == 0);
+    VKD3D_ASSERT(value->component == 0);
 
     /* Only HLSL_IR_LOAD can produce an object. */
     load = hlsl_ir_load(value->node);
@@ -2000,12 +2004,12 @@ static enum validation_result validate_component_index_range_from_deref(struct h
         struct hlsl_ir_node *path_node = deref->path[i].node;
         unsigned int idx = 0;
 
-        assert(path_node);
+        VKD3D_ASSERT(path_node);
         if (path_node->type != HLSL_IR_CONSTANT)
             return DEREF_VALIDATION_NOT_CONSTANT;
 
         /* We should always have generated a cast to UINT. */
-        assert(path_node->data_type->class == HLSL_CLASS_SCALAR
+        VKD3D_ASSERT(path_node->data_type->class == HLSL_CLASS_SCALAR
                 && path_node->data_type->e.numeric.type == HLSL_TYPE_UINT);
 
         idx = hlsl_ir_constant(path_node)->value.u[0].u;
@@ -2061,7 +2065,7 @@ static void note_non_static_deref_expressions(struct hlsl_ctx *ctx, const struct
     {
         struct hlsl_ir_node *path_node = deref->path[i].node;
 
-        assert(path_node);
+        VKD3D_ASSERT(path_node);
         if (path_node->type != HLSL_IR_CONSTANT)
             hlsl_note(ctx, &path_node->loc, VKD3D_SHADER_LOG_ERROR,
                     "Expression for %s within \"%s\" cannot be resolved statically.",
@@ -2535,7 +2539,7 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
         return false;
 
     deref = &hlsl_ir_load(instr)->src;
-    assert(deref->var);
+    VKD3D_ASSERT(deref->var);
 
     if (deref->path_len == 0)
         return false;
@@ -2609,7 +2613,7 @@ static bool validate_nonconstant_vector_store_derefs(struct hlsl_ctx *ctx, struc
         return false;
 
     deref = &hlsl_ir_store(instr)->lhs;
-    assert(deref->var);
+    VKD3D_ASSERT(deref->var);
 
     if (deref->path_len == 0)
         return false;
@@ -2630,6 +2634,124 @@ static bool validate_nonconstant_vector_store_derefs(struct hlsl_ctx *ctx, struc
     return false;
 }
 
+/* This pass flattens array (and row_major matrix) loads that include the indexing of a non-constant
+ * index into multiple constant loads, where the value of only one of them ends up in the resulting
+ * node.
+ * This is achieved through a synthetic variable. The non-constant index is compared for equality
+ * with every possible value it can have within the array bounds, and the ternary operator is used
+ * to update the value of the synthetic var when the equality check passes. */
+static bool lower_nonconstant_array_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
+        struct hlsl_block *block)
+{
+    struct hlsl_constant_value zero_value = {0};
+    struct hlsl_ir_node *cut_index, *zero, *store;
+    unsigned int i, i_cut, element_count;
+    const struct hlsl_deref *deref;
+    struct hlsl_type *cut_type;
+    struct hlsl_ir_load *load;
+    struct hlsl_ir_var *var;
+    bool row_major;
+
+    if (instr->type != HLSL_IR_LOAD)
+        return false;
+    load = hlsl_ir_load(instr);
+    deref = &load->src;
+
+    if (deref->path_len == 0)
+        return false;
+
+    for (i = deref->path_len - 1; ; --i)
+    {
+        if (deref->path[i].node->type != HLSL_IR_CONSTANT)
+        {
+            i_cut = i;
+            break;
+        }
+
+        if (i == 0)
+            return false;
+    }
+
+    cut_index = deref->path[i_cut].node;
+    cut_type = deref->var->data_type;
+    for (i = 0; i < i_cut; ++i)
+        cut_type = hlsl_get_element_type_from_path_index(ctx, cut_type, deref->path[i].node);
+
+    row_major = hlsl_type_is_row_major(cut_type);
+    VKD3D_ASSERT(cut_type->class == HLSL_CLASS_ARRAY || row_major);
+
+    if (!(var = hlsl_new_synthetic_var(ctx, row_major ? "row_major-load" : "array-load", instr->data_type, &instr->loc)))
+        return false;
+
+    if (!(zero = hlsl_new_constant(ctx, instr->data_type, &zero_value, &instr->loc)))
+        return false;
+    hlsl_block_add_instr(block, zero);
+
+    if (!(store = hlsl_new_simple_store(ctx, var, zero)))
+        return false;
+    hlsl_block_add_instr(block, store);
+
+    TRACE("Lowering non-constant %s load on variable '%s'.\n", row_major ? "row_major" : "array", deref->var->name);
+
+    element_count = hlsl_type_element_count(cut_type);
+    for (i = 0; i < element_count; ++i)
+    {
+        struct hlsl_type *btype = hlsl_get_scalar_type(ctx, HLSL_TYPE_BOOL);
+        struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {0};
+        struct hlsl_ir_node *const_i, *equals, *ternary, *var_store;
+        struct hlsl_ir_load *var_load, *specific_load;
+        struct hlsl_deref deref_copy = {0};
+
+        if (!(const_i = hlsl_new_uint_constant(ctx, i, &cut_index->loc)))
+            return false;
+        hlsl_block_add_instr(block, const_i);
+
+        operands[0] = cut_index;
+        operands[1] = const_i;
+        if (!(equals = hlsl_new_expr(ctx, HLSL_OP2_EQUAL, operands, btype, &cut_index->loc)))
+            return false;
+        hlsl_block_add_instr(block, equals);
+
+        if (!(equals = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), var->data_type->dimx, equals, &cut_index->loc)))
+            return false;
+        hlsl_block_add_instr(block, equals);
+
+        if (!(var_load = hlsl_new_var_load(ctx, var, &cut_index->loc)))
+            return false;
+        hlsl_block_add_instr(block, &var_load->node);
+
+        if (!hlsl_copy_deref(ctx, &deref_copy, deref))
+            return false;
+        hlsl_src_remove(&deref_copy.path[i_cut]);
+        hlsl_src_from_node(&deref_copy.path[i_cut], const_i);
+
+        if (!(specific_load = hlsl_new_load_index(ctx, &deref_copy, NULL, &cut_index->loc)))
+        {
+            hlsl_cleanup_deref(&deref_copy);
+            return false;
+        }
+        hlsl_block_add_instr(block, &specific_load->node);
+
+        hlsl_cleanup_deref(&deref_copy);
+
+        operands[0] = equals;
+        operands[1] = &specific_load->node;
+        operands[2] = &var_load->node;
+        if (!(ternary = hlsl_new_expr(ctx, HLSL_OP3_TERNARY, operands, instr->data_type, &cut_index->loc)))
+            return false;
+        hlsl_block_add_instr(block, ternary);
+
+        if (!(var_store = hlsl_new_simple_store(ctx, var, ternary)))
+            return false;
+        hlsl_block_add_instr(block, var_store);
+    }
+
+    if (!(load = hlsl_new_var_load(ctx, var, &instr->loc)))
+        return false;
+    hlsl_block_add_instr(block, &load->node);
+
+    return true;
+}
 /* Lower combined samples and sampler variables to synthesized separated textures and samplers.
  * That is, translate SM1-style samples in the source to SM4-style samples in the bytecode. */
 static bool lower_combined_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
@@ -2672,7 +2794,7 @@ static bool lower_combined_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
         return false;
     }
 
-    assert(hlsl_deref_get_regset(ctx, &load->resource) == HLSL_REGSET_SAMPLERS);
+    VKD3D_ASSERT(hlsl_deref_get_regset(ctx, &load->resource) == HLSL_REGSET_SAMPLERS);
 
     if (!(name = hlsl_get_string_buffer(ctx)))
         return false;
@@ -2689,7 +2811,7 @@ static bool lower_combined_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
         struct hlsl_type *arr_type = load->resource.var->data_type;
         for (i = 0; i < load->resource.path_len; ++i)
         {
-            assert(arr_type->class == HLSL_CLASS_ARRAY);
+            VKD3D_ASSERT(arr_type->class == HLSL_CLASS_ARRAY);
             texture_array_type = hlsl_new_array_type(ctx, texture_array_type, arr_type->e.array.elements_count);
             arr_type = arr_type->e.array.type;
         }
@@ -2718,8 +2840,8 @@ static bool lower_combined_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
 
     hlsl_copy_deref(ctx, &load->sampler, &load->resource);
     load->resource.var = var;
-    assert(hlsl_deref_get_type(ctx, &load->resource)->class == HLSL_CLASS_TEXTURE);
-    assert(hlsl_deref_get_type(ctx, &load->sampler)->class == HLSL_CLASS_SAMPLER);
+    VKD3D_ASSERT(hlsl_deref_get_type(ctx, &load->resource)->class == HLSL_CLASS_TEXTURE);
+    VKD3D_ASSERT(hlsl_deref_get_type(ctx, &load->sampler)->class == HLSL_CLASS_SAMPLER);
 
     return true;
 }
@@ -3137,7 +3259,7 @@ static bool lower_logic_not(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, st
     float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, arg->data_type->dimx);
 
     /* If this is happens, it means we failed to cast the argument to boolean somewhere. */
-    assert(arg->data_type->e.numeric.type == HLSL_TYPE_BOOL);
+    VKD3D_ASSERT(arg->data_type->e.numeric.type == HLSL_TYPE_BOOL);
 
     if (!(arg_cast = hlsl_new_cast(ctx, arg, float_type, &arg->loc)))
         return false;
@@ -3193,7 +3315,7 @@ static bool lower_ternary(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
         return false;
     }
 
-    assert(cond->data_type->e.numeric.type == HLSL_TYPE_BOOL);
+    VKD3D_ASSERT(cond->data_type->e.numeric.type == HLSL_TYPE_BOOL);
 
     type = hlsl_get_numeric_type(ctx, instr->data_type->class, HLSL_TYPE_FLOAT,
             instr->data_type->dimx, instr->data_type->dimy);
@@ -3491,7 +3613,7 @@ static bool lower_casts_to_bool(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
         return false;
 
     /* Narrowing casts should have already been lowered. */
-    assert(type->dimx == arg_type->dimx);
+    VKD3D_ASSERT(type->dimx == arg_type->dimx);
 
     zero = hlsl_new_constant(ctx, arg_type, &zero_value, &instr->loc);
     if (!zero)
@@ -3513,7 +3635,7 @@ struct hlsl_ir_node *hlsl_add_conditional(struct hlsl_ctx *ctx, struct hlsl_bloc
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS];
     struct hlsl_ir_node *cond;
 
-    assert(hlsl_types_are_equal(if_true->data_type, if_false->data_type));
+    VKD3D_ASSERT(hlsl_types_are_equal(if_true->data_type, if_false->data_type));
 
     if (cond_type->e.numeric.type != HLSL_TYPE_BOOL)
     {
@@ -3712,7 +3834,7 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
     {
         arg1 = expr->operands[0].node;
         arg2 = expr->operands[1].node;
-        assert(arg1->data_type->dimx == arg2->data_type->dimx);
+        VKD3D_ASSERT(arg1->data_type->dimx == arg2->data_type->dimx);
         dimx = arg1->data_type->dimx;
         is_bool = type->e.numeric.type == HLSL_TYPE_BOOL;
 
@@ -3930,6 +4052,7 @@ static bool dce(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
         case HLSL_IR_INDEX:
         case HLSL_IR_LOAD:
         case HLSL_IR_RESOURCE_LOAD:
+        case HLSL_IR_STRING_CONSTANT:
         case HLSL_IR_SWIZZLE:
             if (list_empty(&instr->uses))
             {
@@ -3987,8 +4110,8 @@ static bool mark_indexable_vars(struct hlsl_ctx *ctx, struct hlsl_deref *deref,
     if (!deref->rel_offset.node)
         return false;
 
-    assert(deref->var);
-    assert(deref->rel_offset.node->type != HLSL_IR_CONSTANT);
+    VKD3D_ASSERT(deref->var);
+    VKD3D_ASSERT(deref->rel_offset.node->type != HLSL_IR_CONSTANT);
     deref->var->indexable = true;
 
     return true;
@@ -4210,6 +4333,7 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
             break;
         }
         case HLSL_IR_CONSTANT:
+        case HLSL_IR_STRING_CONSTANT:
             break;
         }
     }
@@ -4311,7 +4435,7 @@ static struct hlsl_reg allocate_register(struct hlsl_ctx *ctx, struct register_a
     unsigned int writemask;
     uint32_t reg_idx;
 
-    assert(component_count <= reg_size);
+    VKD3D_ASSERT(component_count <= reg_size);
 
     for (reg_idx = 0;; ++reg_idx)
     {
@@ -4340,7 +4464,7 @@ static struct hlsl_reg allocate_register_with_masks(struct hlsl_ctx *ctx, struct
     struct hlsl_reg ret = {0};
     uint32_t reg_idx;
 
-    assert((reg_writemask & writemask) == writemask);
+    VKD3D_ASSERT((reg_writemask & writemask) == writemask);
 
     for (reg_idx = 0;; ++reg_idx)
     {
@@ -4450,7 +4574,7 @@ static bool track_object_components_sampler_dim(struct hlsl_ctx *ctx, struct hls
     {
         enum hlsl_sampler_dim dim;
 
-        assert(!load->sampler.var);
+        VKD3D_ASSERT(!load->sampler.var);
 
         dim = var->objects_usage[regset][index].sampler_dim;
         if (dim != load->sampling_dim)
@@ -4732,9 +4856,9 @@ static void allocate_const_registers_recurse(struct hlsl_ctx *ctx,
                 constant->reg = allocate_numeric_registers_for_type(ctx, allocator, 1, UINT_MAX, type);
                 TRACE("Allocated constant @%u to %s.\n", instr->index, debug_register('c', constant->reg, type));
 
-                assert(hlsl_is_numeric_type(type));
-                assert(type->dimy == 1);
-                assert(constant->reg.writemask);
+                VKD3D_ASSERT(hlsl_is_numeric_type(type));
+                VKD3D_ASSERT(type->dimy == 1);
+                VKD3D_ASSERT(constant->reg.writemask);
 
                 for (x = 0, i = 0; x < 4; ++x)
                 {
@@ -4845,6 +4969,43 @@ static void sort_uniforms_by_numeric_bind_count(struct hlsl_ctx *ctx)
     list_move_tail(&ctx->extern_vars, &sorted);
 }
 
+/* In SM2, 'sincos' expects specific constants as src1 and src2 arguments.
+ * These have to be referenced directly, i.e. as 'c' not 'r'. */
+static void allocate_sincos_const_registers(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct register_allocator *allocator)
+{
+    const struct hlsl_ir_node *instr;
+    struct hlsl_type *type;
+
+    if (ctx->profile->major_version >= 3)
+        return;
+
+    LIST_FOR_EACH_ENTRY(instr, &block->instrs, struct hlsl_ir_node, entry)
+    {
+        if (instr->type == HLSL_IR_EXPR && (hlsl_ir_expr(instr)->op == HLSL_OP1_SIN_REDUCED
+                || hlsl_ir_expr(instr)->op == HLSL_OP1_COS_REDUCED))
+        {
+            type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, 4);
+
+            ctx->d3dsincosconst1 = allocate_numeric_registers_for_type(ctx, allocator, 1, UINT_MAX, type);
+            TRACE("Allocated D3DSINCOSCONST1 to %s.\n", debug_register('c', ctx->d3dsincosconst1, type));
+            record_constant(ctx, ctx->d3dsincosconst1.id * 4 + 0, -1.55009923e-06f);
+            record_constant(ctx, ctx->d3dsincosconst1.id * 4 + 1, -2.17013894e-05f);
+            record_constant(ctx, ctx->d3dsincosconst1.id * 4 + 2,  2.60416674e-03f);
+            record_constant(ctx, ctx->d3dsincosconst1.id * 4 + 3,  2.60416680e-04f);
+
+            ctx->d3dsincosconst2 = allocate_numeric_registers_for_type(ctx, allocator, 1, UINT_MAX, type);
+            TRACE("Allocated D3DSINCOSCONST2 to %s.\n", debug_register('c', ctx->d3dsincosconst2, type));
+            record_constant(ctx, ctx->d3dsincosconst2.id * 4 + 0, -2.08333340e-02f);
+            record_constant(ctx, ctx->d3dsincosconst2.id * 4 + 1, -1.25000000e-01f);
+            record_constant(ctx, ctx->d3dsincosconst2.id * 4 + 2,  1.00000000e+00f);
+            record_constant(ctx, ctx->d3dsincosconst2.id * 4 + 3,  5.00000000e-01f);
+
+            return;
+        }
+    }
+}
+
 static void allocate_const_registers(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func)
 {
     struct register_allocator allocator_used = {0};
@@ -4866,7 +5027,7 @@ static void allocate_const_registers(struct hlsl_ctx *ctx, struct hlsl_ir_functi
             unsigned int reg_idx = var->reg_reservation.reg_index;
             unsigned int i;
 
-            assert(reg_size % 4 == 0);
+            VKD3D_ASSERT(reg_size % 4 == 0);
             for (i = 0; i < reg_size / 4; ++i)
             {
                 if (i < bind_count)
@@ -4909,6 +5070,8 @@ static void allocate_const_registers(struct hlsl_ctx *ctx, struct hlsl_ir_functi
 
     allocate_const_registers_recurse(ctx, &entry_func->body, &allocator);
 
+    allocate_sincos_const_registers(ctx, &entry_func->body, &allocator);
+
     vkd3d_free(allocator.allocations);
 }
 
@@ -4958,7 +5121,7 @@ static void allocate_semantic_register(struct hlsl_ctx *ctx, struct hlsl_ir_var
     uint32_t reg;
     bool builtin;
 
-    assert(var->semantic.name);
+    VKD3D_ASSERT(var->semantic.name);
 
     if (ctx->profile->major_version < 4)
     {
@@ -5357,7 +5520,7 @@ static void allocate_objects(struct hlsl_ctx *ctx, enum hlsl_regset regset)
 
             if (var->regs[regset].index < min_index)
             {
-                assert(regset == HLSL_REGSET_UAVS);
+                VKD3D_ASSERT(regset == HLSL_REGSET_UAVS);
                 hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_OVERLAPPING_RESERVATIONS,
                         "UAV index (%u) must be higher than the maximum render target index (%u).",
                         var->regs[regset].index, min_index - 1);
@@ -5435,12 +5598,12 @@ bool hlsl_component_index_range_from_deref(struct hlsl_ctx *ctx, const struct hl
         struct hlsl_ir_node *path_node = deref->path[i].node;
         unsigned int idx = 0;
 
-        assert(path_node);
+        VKD3D_ASSERT(path_node);
         if (path_node->type != HLSL_IR_CONSTANT)
             return false;
 
         /* We should always have generated a cast to UINT. */
-        assert(path_node->data_type->class == HLSL_CLASS_SCALAR
+        VKD3D_ASSERT(path_node->data_type->class == HLSL_CLASS_SCALAR
                 && path_node->data_type->e.numeric.type == HLSL_TYPE_UINT);
 
         idx = hlsl_ir_constant(path_node)->value.u[0].u;
@@ -5500,11 +5663,11 @@ bool hlsl_regset_index_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref
         struct hlsl_ir_node *path_node = deref->path[i].node;
         unsigned int idx = 0;
 
-        assert(path_node);
+        VKD3D_ASSERT(path_node);
         if (path_node->type == HLSL_IR_CONSTANT)
         {
             /* We should always have generated a cast to UINT. */
-            assert(path_node->data_type->class == HLSL_CLASS_SCALAR
+            VKD3D_ASSERT(path_node->data_type->class == HLSL_CLASS_SCALAR
                     && path_node->data_type->e.numeric.type == HLSL_TYPE_UINT);
 
             idx = hlsl_ir_constant(path_node)->value.u[0].u;
@@ -5554,8 +5717,8 @@ bool hlsl_regset_index_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref
         type = hlsl_get_element_type_from_path_index(ctx, type, path_node);
     }
 
-    assert(!(regset <= HLSL_REGSET_LAST_OBJECT) || (type->reg_size[regset] == 1));
-    assert(!(regset == HLSL_REGSET_NUMERIC) || type->reg_size[regset] <= 4);
+    VKD3D_ASSERT(!(regset <= HLSL_REGSET_LAST_OBJECT) || (type->reg_size[regset] == 1));
+    VKD3D_ASSERT(!(regset == HLSL_REGSET_NUMERIC) || type->reg_size[regset] <= 4);
     return index_is_constant;
 }
 
@@ -5570,16 +5733,17 @@ bool hlsl_offset_from_deref(struct hlsl_ctx *ctx, const struct hlsl_deref *deref
     if (offset_node)
     {
         /* We should always have generated a cast to UINT. */
-        assert(offset_node->data_type->class == HLSL_CLASS_SCALAR
+        VKD3D_ASSERT(offset_node->data_type->class == HLSL_CLASS_SCALAR
                 && offset_node->data_type->e.numeric.type == HLSL_TYPE_UINT);
-        assert(offset_node->type != HLSL_IR_CONSTANT);
+        VKD3D_ASSERT(offset_node->type != HLSL_IR_CONSTANT);
         return false;
     }
 
     size = deref->var->data_type->reg_size[regset];
     if (*offset >= size)
     {
-        hlsl_error(ctx, &offset_node->loc, VKD3D_SHADER_ERROR_HLSL_OFFSET_OUT_OF_BOUNDS,
+        /* FIXME: Report a more specific location for the constant deref. */
+        hlsl_error(ctx, &deref->var->loc, VKD3D_SHADER_ERROR_HLSL_OFFSET_OUT_OF_BOUNDS,
                 "Dereference is out of bounds. %u/%u", *offset, size);
         return false;
     }
@@ -5594,8 +5758,9 @@ unsigned int hlsl_offset_from_deref_safe(struct hlsl_ctx *ctx, const struct hlsl
     if (hlsl_offset_from_deref(ctx, deref, &offset))
         return offset;
 
-    hlsl_fixme(ctx, &deref->rel_offset.node->loc, "Dereference with non-constant offset of type %s.",
-            hlsl_node_type_to_string(deref->rel_offset.node->type));
+    if (deref->rel_offset.node)
+        hlsl_fixme(ctx, &deref->rel_offset.node->loc, "Dereference with non-constant offset of type %s.",
+                hlsl_node_type_to_string(deref->rel_offset.node->type));
 
     return 0;
 }
@@ -5606,8 +5771,8 @@ struct hlsl_reg hlsl_reg_from_deref(struct hlsl_ctx *ctx, const struct hlsl_dere
     struct hlsl_reg ret = var->regs[HLSL_REGSET_NUMERIC];
     unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref);
 
-    assert(deref->data_type);
-    assert(hlsl_is_numeric_type(deref->data_type));
+    VKD3D_ASSERT(deref->data_type);
+    VKD3D_ASSERT(hlsl_is_numeric_type(deref->data_type));
 
     ret.index += offset / 4;
     ret.id += offset / 4;
@@ -5795,7 +5960,7 @@ static void sm1_generate_vsir_signature_entry(struct hlsl_ctx *ctx,
         register_index = var->regs[HLSL_REGSET_NUMERIC].id;
 
         ret = hlsl_sm1_usage_from_semantic(var->semantic.name, var->semantic.index, &usage, &usage_idx);
-        assert(ret);
+        VKD3D_ASSERT(ret);
         /* With the exception of vertex POSITION output, none of these are
          * system values. Pixel POSITION input is not equivalent to
          * SV_Position; the closer equivalent is VPOS, which is not declared
@@ -6070,7 +6235,7 @@ static void transform_unroll_loops(struct hlsl_ctx *ctx, struct hlsl_block *bloc
             return;
 
         cloned_loop = loop_unrolling_find_unrollable_loop(ctx, &clone, &containing_block);
-        assert(cloned_loop);
+        VKD3D_ASSERT(cloned_loop);
 
         if (!loop_unrolling_unroll_loop(ctx, &clone, containing_block, cloned_loop))
         {
@@ -6085,6 +6250,90 @@ static void transform_unroll_loops(struct hlsl_ctx *ctx, struct hlsl_block *bloc
     }
 }
 
+static bool lower_f16tof32(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct hlsl_block *block)
+{
+    struct hlsl_ir_node *call, *rhs, *store;
+    struct hlsl_ir_function_decl *func;
+    unsigned int component_count;
+    struct hlsl_ir_load *load;
+    struct hlsl_ir_expr *expr;
+    struct hlsl_ir_var *lhs;
+    char *body;
+
+    static const char template[] =
+    "typedef uint%u uintX;\n"
+    "float%u soft_f16tof32(uintX x)\n"
+    "{\n"
+    "    uintX mantissa = x & 0x3ff;\n"
+    "    uintX high2 = mantissa >> 8;\n"
+    "    uintX high2_check = high2 ? high2 : mantissa;\n"
+    "    uintX high6 = high2_check >> 4;\n"
+    "    uintX high6_check = high6 ? high6 : high2_check;\n"
+    "\n"
+    "    uintX high8 = high6_check >> 2;\n"
+    "    uintX high8_check = (high8 ? high8 : high6_check) >> 1;\n"
+    "    uintX shift = high6 ? (high2 ? 12 : 4) : (high2 ? 8 : 0);\n"
+    "    shift = high8 ? shift + 2 : shift;\n"
+    "    shift = high8_check ? shift + 1 : shift;\n"
+    "    shift = -shift + 10;\n"
+    "    shift = mantissa ? shift : 11;\n"
+    "    uintX subnormal_mantissa = ((mantissa << shift) << 23) & 0x7fe000;\n"
+    "    uintX subnormal_exp = -(shift << 23) + 0x38800000;\n"
+    "    uintX subnormal_val = subnormal_exp + subnormal_mantissa;\n"
+    "    uintX subnormal_or_zero = mantissa ? subnormal_val : 0;\n"
+    "\n"
+    "    uintX exponent = (((x >> 10) << 23) & 0xf800000) + 0x38000000;\n"
+    "\n"
+    "    uintX low_3 = (x << 13) & 0x7fe000;\n"
+    "    uintX normalized_val = exponent + low_3;\n"
+    "    uintX inf_nan_val = low_3 + 0x7f800000;\n"
+    "\n"
+    "    uintX exp_mask = 0x7c00;\n"
+    "    uintX is_inf_nan = (x & exp_mask) == exp_mask;\n"
+    "    uintX is_normalized = x & exp_mask;\n"
+    "\n"
+    "    uintX check = is_inf_nan ? inf_nan_val : normalized_val;\n"
+    "    uintX exp_mantissa = (is_normalized ? check : subnormal_or_zero) & 0x7fffe000;\n"
+    "    uintX sign_bit = (x << 16) & 0x80000000;\n"
+    "\n"
+    "    return asfloat(exp_mantissa + sign_bit);\n"
+    "}\n";
+
+
+    if (node->type != HLSL_IR_EXPR)
+        return false;
+
+    expr = hlsl_ir_expr(node);
+
+    if (expr->op != HLSL_OP1_F16TOF32)
+        return false;
+
+    rhs = expr->operands[0].node;
+    component_count = hlsl_type_component_count(rhs->data_type);
+
+    if (!(body = hlsl_sprintf_alloc(ctx, template, component_count, component_count)))
+        return false;
+
+    if (!(func = hlsl_compile_internal_function(ctx, "soft_f16tof32", body)))
+        return false;
+
+    lhs = func->parameters.vars[0];
+
+    if (!(store = hlsl_new_simple_store(ctx, lhs, rhs)))
+        return false;
+    hlsl_block_add_instr(block, store);
+
+    if (!(call = hlsl_new_call(ctx, func, &node->loc)))
+        return false;
+    hlsl_block_add_instr(block, call);
+
+    if (!(load = hlsl_new_var_load(ctx, func->return_var, &node->loc)))
+        return false;
+    hlsl_block_add_instr(block, &load->node);
+
+    return true;
+}
+
 int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func,
         enum vkd3d_shader_target_type target_type, struct vkd3d_shader_code *out)
 {
@@ -6105,6 +6354,9 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
     if (ctx->result)
         return ctx->result;
 
+    if (hlsl_version_ge(ctx, 4, 0) && hlsl_version_lt(ctx, 5, 0))
+        lower_ir(ctx, lower_f16tof32, body);
+
     lower_return(ctx, entry_func, body, false);
 
     while (hlsl_transform_ir(ctx, lower_calls, body, NULL));
@@ -6195,6 +6447,8 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
 
     if (profile->major_version < 4)
     {
+        while (lower_ir(ctx, lower_nonconstant_array_loads, body));
+
         lower_ir(ctx, lower_ternary, body);
 
         lower_ir(ctx, lower_nonfloat_exprs, body);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
index 16015fa8a81..db4913b7c62 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
@@ -28,7 +28,7 @@ static bool fold_abs(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -119,7 +119,7 @@ static bool fold_bit_not(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -234,7 +234,7 @@ static bool fold_ceil(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -260,7 +260,7 @@ static bool fold_exp2(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -286,7 +286,7 @@ static bool fold_floor(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -313,7 +313,7 @@ static bool fold_fract(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     unsigned int k;
     float i;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -339,7 +339,7 @@ static bool fold_log2(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, con
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -384,7 +384,7 @@ static bool fold_neg(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -418,7 +418,7 @@ static bool fold_not(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -442,7 +442,7 @@ static bool fold_rcp(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -487,7 +487,7 @@ static bool fold_rsq(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -527,7 +527,7 @@ static bool fold_sat(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -553,7 +553,7 @@ static bool fold_sqrt(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, con
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -598,8 +598,8 @@ static bool fold_add(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -635,8 +635,8 @@ static bool fold_and(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -662,8 +662,8 @@ static bool fold_or(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -689,8 +689,8 @@ static bool fold_bit_xor(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -715,9 +715,9 @@ static bool fold_dot(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
-    assert(src1->node.data_type->dimx == src2->node.data_type->dimx);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(src1->node.data_type->dimx == src2->node.data_type->dimx);
 
     dst->u[0].f = 0.0f;
     for (k = 0; k < src1->node.data_type->dimx; ++k)
@@ -743,11 +743,11 @@ static bool fold_dp2add(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
-    assert(type == src3->node.data_type->e.numeric.type);
-    assert(src1->node.data_type->dimx == src2->node.data_type->dimx);
-    assert(src3->node.data_type->dimx == 1);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src3->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(src1->node.data_type->dimx == src2->node.data_type->dimx);
+    VKD3D_ASSERT(src3->node.data_type->dimx == 1);
 
     dst->u[0].f = src3->value.u[0].f;
     for (k = 0; k < src1->node.data_type->dimx; ++k)
@@ -774,8 +774,8 @@ static bool fold_div(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -841,8 +841,8 @@ static bool fold_equal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, co
 {
     unsigned int k;
 
-    assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
-    assert(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+    VKD3D_ASSERT(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -877,8 +877,8 @@ static bool fold_gequal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
 {
     unsigned int k;
 
-    assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
-    assert(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+    VKD3D_ASSERT(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -916,8 +916,8 @@ static bool fold_less(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, con
 {
     unsigned int k;
 
-    assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
-    assert(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+    VKD3D_ASSERT(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -955,8 +955,8 @@ static bool fold_lshift(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
 {
     unsigned int k;
 
-    assert(dst_type->e.numeric.type == src1->node.data_type->e.numeric.type);
-    assert(src2->node.data_type->e.numeric.type == HLSL_TYPE_INT);
+    VKD3D_ASSERT(dst_type->e.numeric.type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(src2->node.data_type->e.numeric.type == HLSL_TYPE_INT);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -986,8 +986,8 @@ static bool fold_max(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -1024,8 +1024,8 @@ static bool fold_min(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -1063,8 +1063,8 @@ static bool fold_mod(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -1105,8 +1105,8 @@ static bool fold_mul(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     enum hlsl_base_type type = dst_type->e.numeric.type;
     unsigned int k;
 
-    assert(type == src1->node.data_type->e.numeric.type);
-    assert(type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -1139,8 +1139,8 @@ static bool fold_nequal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
 {
     unsigned int k;
 
-    assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
-    assert(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+    VKD3D_ASSERT(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -1175,9 +1175,9 @@ static bool fold_ternary(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
 {
     unsigned int k;
 
-    assert(dst_type->e.numeric.type == src2->node.data_type->e.numeric.type);
-    assert(dst_type->e.numeric.type == src3->node.data_type->e.numeric.type);
-    assert(src1->node.data_type->e.numeric.type == HLSL_TYPE_BOOL);
+    VKD3D_ASSERT(dst_type->e.numeric.type == src2->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(dst_type->e.numeric.type == src3->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(src1->node.data_type->e.numeric.type == HLSL_TYPE_BOOL);
 
     for (k = 0; k < dst_type->dimx; ++k)
         dst->u[k] = src1->value.u[k].u ? src2->value.u[k] : src3->value.u[k];
@@ -1190,8 +1190,8 @@ static bool fold_rshift(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
 {
     unsigned int k;
 
-    assert(dst_type->e.numeric.type == src1->node.data_type->e.numeric.type);
-    assert(src2->node.data_type->e.numeric.type == HLSL_TYPE_INT);
+    VKD3D_ASSERT(dst_type->e.numeric.type == src1->node.data_type->e.numeric.type);
+    VKD3D_ASSERT(src2->node.data_type->e.numeric.type == HLSL_TYPE_INT);
 
     for (k = 0; k < dst_type->dimx; ++k)
     {
@@ -1239,7 +1239,7 @@ bool hlsl_fold_constant_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         {
             if (expr->operands[i].node->type != HLSL_IR_CONSTANT)
                 return false;
-            assert(expr->operands[i].node->data_type->class <= HLSL_CLASS_VECTOR);
+            VKD3D_ASSERT(expr->operands[i].node->data_type->class <= HLSL_CLASS_VECTOR);
         }
     }
     arg1 = hlsl_ir_constant(expr->operands[0].node);
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index e0ac6322c71..c1b8582af6d 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -469,7 +469,9 @@ static enum vkd3d_result vsir_program_lower_instructions(struct vsir_program *pr
                     return ret;
                 break;
 
+            case VKD3DSIH_DCL:
             case VKD3DSIH_DCL_CONSTANT_BUFFER:
+            case VKD3DSIH_DCL_SAMPLER:
             case VKD3DSIH_DCL_TEMPS:
                 vkd3d_shader_instruction_make_nop(ins);
                 break;
@@ -917,7 +919,7 @@ static void shader_dst_param_normalise_outpointid(struct vkd3d_shader_dst_param
     if (control_point_normaliser_is_in_control_point_phase(normaliser) && reg->type == VKD3DSPR_OUTPUT)
     {
         /* The TPF reader validates idx_count. */
-        assert(reg->idx_count == 1);
+        VKD3D_ASSERT(reg->idx_count == 1);
         reg->idx[1] = reg->idx[0];
         /* The control point id param is implicit here. Avoid later complications by inserting it. */
         reg->idx[0].offset = 0;
@@ -1139,16 +1141,16 @@ static void range_map_set_register_range(uint8_t range_map[][VKD3D_VEC4_SIZE], u
 {
     unsigned int i, j, r, c, component_idx, component_count;
 
-    assert(write_mask <= VKD3DSP_WRITEMASK_ALL);
+    VKD3D_ASSERT(write_mask <= VKD3DSP_WRITEMASK_ALL);
     component_idx = vsir_write_mask_get_component_idx(write_mask);
     component_count = vsir_write_mask_component_count(write_mask);
 
-    assert(register_idx < MAX_REG_OUTPUT && MAX_REG_OUTPUT - register_idx >= register_count);
+    VKD3D_ASSERT(register_idx < MAX_REG_OUTPUT && MAX_REG_OUTPUT - register_idx >= register_count);
 
     if (range_map[register_idx][component_idx] > register_count && is_dcl_indexrange)
     {
         /* Validated in the TPF reader. */
-        assert(range_map[register_idx][component_idx] != UINT8_MAX);
+        VKD3D_ASSERT(range_map[register_idx][component_idx] != UINT8_MAX);
         return;
     }
     if (range_map[register_idx][component_idx] == register_count)
@@ -1168,7 +1170,7 @@ static void range_map_set_register_range(uint8_t range_map[][VKD3D_VEC4_SIZE], u
             /* A synthetic patch constant range which overlaps an existing range can start upstream of it
              * for fork/join phase instancing, but ranges declared by dcl_indexrange should not overlap.
              * The latter is validated in the TPF reader. */
-            assert(!range_map[r][c] || !is_dcl_indexrange);
+            VKD3D_ASSERT(!range_map[r][c] || !is_dcl_indexrange);
             range_map[r][c] = UINT8_MAX;
         }
     }
@@ -1371,7 +1373,7 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
 
             TRACE("Merging %s, reg %u, mask %#x, sysval %#x with %s, mask %#x, sysval %#x.\n", e->semantic_name,
                     e->register_index, e->mask, e->sysval_semantic, f->semantic_name, f->mask, f->sysval_semantic);
-            assert(!(e->mask & f->mask));
+            VKD3D_ASSERT(!(e->mask & f->mask));
 
             e->mask |= f->mask;
             e->used_mask |= f->used_mask;
@@ -1405,7 +1407,7 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
             continue;
 
         register_count = range_map_get_register_count(range_map, e->register_index, e->mask);
-        assert(register_count != UINT8_MAX);
+        VKD3D_ASSERT(register_count != UINT8_MAX);
         register_count += !register_count;
 
         if (register_count > 1)
@@ -1428,7 +1430,7 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
 static unsigned int shader_register_normalise_arrayed_addressing(struct vkd3d_shader_register *reg,
         unsigned int id_idx, unsigned int register_index)
 {
-    assert(id_idx < ARRAY_SIZE(reg->idx) - 1);
+    VKD3D_ASSERT(id_idx < ARRAY_SIZE(reg->idx) - 1);
 
     /* For a relative-addressed register index, move the id up a slot to separate it from the address,
      * because rel_addr can be replaced with a constant offset in some cases. */
@@ -1535,7 +1537,7 @@ static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_par
     if (is_io_dcl)
     {
         /* Validated in the TPF reader. */
-        assert(element_idx < ARRAY_SIZE(normaliser->input_dcl_params));
+        VKD3D_ASSERT(element_idx < ARRAY_SIZE(normaliser->input_dcl_params));
 
         if (dcl_params[element_idx])
         {
@@ -1560,7 +1562,7 @@ static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_par
         else
         {
             /* The control point id param. */
-            assert(reg->idx[0].rel_addr);
+            VKD3D_ASSERT(reg->idx[0].rel_addr);
         }
         id_idx = 1;
     }
@@ -1799,7 +1801,7 @@ static enum vkd3d_result vsir_program_normalise_io_registers(struct vsir_program
                     normaliser.input_range_map[i][j] = normaliser.output_range_map[i][j];
                 else if (normaliser.input_range_map[i][j] && !normaliser.output_range_map[i][j])
                     normaliser.output_range_map[i][j] = normaliser.input_range_map[i][j];
-                else assert(normaliser.input_range_map[i][j] == normaliser.output_range_map[i][j]);
+                else VKD3D_ASSERT(normaliser.input_range_map[i][j] == normaliser.output_range_map[i][j]);
             }
         }
     }
@@ -2815,7 +2817,7 @@ static enum vkd3d_result vsir_program_flatten_control_flow_constructs(struct vsi
 
 static unsigned int label_from_src_param(const struct vkd3d_shader_src_param *param)
 {
-    assert(param->reg.type == VKD3DSPR_LABEL);
+    VKD3D_ASSERT(param->reg.type == VKD3DSPR_LABEL);
     return param->reg.idx[0].offset;
 }
 
@@ -3084,7 +3086,7 @@ static enum vkd3d_result vsir_program_materialise_phi_ssas_to_temps(struct vsir_
             unsigned int label;
 
             label = label_from_src_param(&ins->src[j + 1]);
-            assert(label);
+            VKD3D_ASSERT(label);
 
             info = &block_info[label - 1];
 
@@ -3241,7 +3243,7 @@ static enum vkd3d_result vsir_block_init(struct vsir_block *block, unsigned int
 
     byte_count = VKD3D_BITMAP_SIZE(block_count) * sizeof(*block->dominates);
 
-    assert(label);
+    VKD3D_ASSERT(label);
     memset(block, 0, sizeof(*block));
     block->label = label;
     vsir_block_list_init(&block->predecessors);
@@ -3525,7 +3527,7 @@ static enum vkd3d_result vsir_cfg_add_edge(struct vsir_cfg *cfg, struct vsir_blo
     struct vsir_block *successor = &cfg->blocks[target - 1];
     enum vkd3d_result ret;
 
-    assert(successor->label != 0);
+    VKD3D_ASSERT(successor->label != 0);
 
     if ((ret = vsir_block_list_add(&block->successors, successor)) < 0)
         return ret;
@@ -3702,11 +3704,11 @@ static enum vkd3d_result vsir_cfg_init(struct vsir_cfg *cfg, struct vsir_program
             {
                 unsigned int label = label_from_src_param(&instruction->src[0]);
 
-                assert(!current_block);
-                assert(label > 0);
-                assert(label <= cfg->block_count);
+                VKD3D_ASSERT(!current_block);
+                VKD3D_ASSERT(label > 0);
+                VKD3D_ASSERT(label <= cfg->block_count);
                 current_block = &cfg->blocks[label - 1];
-                assert(current_block->label == 0);
+                VKD3D_ASSERT(current_block->label == 0);
                 if ((ret = vsir_block_init(current_block, label, program->block_count)) < 0)
                     goto fail;
                 current_block->begin = &program->instructions.elements[i + 1];
@@ -3717,7 +3719,7 @@ static enum vkd3d_result vsir_cfg_init(struct vsir_cfg *cfg, struct vsir_program
 
             case VKD3DSIH_BRANCH:
             case VKD3DSIH_RET:
-                assert(current_block);
+                VKD3D_ASSERT(current_block);
                 current_block->end = instruction;
                 current_block = NULL;
                 break;
@@ -3725,7 +3727,7 @@ static enum vkd3d_result vsir_cfg_init(struct vsir_cfg *cfg, struct vsir_program
             case VKD3DSIH_HS_CONTROL_POINT_PHASE:
             case VKD3DSIH_HS_FORK_PHASE:
             case VKD3DSIH_HS_JOIN_PHASE:
-                assert(!current_block);
+                VKD3D_ASSERT(!current_block);
                 finish = true;
                 break;
 
@@ -3795,7 +3797,7 @@ static void vsir_cfg_compute_dominators_recurse(struct vsir_block *current, stru
 {
     size_t i;
 
-    assert(current->label != 0);
+    VKD3D_ASSERT(current->label != 0);
 
     if (current == reference)
         return;
@@ -4010,7 +4012,7 @@ static enum vkd3d_result vsir_cfg_sort_nodes(struct vsir_cfg *cfg)
         /* Do not count back edges. */
         if (cfg->loops_by_header[i] != SIZE_MAX)
         {
-            assert(in_degrees[i] > 0);
+            VKD3D_ASSERT(in_degrees[i] > 0);
             in_degrees[i] -= 1;
         }
 
@@ -4096,7 +4098,7 @@ static enum vkd3d_result vsir_cfg_sort_nodes(struct vsir_cfg *cfg)
 
             inner_stack_item->seen_count += new_seen_count;
 
-            assert(inner_stack_item->seen_count <= inner_stack_item->loop->count);
+            VKD3D_ASSERT(inner_stack_item->seen_count <= inner_stack_item->loop->count);
             if (inner_stack_item->seen_count != inner_stack_item->loop->count)
                 break;
 
@@ -4116,7 +4118,7 @@ static enum vkd3d_result vsir_cfg_sort_nodes(struct vsir_cfg *cfg)
             if (vsir_block_dominates(successor, block))
                 continue;
 
-            assert(in_degrees[successor->label - 1] > 0);
+            VKD3D_ASSERT(in_degrees[successor->label - 1] > 0);
             --in_degrees[successor->label - 1];
 
             if (in_degrees[successor->label - 1] == 0)
@@ -4137,7 +4139,7 @@ static enum vkd3d_result vsir_cfg_sort_nodes(struct vsir_cfg *cfg)
         goto fail;
     }
 
-    assert(sorter.stack_count == 0);
+    VKD3D_ASSERT(sorter.stack_count == 0);
 
     vkd3d_free(in_degrees);
     vkd3d_free(sorter.stack);
@@ -4207,7 +4209,7 @@ static enum vkd3d_result vsir_cfg_generate_synthetic_loop_intervals(struct vsir_
             if (vsir_block_dominates(successor, block))
                 continue;
 
-            assert(block->order_pos < successor->order_pos);
+            VKD3D_ASSERT(block->order_pos < successor->order_pos);
 
             /* Jumping from a block to the following one is always
              * possible, so nothing to do. */
@@ -4280,7 +4282,7 @@ static enum vkd3d_result vsir_cfg_generate_synthetic_loop_intervals(struct vsir_
                 {
                     if (interval->synthetic)
                         interval->begin = min(begin, interval->begin);
-                    assert(begin >= interval->begin);
+                    VKD3D_ASSERT(begin >= interval->begin);
                 }
             }
 
@@ -4333,7 +4335,7 @@ static void vsir_cfg_compute_edge_action(struct vsir_cfg *cfg, struct vsir_block
                 break;
         }
 
-        assert(action->target != UINT_MAX);
+        VKD3D_ASSERT(action->target != UINT_MAX);
         action->jump_type = JUMP_CONTINUE;
     }
     else
@@ -4355,7 +4357,7 @@ static void vsir_cfg_compute_edge_action(struct vsir_cfg *cfg, struct vsir_block
 
         if (action->target == UINT_MAX)
         {
-            assert(successor->order_pos == block->order_pos + 1);
+            VKD3D_ASSERT(successor->order_pos == block->order_pos + 1);
             action->jump_type = JUMP_NONE;
         }
         else
@@ -4382,7 +4384,7 @@ static enum vkd3d_result vsir_cfg_build_structured_program(struct vsir_cfg *cfg)
         struct vsir_block *block = cfg->order.blocks[i];
         struct vsir_cfg_structure *structure;
 
-        assert(stack_depth > 0);
+        VKD3D_ASSERT(stack_depth > 0);
 
         /* Open loop intervals. */
         while (open_interval_idx < cfg->loop_interval_count)
@@ -4441,7 +4443,7 @@ static enum vkd3d_result vsir_cfg_build_structured_program(struct vsir_cfg *cfg)
                  * selection ladders. */
                 if (action_true.successor == action_false.successor)
                 {
-                    assert(action_true.jump_type == action_false.jump_type);
+                    VKD3D_ASSERT(action_true.jump_type == action_false.jump_type);
                 }
                 else
                 {
@@ -4457,7 +4459,7 @@ static enum vkd3d_result vsir_cfg_build_structured_program(struct vsir_cfg *cfg)
                         struct vsir_cfg_structure_list *inner_loop_frame = stack[stack_depth - 2];
                         struct vsir_cfg_structure *inner_loop = &inner_loop_frame->structures[inner_loop_frame->count - 1];
 
-                        assert(inner_loop->type == STRUCTURE_TYPE_LOOP);
+                        VKD3D_ASSERT(inner_loop->type == STRUCTURE_TYPE_LOOP);
 
                         /* Otherwise, if one of the branches is
                          * continueing the inner loop we're inside,
@@ -4474,7 +4476,7 @@ static enum vkd3d_result vsir_cfg_build_structured_program(struct vsir_cfg *cfg)
                         action_false = tmp;
                     }
 
-                    assert(action_true.jump_type != JUMP_NONE);
+                    VKD3D_ASSERT(action_true.jump_type != JUMP_NONE);
 
                     if (!(structure = vsir_cfg_structure_list_append(stack[stack_depth - 1], STRUCTURE_TYPE_JUMP)))
                         goto fail;
@@ -4514,8 +4516,8 @@ static enum vkd3d_result vsir_cfg_build_structured_program(struct vsir_cfg *cfg)
         }
     }
 
-    assert(stack_depth == 0);
-    assert(open_interval_idx == cfg->loop_interval_count);
+    VKD3D_ASSERT(stack_depth == 0);
+    VKD3D_ASSERT(open_interval_idx == cfg->loop_interval_count);
 
     if (TRACE_ON())
         vsir_cfg_dump_structured_program(cfg);
@@ -4539,7 +4541,7 @@ static void vsir_cfg_remove_trailing_continue(struct vsir_cfg *cfg,
             && !last->u.jump.condition && last->u.jump.target == target)
     {
         --list->count;
-        assert(cfg->loop_intervals[target].target_count > 0);
+        VKD3D_ASSERT(cfg->loop_intervals[target].target_count > 0);
         --cfg->loop_intervals[target].target_count;
     }
 }
@@ -4580,7 +4582,7 @@ static enum vkd3d_result vsir_cfg_move_breaks_out_of_selections(struct vsir_cfg
     size_t pos = list->count - 1;
 
     selection = &list->structures[pos];
-    assert(selection->type == STRUCTURE_TYPE_SELECTION);
+    VKD3D_ASSERT(selection->type == STRUCTURE_TYPE_SELECTION);
 
     if_break = vsir_cfg_get_trailing_break(&selection->u.selection.if_body);
     else_break = vsir_cfg_get_trailing_break(&selection->u.selection.else_body);
@@ -4601,19 +4603,19 @@ static enum vkd3d_result vsir_cfg_move_breaks_out_of_selections(struct vsir_cfg
     /* Pointer `selection' could have been invalidated by the append
      * operation. */
     selection = &list->structures[pos];
-    assert(selection->type == STRUCTURE_TYPE_SELECTION);
+    VKD3D_ASSERT(selection->type == STRUCTURE_TYPE_SELECTION);
 
     if (if_target == max_target)
     {
         --selection->u.selection.if_body.count;
-        assert(cfg->loop_intervals[if_target].target_count > 0);
+        VKD3D_ASSERT(cfg->loop_intervals[if_target].target_count > 0);
         --cfg->loop_intervals[if_target].target_count;
     }
 
     if (else_target == max_target)
     {
         --selection->u.selection.else_body.count;
-        assert(cfg->loop_intervals[else_target].target_count > 0);
+        VKD3D_ASSERT(cfg->loop_intervals[else_target].target_count > 0);
         --cfg->loop_intervals[else_target].target_count;
     }
 
@@ -4721,7 +4723,7 @@ static enum vkd3d_result vsir_cfg_append_loop(struct vsir_cfg *cfg,
     }
 
     target = trailing_break->u.jump.target;
-    assert(cfg->loop_intervals[target].target_count > 0);
+    VKD3D_ASSERT(cfg->loop_intervals[target].target_count > 0);
 
     /* If the loop is not targeted by any jump, we can remove it. The
      * trailing `break' then targets another loop, so we have to keep
@@ -4888,7 +4890,7 @@ static void vsir_cfg_mark_trampolines(struct vsir_cfg *cfg, struct vsir_cfg_stru
                     break;
                 for (l = loop; l && l->u.loop.idx != structure->u.jump.target; l = l->u.loop.outer_loop)
                 {
-                    assert(l->type == STRUCTURE_TYPE_LOOP);
+                    VKD3D_ASSERT(l->type == STRUCTURE_TYPE_LOOP);
                     l->u.loop.needs_trampoline = true;
                 }
                 break;
@@ -4928,7 +4930,7 @@ static void vsir_cfg_mark_launchers(struct vsir_cfg *cfg, struct vsir_cfg_struct
             case STRUCTURE_TYPE_JUMP:
                 if (structure->u.jump.type != JUMP_BREAK && structure->u.jump.type != JUMP_CONTINUE)
                     break;
-                assert(loop && loop->type == STRUCTURE_TYPE_LOOP);
+                VKD3D_ASSERT(loop && loop->type == STRUCTURE_TYPE_LOOP);
                 if (loop->u.loop.needs_trampoline)
                     structure->u.jump.needs_launcher = true;
                 break;
@@ -5126,7 +5128,7 @@ static enum vkd3d_result vsir_cfg_structure_list_emit_jump(struct vsir_cfg *cfg,
             break;
 
         case JUMP_RET:
-            assert(!jump->condition);
+            VKD3D_ASSERT(!jump->condition);
             opcode = VKD3DSIH_RET;
             break;
 
@@ -5266,18 +5268,18 @@ static enum vkd3d_result vsir_program_structurize(struct vsir_program *program,
         switch (ins->opcode)
         {
             case VKD3DSIH_LABEL:
-                assert(program->shader_version.type != VKD3D_SHADER_TYPE_HULL);
+                VKD3D_ASSERT(program->shader_version.type != VKD3D_SHADER_TYPE_HULL);
                 TRACE("Structurizing a non-hull shader.\n");
                 if ((ret = vsir_program_structurize_function(program, message_context,
                         &target, &i)) < 0)
                     goto fail;
-                assert(i == program->instructions.count);
+                VKD3D_ASSERT(i == program->instructions.count);
                 break;
 
             case VKD3DSIH_HS_CONTROL_POINT_PHASE:
             case VKD3DSIH_HS_FORK_PHASE:
             case VKD3DSIH_HS_JOIN_PHASE:
-                assert(program->shader_version.type == VKD3D_SHADER_TYPE_HULL);
+                VKD3D_ASSERT(program->shader_version.type == VKD3D_SHADER_TYPE_HULL);
                 TRACE("Structurizing phase %u of a hull shader.\n", ins->opcode);
                 target.instructions[target.ins_count++] = *ins;
                 ++i;
@@ -5439,18 +5441,18 @@ static enum vkd3d_result vsir_program_materialize_undominated_ssas_to_temps(stru
         switch (ins->opcode)
         {
             case VKD3DSIH_LABEL:
-                assert(program->shader_version.type != VKD3D_SHADER_TYPE_HULL);
+                VKD3D_ASSERT(program->shader_version.type != VKD3D_SHADER_TYPE_HULL);
                 TRACE("Materializing undominated SSAs in a non-hull shader.\n");
                 if ((ret = vsir_program_materialize_undominated_ssas_to_temps_in_function(
                         program, message_context, &i)) < 0)
                     return ret;
-                assert(i == program->instructions.count);
+                VKD3D_ASSERT(i == program->instructions.count);
                 break;
 
             case VKD3DSIH_HS_CONTROL_POINT_PHASE:
             case VKD3DSIH_HS_FORK_PHASE:
             case VKD3DSIH_HS_JOIN_PHASE:
-                assert(program->shader_version.type == VKD3D_SHADER_TYPE_HULL);
+                VKD3D_ASSERT(program->shader_version.type == VKD3D_SHADER_TYPE_HULL);
                 TRACE("Materializing undominated SSAs in phase %u of a hull shader.\n", ins->opcode);
                 ++i;
                 if ((ret = vsir_program_materialize_undominated_ssas_to_temps_in_function(
@@ -6097,8 +6099,8 @@ static const char *name_from_cf_type(enum cf_type type)
 static void vsir_validate_cf_type(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction, enum cf_type expected_type)
 {
-    assert(ctx->cf_type != CF_TYPE_UNKNOWN);
-    assert(expected_type != CF_TYPE_UNKNOWN);
+    VKD3D_ASSERT(ctx->cf_type != CF_TYPE_UNKNOWN);
+    VKD3D_ASSERT(expected_type != CF_TYPE_UNKNOWN);
     if (ctx->cf_type != expected_type)
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "Invalid instruction %#x in %s shader.",
                 instruction->opcode, name_from_cf_type(ctx->cf_type));
diff --git a/libs/vkd3d/libs/vkd3d-shader/preproc.h b/libs/vkd3d/libs/vkd3d-shader/preproc.h
index 4860cf5f90e..9806614a35b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/preproc.h
+++ b/libs/vkd3d/libs/vkd3d-shader/preproc.h
@@ -141,7 +141,7 @@ void preproc_warning(struct preproc_ctx *ctx, const struct vkd3d_shader_location
 
 static inline struct preproc_file *preproc_get_top_file(struct preproc_ctx *ctx)
 {
-    assert(ctx->file_count);
+    VKD3D_ASSERT(ctx->file_count);
     return &ctx->file_stack[ctx->file_count - 1];
 }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/preproc.l b/libs/vkd3d/libs/vkd3d-shader/preproc.l
index a3cdbe559a7..7fc963192cf 100644
--- a/libs/vkd3d/libs/vkd3d-shader/preproc.l
+++ b/libs/vkd3d/libs/vkd3d-shader/preproc.l
@@ -409,7 +409,7 @@ int yylex(YYSTYPE *lval, YYLTYPE *lloc, yyscan_t scanner)
             }
             ctx->last_was_eof = false;
 
-            assert(ctx->file_count);
+            VKD3D_ASSERT(ctx->file_count);
             if (!(token = preproc_lexer_lex(lval, lloc, scanner)))
             {
                 ctx->last_was_eof = true;
@@ -647,7 +647,7 @@ int yylex(YYSTYPE *lval, YYLTYPE *lloc, yyscan_t scanner)
             {
                 struct preproc_text *current_arg = NULL;
 
-                assert(func_state->macro->arg_count);
+                VKD3D_ASSERT(func_state->macro->arg_count);
 
                 if (func_state->arg_count < func_state->macro->arg_count)
                     current_arg = &func_state->macro->arg_values[func_state->arg_count];
diff --git a/libs/vkd3d/libs/vkd3d-shader/preproc.y b/libs/vkd3d/libs/vkd3d-shader/preproc.y
index 009c35ffb97..366e351e3b5 100644
--- a/libs/vkd3d/libs/vkd3d-shader/preproc.y
+++ b/libs/vkd3d/libs/vkd3d-shader/preproc.y
@@ -119,7 +119,7 @@ bool preproc_add_macro(struct preproc_ctx *ctx, const struct vkd3d_shader_locati
     macro->body.text = *body;
     macro->body.location = *body_loc;
     ret = rb_put(&ctx->macros, name, &macro->entry);
-    assert(!ret);
+    VKD3D_ASSERT(!ret);
     return true;
 }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index d66446be0b0..bc8a7a5b28c 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -313,7 +313,7 @@ static bool vkd3d_spirv_stream_append(struct vkd3d_spirv_stream *dst_stream,
     struct vkd3d_spirv_chunk *chunk;
     size_t src_location = 0;
 
-    assert(list_empty(&dst_stream->inserted_chunks));
+    VKD3D_ASSERT(list_empty(&dst_stream->inserted_chunks));
 
     LIST_FOR_EACH_ENTRY(chunk, &src_stream->inserted_chunks, struct vkd3d_spirv_chunk, entry)
         src_word_count += chunk->word_count;
@@ -322,16 +322,16 @@ static bool vkd3d_spirv_stream_append(struct vkd3d_spirv_stream *dst_stream,
             dst_stream->word_count + src_word_count, sizeof(*dst_stream->words)))
         return false;
 
-    assert(dst_stream->word_count + src_word_count <= dst_stream->capacity);
+    VKD3D_ASSERT(dst_stream->word_count + src_word_count <= dst_stream->capacity);
     LIST_FOR_EACH_ENTRY(chunk, &src_stream->inserted_chunks, struct vkd3d_spirv_chunk, entry)
     {
-        assert(src_location <= chunk->location);
+        VKD3D_ASSERT(src_location <= chunk->location);
         word_count = chunk->location - src_location;
         memcpy(&dst_stream->words[dst_stream->word_count], &src_stream->words[src_location],
                 word_count * sizeof(*src_stream->words));
         dst_stream->word_count += word_count;
         src_location += word_count;
-        assert(src_location == chunk->location);
+        VKD3D_ASSERT(src_location == chunk->location);
 
         memcpy(&dst_stream->words[dst_stream->word_count], chunk->words,
                 chunk->word_count * sizeof(*chunk->words));
@@ -464,7 +464,7 @@ static void vkd3d_spirv_set_execution_model(struct vkd3d_spirv_builder *builder,
 
 static uint32_t vkd3d_spirv_opcode_word(SpvOp op, unsigned int word_count)
 {
-    assert(!(op & ~SpvOpCodeMask));
+    VKD3D_ASSERT(!(op & ~SpvOpCodeMask));
     return (word_count << SpvWordCountShift) | op;
 }
 
@@ -538,7 +538,7 @@ static int vkd3d_spirv_declaration_compare(const void *key, const struct rb_entr
         return ret;
     if ((ret = vkd3d_u32_compare(a->parameter_count, b->parameter_count)))
         return ret;
-    assert(a->parameter_count <= ARRAY_SIZE(a->parameters));
+    VKD3D_ASSERT(a->parameter_count <= ARRAY_SIZE(a->parameters));
     return memcmp(&a->parameters, &b->parameters, a->parameter_count * sizeof(*a->parameters));
 }
 
@@ -554,7 +554,7 @@ static void vkd3d_spirv_insert_declaration(struct vkd3d_spirv_builder *builder,
 {
     struct vkd3d_spirv_declaration *d;
 
-    assert(declaration->parameter_count <= ARRAY_SIZE(declaration->parameters));
+    VKD3D_ASSERT(declaration->parameter_count <= ARRAY_SIZE(declaration->parameters));
 
     if (!(d = vkd3d_malloc(sizeof(*d))))
         return;
@@ -823,7 +823,7 @@ static uint32_t vkd3d_spirv_build_op_tr2v(struct vkd3d_spirv_builder *builder,
 static void vkd3d_spirv_begin_function_stream_insertion(struct vkd3d_spirv_builder *builder,
         size_t location)
 {
-    assert(builder->insertion_location == ~(size_t)0);
+    VKD3D_ASSERT(builder->insertion_location == ~(size_t)0);
 
     if (vkd3d_spirv_stream_current_location(&builder->function_stream) == location)
         return;
@@ -1166,7 +1166,7 @@ static uint32_t vkd3d_spirv_get_op_constant(struct vkd3d_spirv_builder *builder,
 static uint32_t vkd3d_spirv_build_op_constant64(struct vkd3d_spirv_builder *builder,
         uint32_t result_type, const uint32_t *values, unsigned int value_count)
 {
-    assert(value_count == 2);
+    VKD3D_ASSERT(value_count == 2);
     return vkd3d_spirv_build_op_trv(builder, &builder->global_stream,
             SpvOpConstant, result_type, values, value_count);
 }
@@ -1583,13 +1583,13 @@ static uint32_t vkd3d_spirv_build_image_instruction(struct vkd3d_spirv_builder *
     unsigned int index = 0, i;
     uint32_t w[10];
 
-    assert(operand_count <= ARRAY_SIZE(w));
+    VKD3D_ASSERT(operand_count <= ARRAY_SIZE(w));
     for (i = 0; i < operand_count; ++i)
         w[index++] = operands[i];
 
     if (image_operands_mask)
     {
-        assert(index + 1 + image_operand_count <= ARRAY_SIZE(w));
+        VKD3D_ASSERT(index + 1 + image_operand_count <= ARRAY_SIZE(w));
         w[index++] = image_operands_mask;
         for (i = 0; i < image_operand_count; ++i)
             w[index++] = image_operands[i];
@@ -1606,9 +1606,9 @@ static uint32_t vkd3d_spirv_build_op_image_sample(struct vkd3d_spirv_builder *bu
     const uint32_t operands[] = {sampled_image_id, coordinate_id};
 
     if (op == SpvOpImageSampleExplicitLod)
-        assert(image_operands_mask & (SpvImageOperandsLodMask | SpvImageOperandsGradMask));
+        VKD3D_ASSERT(image_operands_mask & (SpvImageOperandsLodMask | SpvImageOperandsGradMask));
     else
-        assert(op == SpvOpImageSampleImplicitLod);
+        VKD3D_ASSERT(op == SpvOpImageSampleImplicitLod);
 
     return vkd3d_spirv_build_image_instruction(builder, op, result_type,
             operands, ARRAY_SIZE(operands), image_operands_mask, image_operands, image_operand_count);
@@ -1621,9 +1621,9 @@ static uint32_t vkd3d_spirv_build_op_image_sample_dref(struct vkd3d_spirv_builde
     const uint32_t operands[] = {sampled_image_id, coordinate_id, dref_id};
 
     if (op == SpvOpImageSampleDrefExplicitLod)
-        assert(image_operands_mask & (SpvImageOperandsLodMask | SpvImageOperandsGradMask));
+        VKD3D_ASSERT(image_operands_mask & (SpvImageOperandsLodMask | SpvImageOperandsGradMask));
     else
-        assert(op == SpvOpImageSampleDrefImplicitLod);
+        VKD3D_ASSERT(op == SpvOpImageSampleDrefImplicitLod);
 
     return vkd3d_spirv_build_image_instruction(builder, op, result_type,
             operands, ARRAY_SIZE(operands), image_operands_mask, image_operands, image_operand_count);
@@ -1900,7 +1900,7 @@ static uint32_t vkd3d_spirv_get_type_id(struct vkd3d_spirv_builder *builder,
     }
     else
     {
-        assert(component_type != VKD3D_SHADER_COMPONENT_VOID);
+        VKD3D_ASSERT(component_type != VKD3D_SHADER_COMPONENT_VOID);
         scalar_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
         return vkd3d_spirv_get_op_type_vector(builder, scalar_id, component_count);
     }
@@ -2266,7 +2266,7 @@ static void vkd3d_symbol_make_register(struct vkd3d_symbol *symbol,
         case VKD3DSPR_OUTPUT:
         case VKD3DSPR_PATCHCONST:
             symbol->key.reg.idx = reg->idx_count ? reg->idx[reg->idx_count - 1].offset : ~0u;
-            assert(!reg->idx_count || symbol->key.reg.idx != ~0u);
+            VKD3D_ASSERT(!reg->idx_count || symbol->key.reg.idx != ~0u);
             break;
 
         case VKD3DSPR_IMMCONSTBUFFER:
@@ -2905,7 +2905,7 @@ static struct vkd3d_shader_descriptor_binding spirv_compiler_get_descriptor_bind
 
     if (is_uav_counter)
     {
-        assert(descriptor_type == VKD3D_SHADER_DESCRIPTOR_TYPE_UAV);
+        VKD3D_ASSERT(descriptor_type == VKD3D_SHADER_DESCRIPTOR_TYPE_UAV);
         binding_offsets = compiler->offset_info.uav_counter_offsets;
         for (i = 0; i < shader_interface->uav_counter_count; ++i)
         {
@@ -3023,7 +3023,7 @@ static uint32_t spirv_compiler_get_constant(struct spirv_compiler *compiler,
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     unsigned int i;
 
-    assert(0 < component_count && component_count <= VKD3D_VEC4_SIZE);
+    VKD3D_ASSERT(0 < component_count && component_count <= VKD3D_VEC4_SIZE);
     type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
 
     switch (component_type)
@@ -3064,7 +3064,7 @@ static uint32_t spirv_compiler_get_constant64(struct spirv_compiler *compiler,
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     unsigned int i;
 
-    assert(0 < component_count && component_count <= VKD3D_DVEC2_SIZE);
+    VKD3D_ASSERT(0 < component_count && component_count <= VKD3D_DVEC2_SIZE);
     type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
 
     if (component_type != VKD3D_SHADER_COMPONENT_DOUBLE && component_type != VKD3D_SHADER_COMPONENT_UINT64)
@@ -3442,7 +3442,7 @@ static uint32_t spirv_compiler_emit_construct_vector(struct spirv_compiler *comp
     uint32_t type_id, result_id;
     unsigned int i;
 
-    assert(val_component_idx < val_component_count);
+    VKD3D_ASSERT(val_component_idx < val_component_count);
 
     type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
     if (val_component_count == 1)
@@ -3503,11 +3503,11 @@ static bool spirv_compiler_get_register_info(struct spirv_compiler *compiler,
     struct vkd3d_symbol reg_symbol, *symbol;
     struct rb_entry *entry;
 
-    assert(!register_is_constant_or_undef(reg));
+    VKD3D_ASSERT(!register_is_constant_or_undef(reg));
 
     if (reg->type == VKD3DSPR_TEMP)
     {
-        assert(reg->idx[0].offset < compiler->temp_count);
+        VKD3D_ASSERT(reg->idx[0].offset < compiler->temp_count);
         register_info->id = compiler->temp_id + reg->idx[0].offset;
         register_info->storage_class = SpvStorageClassPrivate;
         register_info->descriptor_array = NULL;
@@ -3638,7 +3638,7 @@ static void spirv_compiler_emit_dereference_register(struct spirv_compiler *comp
 
     if (reg->type == VKD3DSPR_CONSTBUFFER)
     {
-        assert(!reg->idx[0].rel_addr);
+        VKD3D_ASSERT(!reg->idx[0].rel_addr);
         if (register_info->descriptor_array)
             indexes[index_count++] = spirv_compiler_get_descriptor_index(compiler, reg,
                     register_info->descriptor_array, register_info->binding_base_idx, VKD3D_SHADER_RESOURCE_BUFFER);
@@ -3756,7 +3756,7 @@ static uint32_t spirv_compiler_emit_swizzle(struct spirv_compiler *compiler,
         {
             if (write_mask & (VKD3DSP_WRITEMASK_0 << i))
             {
-                assert(VKD3DSP_WRITEMASK_0 << vsir_swizzle_get_component(swizzle, i) == val_write_mask);
+                VKD3D_ASSERT(VKD3DSP_WRITEMASK_0 << vsir_swizzle_get_component(swizzle, i) == val_write_mask);
                 components[component_idx++] = val_id;
             }
         }
@@ -3781,7 +3781,7 @@ static uint32_t spirv_compiler_emit_vector_shuffle(struct spirv_compiler *compil
     uint32_t type_id;
     unsigned int i;
 
-    assert(component_count <= ARRAY_SIZE(components));
+    VKD3D_ASSERT(component_count <= ARRAY_SIZE(components));
 
     for (i = 0; i < component_count; ++i)
     {
@@ -3804,7 +3804,7 @@ static uint32_t spirv_compiler_emit_int_to_bool(struct spirv_compiler *compiler,
     uint32_t type_id;
     SpvOp op;
 
-    assert(!(condition & ~(VKD3D_SHADER_CONDITIONAL_OP_NZ | VKD3D_SHADER_CONDITIONAL_OP_Z)));
+    VKD3D_ASSERT(!(condition & ~(VKD3D_SHADER_CONDITIONAL_OP_NZ | VKD3D_SHADER_CONDITIONAL_OP_Z)));
 
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_BOOL, component_count);
     op = condition & VKD3D_SHADER_CONDITIONAL_OP_Z ? SpvOpIEqual : SpvOpINotEqual;
@@ -3934,7 +3934,7 @@ static uint32_t spirv_compiler_emit_load_constant(struct spirv_compiler *compile
     uint32_t values[VKD3D_VEC4_SIZE] = {0};
     unsigned int i, j;
 
-    assert(reg->type == VKD3DSPR_IMMCONST);
+    VKD3D_ASSERT(reg->type == VKD3DSPR_IMMCONST);
 
     if (reg->dimension == VSIR_DIMENSION_SCALAR)
     {
@@ -3962,7 +3962,7 @@ static uint32_t spirv_compiler_emit_load_constant64(struct spirv_compiler *compi
     uint64_t values[VKD3D_DVEC2_SIZE] = {0};
     unsigned int i, j;
 
-    assert(reg->type == VKD3DSPR_IMMCONST64);
+    VKD3D_ASSERT(reg->type == VKD3DSPR_IMMCONST64);
 
     if (reg->dimension == VSIR_DIMENSION_SCALAR)
     {
@@ -3989,7 +3989,7 @@ static uint32_t spirv_compiler_emit_load_undef(struct spirv_compiler *compiler,
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id;
 
-    assert(reg->type == VKD3DSPR_UNDEF);
+    VKD3D_ASSERT(reg->type == VKD3DSPR_UNDEF);
 
     type_id = vkd3d_spirv_get_type_id_for_data_type(builder, reg->data_type, component_count);
     return vkd3d_spirv_get_op_undef(builder, type_id);
@@ -4005,8 +4005,8 @@ static uint32_t spirv_compiler_emit_load_scalar(struct spirv_compiler *compiler,
     enum vkd3d_shader_component_type component_type;
     uint32_t skipped_component_mask;
 
-    assert(!register_is_constant_or_undef(reg));
-    assert(vsir_write_mask_component_count(write_mask) == 1);
+    VKD3D_ASSERT(!register_is_constant_or_undef(reg));
+    VKD3D_ASSERT(vsir_write_mask_component_count(write_mask) == 1);
 
     component_idx = vsir_write_mask_get_component_idx(write_mask);
     component_idx = vsir_swizzle_get_component(swizzle, component_idx);
@@ -4129,8 +4129,8 @@ static uint32_t spirv_compiler_emit_constant_array(struct spirv_compiler *compil
 static const struct ssa_register_info *spirv_compiler_get_ssa_register_info(const struct spirv_compiler *compiler,
         const struct vkd3d_shader_register *reg)
 {
-    assert(reg->idx[0].offset < compiler->ssa_register_count);
-    assert(reg->idx_count == 1);
+    VKD3D_ASSERT(reg->idx[0].offset < compiler->ssa_register_count);
+    VKD3D_ASSERT(reg->idx_count == 1);
     return &compiler->ssa_register_info[reg->idx[0].offset];
 }
 
@@ -4138,7 +4138,7 @@ static void spirv_compiler_set_ssa_register_info(const struct spirv_compiler *co
         const struct vkd3d_shader_register *reg, uint32_t val_id)
 {
     unsigned int i = reg->idx[0].offset;
-    assert(i < compiler->ssa_register_count);
+    VKD3D_ASSERT(i < compiler->ssa_register_count);
     compiler->ssa_register_info[i].data_type = reg->data_type;
     compiler->ssa_register_info[i].id = val_id;
 }
@@ -4158,10 +4158,10 @@ static uint32_t spirv_compiler_emit_load_ssa_reg(struct spirv_compiler *compiler
     if (!val_id)
     {
         /* Should only be from a missing instruction implementation. */
-        assert(compiler->failed);
+        VKD3D_ASSERT(compiler->failed);
         return 0;
     }
-    assert(vkd3d_swizzle_is_scalar(swizzle, reg));
+    VKD3D_ASSERT(vkd3d_swizzle_is_scalar(swizzle, reg));
 
     reg_component_type = vkd3d_component_type_from_data_type(ssa->data_type);
 
@@ -4383,7 +4383,7 @@ static void spirv_compiler_emit_store(struct spirv_compiler *compiler,
     unsigned int i, src_idx, dst_idx;
     uint32_t type_id, dst_val_id;
 
-    assert(write_mask);
+    VKD3D_ASSERT(write_mask);
 
     component_count = vsir_write_mask_component_count(write_mask);
     dst_component_count = vsir_write_mask_component_count(dst_write_mask);
@@ -4408,7 +4408,7 @@ static void spirv_compiler_emit_store(struct spirv_compiler *compiler,
         type_id = vkd3d_spirv_get_type_id(builder, component_type, dst_component_count);
         dst_val_id = vkd3d_spirv_build_op_load(builder, type_id, dst_id, SpvMemoryAccessMaskNone);
 
-        assert(component_count <= ARRAY_SIZE(components));
+        VKD3D_ASSERT(component_count <= ARRAY_SIZE(components));
 
         for (i = 0, src_idx = 0, dst_idx = 0; dst_idx < VKD3D_VEC4_SIZE; ++dst_idx)
         {
@@ -4437,7 +4437,7 @@ static void spirv_compiler_emit_store_reg(struct spirv_compiler *compiler,
     uint32_t src_write_mask = write_mask;
     uint32_t type_id;
 
-    assert(!register_is_constant_or_undef(reg));
+    VKD3D_ASSERT(!register_is_constant_or_undef(reg));
 
     if (reg->type == VKD3DSPR_SSA)
     {
@@ -4496,7 +4496,7 @@ static uint32_t spirv_compiler_emit_sat(struct spirv_compiler *compiler,
 static void spirv_compiler_emit_store_dst(struct spirv_compiler *compiler,
         const struct vkd3d_shader_dst_param *dst, uint32_t val_id)
 {
-    assert(!(dst->modifiers & ~VKD3DSPDM_SATURATE));
+    VKD3D_ASSERT(!(dst->modifiers & ~VKD3DSPDM_SATURATE));
     if (dst->modifiers & VKD3DSPDM_SATURATE)
         val_id = spirv_compiler_emit_sat(compiler, &dst->reg, dst->write_mask, val_id);
 
@@ -4928,7 +4928,7 @@ static uint32_t spirv_compiler_get_invocation_id(struct spirv_compiler *compiler
 {
     struct vkd3d_shader_register r;
 
-    assert(compiler->shader_type == VKD3D_SHADER_TYPE_HULL);
+    VKD3D_ASSERT(compiler->shader_type == VKD3D_SHADER_TYPE_HULL);
 
     vsir_register_init(&r, VKD3DSPR_OUTPOINTID, VKD3D_DATA_FLOAT, 0);
     return spirv_compiler_get_register_id(compiler, &r);
@@ -5048,7 +5048,7 @@ static uint32_t spirv_compiler_emit_builtin_variable_v(struct spirv_compiler *co
     unsigned int sizes[2];
     uint32_t id;
 
-    assert(size_count <= ARRAY_SIZE(sizes));
+    VKD3D_ASSERT(size_count <= ARRAY_SIZE(sizes));
     memcpy(sizes, array_sizes, size_count * sizeof(sizes[0]));
     array_sizes = sizes;
     sizes[0] = max(sizes[0], builtin->spirv_array_size);
@@ -5210,7 +5210,7 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
             use_private_var ? VKD3D_SHADER_COMPONENT_FLOAT : component_type,
             use_private_var ? VKD3DSP_WRITEMASK_ALL : reg_write_mask);
     reg_symbol.info.reg.is_aggregate = array_sizes[0] || array_sizes[1];
-    assert(!builtin || !builtin->spirv_array_size || use_private_var || array_sizes[0] || array_sizes[1]);
+    VKD3D_ASSERT(!builtin || !builtin->spirv_array_size || use_private_var || array_sizes[0] || array_sizes[1]);
     spirv_compiler_put_symbol(compiler, &reg_symbol);
 
     vkd3d_spirv_build_op_name(builder, var_id, reg_type == VKD3DSPR_PATCHCONST ? "vpc%u" : "v%u", element_idx);
@@ -5256,8 +5256,8 @@ static void spirv_compiler_emit_input_register(struct spirv_compiler *compiler,
     uint32_t write_mask;
     uint32_t input_id;
 
-    assert(!reg->idx_count || !reg->idx[0].rel_addr);
-    assert(reg->idx_count < 2);
+    VKD3D_ASSERT(!reg->idx_count || !reg->idx[0].rel_addr);
+    VKD3D_ASSERT(reg->idx_count < 2);
 
     if (!(builtin = get_spirv_builtin_for_register(reg->type)))
     {
@@ -5391,8 +5391,8 @@ static void spirv_compiler_emit_output_register(struct spirv_compiler *compiler,
     uint32_t write_mask;
     uint32_t output_id;
 
-    assert(!reg->idx_count || !reg->idx[0].rel_addr);
-    assert(reg->idx_count < 2);
+    VKD3D_ASSERT(!reg->idx_count || !reg->idx[0].rel_addr);
+    VKD3D_ASSERT(reg->idx_count < 2);
 
     if (!(builtin = get_spirv_builtin_for_register(reg->type)))
     {
@@ -5578,7 +5578,7 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler,
             use_private_variable ? VKD3D_SHADER_COMPONENT_FLOAT : component_type,
             use_private_variable ? VKD3DSP_WRITEMASK_ALL : reg_write_mask);
     reg_symbol.info.reg.is_aggregate = array_sizes[0] || array_sizes[1];
-    assert(!builtin || !builtin->spirv_array_size || use_private_variable || array_sizes[0] || array_sizes[1]);
+    VKD3D_ASSERT(!builtin || !builtin->spirv_array_size || use_private_variable || array_sizes[0] || array_sizes[1]);
 
     spirv_compiler_put_symbol(compiler, &reg_symbol);
 
@@ -5916,7 +5916,7 @@ static void spirv_compiler_emit_temps(struct spirv_compiler *compiler, uint32_t
     function_location = spirv_compiler_get_current_function_location(compiler);
     vkd3d_spirv_begin_function_stream_insertion(builder, function_location);
 
-    assert(!compiler->temp_count);
+    VKD3D_ASSERT(!compiler->temp_count);
     compiler->temp_count = count;
     for (i = 0; i < compiler->temp_count; ++i)
     {
@@ -5924,7 +5924,7 @@ static void spirv_compiler_emit_temps(struct spirv_compiler *compiler, uint32_t
                 SpvStorageClassPrivate, VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_VEC4_SIZE);
         if (!i)
             compiler->temp_id = id;
-        assert(id == compiler->temp_id + i);
+        VKD3D_ASSERT(id == compiler->temp_id + i);
 
         vkd3d_spirv_build_op_name(builder, id, "r%u", i);
     }
@@ -5934,7 +5934,7 @@ static void spirv_compiler_emit_temps(struct spirv_compiler *compiler, uint32_t
 
 static void spirv_compiler_allocate_ssa_register_ids(struct spirv_compiler *compiler, unsigned int count)
 {
-    assert(!compiler->ssa_register_info);
+    VKD3D_ASSERT(!compiler->ssa_register_info);
     if (!(compiler->ssa_register_info = vkd3d_calloc(count, sizeof(*compiler->ssa_register_info))))
     {
         ERR("Failed to allocate SSA register value id array, count %u.\n", count);
@@ -6036,7 +6036,7 @@ static void spirv_compiler_emit_push_constant_buffers(struct spirv_compiler *com
         vkd3d_spirv_build_op_decorate1(builder, member_ids[j], SpvDecorationArrayStride, 4);
         descriptor_offsets_member_idx = j;
         compiler->descriptor_offsets_member_id = spirv_compiler_get_constant_uint(compiler, j);
-        assert(j == count - 1);
+        VKD3D_ASSERT(j == count - 1);
     }
 
     struct_id = vkd3d_spirv_build_op_type_struct(builder, member_ids, count);
@@ -6523,7 +6523,7 @@ static void spirv_compiler_emit_resource_declaration(struct spirv_compiler *comp
 
         if (d->flags & VKD3D_SHADER_DESCRIPTOR_INFO_FLAG_UAV_COUNTER)
         {
-            assert(structure_stride); /* counters are valid only for structured buffers */
+            VKD3D_ASSERT(structure_stride); /* counters are valid only for structured buffers */
 
             counter_type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_UINT, 1);
             if (spirv_compiler_is_opengl_target(compiler))
@@ -6866,7 +6866,7 @@ static void spirv_compiler_enter_shader_phase(struct spirv_compiler *compiler,
     uint32_t function_id, void_id, function_type_id;
     struct vkd3d_shader_phase *phase;
 
-    assert(compiler->phase != instruction->opcode);
+    VKD3D_ASSERT(compiler->phase != instruction->opcode);
 
     if (!is_in_default_phase(compiler))
         spirv_compiler_leave_shader_phase(compiler);
@@ -6943,7 +6943,7 @@ static void spirv_compiler_emit_default_control_point_phase(struct spirv_compile
     input_reg.idx[1].offset = 0;
     input_id = spirv_compiler_get_register_id(compiler, &input_reg);
 
-    assert(input_signature->element_count == output_signature->element_count);
+    VKD3D_ASSERT(input_signature->element_count == output_signature->element_count);
     for (i = 0; i < output_signature->element_count; ++i)
     {
         const struct signature_element *output = &output_signature->elements[i];
@@ -6951,8 +6951,8 @@ static void spirv_compiler_emit_default_control_point_phase(struct spirv_compile
         struct vkd3d_shader_register_info output_reg_info;
         struct vkd3d_shader_register output_reg;
 
-        assert(input->mask == output->mask);
-        assert(input->component_type == output->component_type);
+        VKD3D_ASSERT(input->mask == output->mask);
+        VKD3D_ASSERT(input->component_type == output->component_type);
 
         input_reg.idx[1].offset = i;
         input_id = spirv_compiler_get_register_id(compiler, &input_reg);
@@ -7120,7 +7120,7 @@ static void spirv_compiler_emit_bool_cast(struct spirv_compiler *compiler,
     const struct vkd3d_shader_src_param *src = instruction->src;
     uint32_t val_id;
 
-    assert(src->reg.data_type == VKD3D_DATA_BOOL && dst->reg.data_type != VKD3D_DATA_BOOL);
+    VKD3D_ASSERT(src->reg.data_type == VKD3D_DATA_BOOL && dst->reg.data_type != VKD3D_DATA_BOOL);
 
     val_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
     if (dst->reg.data_type == VKD3D_DATA_HALF || dst->reg.data_type == VKD3D_DATA_FLOAT)
@@ -7199,8 +7199,8 @@ static enum vkd3d_result spirv_compiler_emit_alu_instruction(struct spirv_compil
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    assert(instruction->dst_count == 1);
-    assert(instruction->src_count <= SPIRV_MAX_SRC_COUNT);
+    VKD3D_ASSERT(instruction->dst_count == 1);
+    VKD3D_ASSERT(instruction->src_count <= SPIRV_MAX_SRC_COUNT);
 
     type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
 
@@ -7330,8 +7330,8 @@ static void spirv_compiler_emit_ext_glsl_instruction(struct spirv_compiler *comp
 
     instr_set_id = vkd3d_spirv_get_glsl_std450_instr_set(builder);
 
-    assert(instruction->dst_count == 1);
-    assert(instruction->src_count <= SPIRV_MAX_SRC_COUNT);
+    VKD3D_ASSERT(instruction->dst_count == 1);
+    VKD3D_ASSERT(instruction->src_count <= SPIRV_MAX_SRC_COUNT);
 
     type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
 
@@ -7472,7 +7472,7 @@ static void spirv_compiler_emit_swapc(struct spirv_compiler *compiler,
     uint32_t condition_id, src1_id, src2_id, type_id, val_id;
     unsigned int component_count;
 
-    assert(dst[0].write_mask == dst[1].write_mask);
+    VKD3D_ASSERT(dst[0].write_mask == dst[1].write_mask);
 
     condition_id = spirv_compiler_emit_load_src(compiler, &src[0], dst->write_mask);
     src1_id = spirv_compiler_emit_load_src(compiler, &src[1], dst->write_mask);
@@ -7511,7 +7511,7 @@ static void spirv_compiler_emit_dot(struct spirv_compiler *compiler,
     else
         write_mask = VKD3DSP_WRITEMASK_0 | VKD3DSP_WRITEMASK_1;
 
-    assert(instruction->src_count == ARRAY_SIZE(src_ids));
+    VKD3D_ASSERT(instruction->src_count == ARRAY_SIZE(src_ids));
     for (i = 0; i < ARRAY_SIZE(src_ids); ++i)
         src_ids[i] = spirv_compiler_emit_load_src(compiler, &src[i], write_mask);
 
@@ -7703,8 +7703,8 @@ static void spirv_compiler_emit_ftoi(struct spirv_compiler *compiler,
     enum vkd3d_shader_component_type component_type;
     unsigned int component_count;
 
-    assert(instruction->dst_count == 1);
-    assert(instruction->src_count == 1);
+    VKD3D_ASSERT(instruction->dst_count == 1);
+    VKD3D_ASSERT(instruction->src_count == 1);
 
     /* OpConvertFToI has undefined results if the result cannot be represented
      * as a signed integer, but Direct3D expects the result to saturate,
@@ -7756,8 +7756,8 @@ static void spirv_compiler_emit_ftou(struct spirv_compiler *compiler,
     uint32_t src_type_id, dst_type_id, condition_type_id;
     unsigned int component_count;
 
-    assert(instruction->dst_count == 1);
-    assert(instruction->src_count == 1);
+    VKD3D_ASSERT(instruction->dst_count == 1);
+    VKD3D_ASSERT(instruction->src_count == 1);
 
     /* OpConvertFToU has undefined results if the result cannot be represented
      * as an unsigned integer, but Direct3D expects the result to saturate,
@@ -7805,7 +7805,7 @@ static void spirv_compiler_emit_bitfield_instruction(struct spirv_compiler *comp
     SpvOp op;
 
     src_count = instruction->src_count;
-    assert(2 <= src_count && src_count <= ARRAY_SIZE(src_ids));
+    VKD3D_ASSERT(2 <= src_count && src_count <= ARRAY_SIZE(src_ids));
 
     component_type = vkd3d_component_type_from_data_type(dst->reg.data_type);
     type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
@@ -7823,7 +7823,7 @@ static void spirv_compiler_emit_bitfield_instruction(struct spirv_compiler *comp
             return;
     }
 
-    assert(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
+    VKD3D_ASSERT(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
     for (i = 0, k = 0; i < VKD3D_VEC4_SIZE; ++i)
     {
         if (!(write_mask = dst->write_mask & (VKD3DSP_WRITEMASK_0 << i)))
@@ -7867,7 +7867,7 @@ static void spirv_compiler_emit_f16tof32(struct spirv_compiler *compiler,
     scalar_type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, 1);
 
     /* FIXME: Consider a single UnpackHalf2x16 instruction per 2 components. */
-    assert(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
+    VKD3D_ASSERT(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
     for (i = 0, j = 0; i < VKD3D_VEC4_SIZE; ++i)
     {
         if (!(write_mask = dst->write_mask & (VKD3DSP_WRITEMASK_0 << i)))
@@ -7901,7 +7901,7 @@ static void spirv_compiler_emit_f32tof16(struct spirv_compiler *compiler,
     zero_id = spirv_compiler_get_constant_float(compiler, 0.0f);
 
     /* FIXME: Consider a single PackHalf2x16 instruction per 2 components. */
-    assert(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
+    VKD3D_ASSERT(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
     for (i = 0, j = 0; i < VKD3D_VEC4_SIZE; ++i)
     {
         if (!(write_mask = dst->write_mask & (VKD3DSP_WRITEMASK_0 << i)))
@@ -8331,8 +8331,8 @@ static void spirv_compiler_emit_deriv_instruction(struct spirv_compiler *compile
     if (info->needs_derivative_control)
         vkd3d_spirv_enable_capability(builder, SpvCapabilityDerivativeControl);
 
-    assert(instruction->dst_count == 1);
-    assert(instruction->src_count == 1);
+    VKD3D_ASSERT(instruction->dst_count == 1);
+    VKD3D_ASSERT(instruction->src_count == 1);
 
     type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
     src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
@@ -8366,7 +8366,7 @@ static const struct vkd3d_symbol *spirv_compiler_find_resource(struct spirv_comp
 
     vkd3d_symbol_make_resource(&resource_key, resource_reg);
     entry = rb_get(&compiler->symbol_table, &resource_key);
-    assert(entry);
+    VKD3D_ASSERT(entry);
     return RB_ENTRY_VALUE(entry, struct vkd3d_symbol, entry);
 }
 
@@ -8475,8 +8475,8 @@ static void spirv_compiler_prepare_image(struct spirv_compiler *compiler,
     {
         struct vkd3d_shader_register_info register_info;
 
-        assert(image->image_id);
-        assert(sampler_reg);
+        VKD3D_ASSERT(image->image_id);
+        VKD3D_ASSERT(sampler_reg);
 
         if (!spirv_compiler_get_register_info(compiler, sampler_reg, &register_info))
             ERR("Failed to get sampler register info.\n");
@@ -8559,7 +8559,7 @@ static void spirv_compiler_emit_ld(struct spirv_compiler *compiler,
         image_operands[image_operand_count++] = spirv_compiler_emit_load_src(compiler,
                 &src[2], VKD3DSP_WRITEMASK_0);
     }
-    assert(image_operand_count <= ARRAY_SIZE(image_operands));
+    VKD3D_ASSERT(image_operand_count <= ARRAY_SIZE(image_operands));
     val_id = vkd3d_spirv_build_op_image_fetch(builder, type_id,
             image.image_id, coordinate_id, operands_mask, image_operands, image_operand_count);
 
@@ -8653,7 +8653,7 @@ static void spirv_compiler_emit_sample(struct spirv_compiler *compiler,
 
     sampled_type_id = vkd3d_spirv_get_type_id(builder, image.sampled_type, VKD3D_VEC4_SIZE);
     coordinate_id = spirv_compiler_emit_load_src(compiler, &src[0], VKD3DSP_WRITEMASK_ALL);
-    assert(image_operand_count <= ARRAY_SIZE(image_operands));
+    VKD3D_ASSERT(image_operand_count <= ARRAY_SIZE(image_operands));
     val_id = vkd3d_spirv_build_op_image_sample(builder, op, sampled_type_id,
             image.sampled_image_id, coordinate_id, operands_mask, image_operands, image_operand_count);
 
@@ -8838,7 +8838,7 @@ static void spirv_compiler_emit_ld_raw_structured_srv_uav(struct spirv_compiler
                 type_id, resource_symbol->info.resource.structure_stride,
                 &src[0], VKD3DSP_WRITEMASK_0, &src[1], VKD3DSP_WRITEMASK_0);
 
-        assert(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
+        VKD3D_ASSERT(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
         for (i = 0, j = 0; i < VKD3D_VEC4_SIZE; ++i)
         {
             if (!(dst->write_mask & (VKD3DSP_WRITEMASK_0 << i)))
@@ -8870,7 +8870,7 @@ static void spirv_compiler_emit_ld_raw_structured_srv_uav(struct spirv_compiler
                 type_id, image.structure_stride, &src[0], VKD3DSP_WRITEMASK_0, &src[1], VKD3DSP_WRITEMASK_0);
 
         texel_type_id = vkd3d_spirv_get_type_id(builder, image.sampled_type, VKD3D_VEC4_SIZE);
-        assert(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
+        VKD3D_ASSERT(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
         for (i = 0, j = 0; i < VKD3D_VEC4_SIZE; ++i)
         {
             if (!(dst->write_mask & (VKD3DSP_WRITEMASK_0 << i)))
@@ -8913,7 +8913,7 @@ static void spirv_compiler_emit_ld_tgsm(struct spirv_compiler *compiler,
     base_coordinate_id = spirv_compiler_emit_raw_structured_addressing(compiler,
             type_id, reg_info.structure_stride, &src[0], VKD3DSP_WRITEMASK_0, &src[1], VKD3DSP_WRITEMASK_0);
 
-    assert(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
+    VKD3D_ASSERT(dst->write_mask & VKD3DSP_WRITEMASK_ALL);
     for (i = 0, j = 0; i < VKD3D_VEC4_SIZE; ++i)
     {
         if (!(dst->write_mask & (VKD3DSP_WRITEMASK_0 << i)))
@@ -8976,7 +8976,7 @@ static void spirv_compiler_emit_store_uav_raw_structured(struct spirv_compiler *
                 &src[0], VKD3DSP_WRITEMASK_0, &src[1], VKD3DSP_WRITEMASK_0);
 
         data = &src[instruction->src_count - 1];
-        assert(data->reg.data_type == VKD3D_DATA_UINT);
+        VKD3D_ASSERT(data->reg.data_type == VKD3D_DATA_UINT);
         val_id = spirv_compiler_emit_load_src(compiler, data, dst->write_mask);
 
         component_count = vsir_write_mask_component_count(dst->write_mask);
@@ -9004,7 +9004,7 @@ static void spirv_compiler_emit_store_uav_raw_structured(struct spirv_compiler *
                 type_id, image.structure_stride, &src[0], VKD3DSP_WRITEMASK_0, &src[1], VKD3DSP_WRITEMASK_0);
 
         data = &src[instruction->src_count - 1];
-        assert(data->reg.data_type == VKD3D_DATA_UINT);
+        VKD3D_ASSERT(data->reg.data_type == VKD3D_DATA_UINT);
         val_id = spirv_compiler_emit_load_src(compiler, data, dst->write_mask);
 
         component_count = vsir_write_mask_component_count(dst->write_mask);
@@ -9185,7 +9185,7 @@ static void spirv_compiler_emit_uav_counter_instruction(struct spirv_compiler *c
 
     resource_symbol = spirv_compiler_find_resource(compiler, &src->reg);
     counter_id = resource_symbol->info.resource.uav_counter_id;
-    assert(counter_id);
+    VKD3D_ASSERT(counter_id);
 
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_UINT, 1);
 
@@ -9350,14 +9350,14 @@ static void spirv_compiler_emit_atomic_instruction(struct spirv_compiler *compil
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_UINT, 1);
     if (structure_stride || raw)
     {
-        assert(!raw != !structure_stride);
+        VKD3D_ASSERT(!raw != !structure_stride);
         coordinate_id = spirv_compiler_emit_raw_structured_addressing(compiler,
                 type_id, structure_stride, &src[0], VKD3DSP_WRITEMASK_0,
                 &src[0], VKD3DSP_WRITEMASK_1);
     }
     else
     {
-        assert(resource->reg.type != VKD3DSPR_GROUPSHAREDMEM);
+        VKD3D_ASSERT(resource->reg.type != VKD3DSPR_GROUPSHAREDMEM);
         coordinate_id = spirv_compiler_emit_load_src(compiler, &src[0], coordinate_mask);
     }
 
@@ -9725,7 +9725,7 @@ static void spirv_compiler_emit_eval_attrib(struct spirv_compiler *compiler,
     }
     else
     {
-        assert(instruction->opcode == VKD3DSIH_EVAL_SAMPLE_INDEX);
+        VKD3D_ASSERT(instruction->opcode == VKD3DSIH_EVAL_SAMPLE_INDEX);
         op = GLSLstd450InterpolateAtSample;
         src_ids[src_count++] = spirv_compiler_emit_load_src(compiler, &src[1], VKD3DSP_WRITEMASK_0);
     }
@@ -10473,7 +10473,6 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_WAVE_READ_LANE_FIRST:
             spirv_compiler_emit_wave_read_lane_first(compiler, instruction);
             break;
-        case VKD3DSIH_DCL:
         case VKD3DSIH_DCL_HS_MAX_TESSFACTOR:
         case VKD3DSIH_DCL_INPUT_CONTROL_POINT_COUNT:
         case VKD3DSIH_DCL_INPUT_SGV:
@@ -10483,7 +10482,6 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DCL_OUTPUT_SIV:
         case VKD3DSIH_DCL_RESOURCE_RAW:
         case VKD3DSIH_DCL_RESOURCE_STRUCTURED:
-        case VKD3DSIH_DCL_SAMPLER:
         case VKD3DSIH_DCL_UAV_RAW:
         case VKD3DSIH_DCL_UAV_STRUCTURED:
         case VKD3DSIH_DCL_UAV_TYPED:
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index 3a9a402e8e2..d6d5bbc1c07 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -1716,7 +1716,7 @@ static enum vkd3d_sm4_swizzle_type vkd3d_sm4_get_default_swizzle_type(
     const struct vkd3d_sm4_register_type_info *register_type_info =
             get_info_from_vkd3d_register_type(lookup, vkd3d_type);
 
-    assert(register_type_info);
+    VKD3D_ASSERT(register_type_info);
     return register_type_info->default_src_swizzle_type;
 }
 
@@ -2887,7 +2887,7 @@ static void write_sm4_signature(struct hlsl_ctx *ctx, struct dxbc_writer *dxbc,
             continue;
 
         ret = hlsl_sm4_usage_from_semantic(ctx, &var->semantic, output, &usage);
-        assert(ret);
+        VKD3D_ASSERT(ret);
         if (usage == ~0u)
             continue;
         usage_idx = var->semantic.index;
@@ -2898,7 +2898,7 @@ static void write_sm4_signature(struct hlsl_ctx *ctx, struct dxbc_writer *dxbc,
         }
         else
         {
-            assert(var->regs[HLSL_REGSET_NUMERIC].allocated);
+            VKD3D_ASSERT(var->regs[HLSL_REGSET_NUMERIC].allocated);
             reg_idx = var->regs[HLSL_REGSET_NUMERIC].id;
         }
 
@@ -2975,7 +2975,7 @@ static D3D_SHADER_VARIABLE_CLASS sm4_class(const struct hlsl_type *type)
     switch (type->class)
     {
         case HLSL_CLASS_MATRIX:
-            assert(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
+            VKD3D_ASSERT(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
             if (type->modifiers & HLSL_MODIFIER_COLUMN_MAJOR)
                 return D3D_SVC_MATRIX_COLUMNS;
             else
@@ -3002,6 +3002,10 @@ static D3D_SHADER_VARIABLE_CLASS sm4_class(const struct hlsl_type *type)
         case HLSL_CLASS_VERTEX_SHADER:
         case HLSL_CLASS_VOID:
         case HLSL_CLASS_CONSTANT_BUFFER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
             break;
     }
     vkd3d_unreachable();
@@ -3082,7 +3086,7 @@ static void write_sm4_type(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *b
     }
     else
     {
-        assert(array_type->class <= HLSL_CLASS_LAST_NUMERIC);
+        VKD3D_ASSERT(array_type->class <= HLSL_CLASS_LAST_NUMERIC);
         type->bytecode_offset = put_u32(buffer, vkd3d_make_u32(sm4_class(array_type), sm4_base_type(array_type)));
         put_u32(buffer, vkd3d_make_u32(array_type->dimy, array_type->dimx));
         put_u32(buffer, vkd3d_make_u32(array_size, 0));
@@ -3665,9 +3669,9 @@ static uint32_t sm4_encode_instruction_modifier(const struct sm4_instruction_mod
     switch (imod->type)
     {
         case VKD3D_SM4_MODIFIER_AOFFIMMI:
-            assert(-8 <= imod->u.aoffimmi.u && imod->u.aoffimmi.u <= 7);
-            assert(-8 <= imod->u.aoffimmi.v && imod->u.aoffimmi.v <= 7);
-            assert(-8 <= imod->u.aoffimmi.w && imod->u.aoffimmi.w <= 7);
+            VKD3D_ASSERT(-8 <= imod->u.aoffimmi.u && imod->u.aoffimmi.u <= 7);
+            VKD3D_ASSERT(-8 <= imod->u.aoffimmi.v && imod->u.aoffimmi.v <= 7);
+            VKD3D_ASSERT(-8 <= imod->u.aoffimmi.w && imod->u.aoffimmi.w <= 7);
             word |= ((uint32_t)imod->u.aoffimmi.u & 0xf) << VKD3D_SM4_AOFFIMMI_U_SHIFT;
             word |= ((uint32_t)imod->u.aoffimmi.v & 0xf) << VKD3D_SM4_AOFFIMMI_V_SHIFT;
             word |= ((uint32_t)imod->u.aoffimmi.w & 0xf) << VKD3D_SM4_AOFFIMMI_W_SHIFT;
@@ -3706,7 +3710,7 @@ struct sm4_instruction
 static void sm4_register_from_node(struct vkd3d_shader_register *reg, uint32_t *writemask,
         const struct hlsl_ir_node *instr)
 {
-    assert(instr->reg.allocated);
+    VKD3D_ASSERT(instr->reg.allocated);
     reg->type = VKD3DSPR_TEMP;
     reg->dimension = VSIR_DIMENSION_VEC4;
     reg->idx[0].offset = instr->reg.id;
@@ -3725,7 +3729,7 @@ static void sm4_numeric_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_s
     reg->idx[0].offset = var->regs[HLSL_REGSET_NUMERIC].id;
     reg->dimension = VSIR_DIMENSION_VEC4;
 
-    assert(var->regs[HLSL_REGSET_NUMERIC].allocated);
+    VKD3D_ASSERT(var->regs[HLSL_REGSET_NUMERIC].allocated);
 
     if (!var->indexable)
     {
@@ -3744,13 +3748,13 @@ static void sm4_numeric_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_s
             struct vkd3d_shader_src_param *idx_src;
             unsigned int idx_writemask;
 
-            assert(sm4_instr->idx_src_count < ARRAY_SIZE(sm4_instr->idx_srcs));
+            VKD3D_ASSERT(sm4_instr->idx_src_count < ARRAY_SIZE(sm4_instr->idx_srcs));
             idx_src = &sm4_instr->idx_srcs[sm4_instr->idx_src_count++];
             memset(idx_src, 0, sizeof(*idx_src));
 
             reg->idx[1].rel_addr = idx_src;
             sm4_register_from_node(&idx_src->reg, &idx_writemask, deref->rel_offset.node);
-            assert(idx_writemask != 0);
+            VKD3D_ASSERT(idx_writemask != 0);
             idx_src->swizzle = swizzle_from_sm4(hlsl_swizzle_from_writemask(idx_writemask));
         }
     }
@@ -3786,7 +3790,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_shader_re
                 reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
                 reg->idx_count = 1;
             }
-            assert(regset == HLSL_REGSET_TEXTURES);
+            VKD3D_ASSERT(regset == HLSL_REGSET_TEXTURES);
             *writemask = VKD3DSP_WRITEMASK_ALL;
         }
         else if (regset == HLSL_REGSET_UAVS)
@@ -3805,7 +3809,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_shader_re
                 reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
                 reg->idx_count = 1;
             }
-            assert(regset == HLSL_REGSET_UAVS);
+            VKD3D_ASSERT(regset == HLSL_REGSET_UAVS);
             *writemask = VKD3DSP_WRITEMASK_ALL;
         }
         else if (regset == HLSL_REGSET_SAMPLERS)
@@ -3824,14 +3828,14 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_shader_re
                 reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
                 reg->idx_count = 1;
             }
-            assert(regset == HLSL_REGSET_SAMPLERS);
+            VKD3D_ASSERT(regset == HLSL_REGSET_SAMPLERS);
             *writemask = VKD3DSP_WRITEMASK_ALL;
         }
         else
         {
             unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref) + var->buffer_offset;
 
-            assert(data_type->class <= HLSL_CLASS_VECTOR);
+            VKD3D_ASSERT(data_type->class <= HLSL_CLASS_VECTOR);
             reg->type = VKD3DSPR_CONSTBUFFER;
             reg->dimension = VSIR_DIMENSION_VEC4;
             if (hlsl_version_ge(ctx, 5, 1))
@@ -3871,7 +3875,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_shader_re
         {
             struct hlsl_reg hlsl_reg = hlsl_reg_from_deref(ctx, deref);
 
-            assert(hlsl_reg.allocated);
+            VKD3D_ASSERT(hlsl_reg.allocated);
             reg->type = VKD3DSPR_INPUT;
             reg->dimension = VSIR_DIMENSION_VEC4;
             reg->idx[0].offset = hlsl_reg.id;
@@ -3903,7 +3907,7 @@ static void sm4_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_shader_re
         {
             struct hlsl_reg hlsl_reg = hlsl_reg_from_deref(ctx, deref);
 
-            assert(hlsl_reg.allocated);
+            VKD3D_ASSERT(hlsl_reg.allocated);
             reg->type = VKD3DSPR_OUTPUT;
             reg->dimension = VSIR_DIMENSION_VEC4;
             reg->idx[0].offset = hlsl_reg.id;
@@ -4039,7 +4043,7 @@ static uint32_t sm4_encode_register(const struct tpf_writer *tpf, const struct v
         switch (sm4_swizzle_type)
         {
             case VKD3D_SM4_SWIZZLE_NONE:
-                assert(sm4_swizzle || register_is_constant(reg));
+                VKD3D_ASSERT(sm4_swizzle || register_is_constant(reg));
                 token |= (sm4_swizzle << VKD3D_SM4_WRITEMASK_SHIFT) & VKD3D_SM4_WRITEMASK_MASK;
                 break;
 
@@ -4071,16 +4075,16 @@ static void sm4_write_register_index(const struct tpf_writer *tpf, const struct
         const struct vkd3d_shader_src_param *idx_src = reg->idx[j].rel_addr;
         uint32_t idx_src_token;
 
-        assert(idx_src);
-        assert(!idx_src->modifiers);
-        assert(idx_src->reg.type != VKD3DSPR_IMMCONST);
+        VKD3D_ASSERT(idx_src);
+        VKD3D_ASSERT(!idx_src->modifiers);
+        VKD3D_ASSERT(idx_src->reg.type != VKD3DSPR_IMMCONST);
         idx_src_token = sm4_encode_register(tpf, &idx_src->reg, VKD3D_SM4_SWIZZLE_SCALAR, idx_src->swizzle);
 
         put_u32(buffer, idx_src_token);
         for (k = 0; k < idx_src->reg.idx_count; ++k)
         {
             put_u32(buffer, idx_src->reg.idx[k].offset);
-            assert(!idx_src->reg.idx[k].rel_addr);
+            VKD3D_ASSERT(!idx_src->reg.idx[k].rel_addr);
         }
     }
     else
@@ -4280,7 +4284,7 @@ static void write_sm4_dcl_samplers(const struct tpf_writer *tpf, const struct ex
     if (component_type->sampler_dim == HLSL_SAMPLER_DIM_COMPARISON)
         instr.extra_bits |= VKD3D_SM4_SAMPLER_COMPARISON << VKD3D_SM4_SAMPLER_MODE_SHIFT;
 
-    assert(resource->regset == HLSL_REGSET_SAMPLERS);
+    VKD3D_ASSERT(resource->regset == HLSL_REGSET_SAMPLERS);
 
     for (i = 0; i < resource->bind_count; ++i)
     {
@@ -4289,7 +4293,7 @@ static void write_sm4_dcl_samplers(const struct tpf_writer *tpf, const struct ex
 
         if (hlsl_version_ge(tpf->ctx, 5, 1))
         {
-            assert(!i);
+            VKD3D_ASSERT(!i);
             instr.dsts[0].reg.idx[0].offset = resource->id;
             instr.dsts[0].reg.idx[1].offset = resource->index;
             instr.dsts[0].reg.idx[2].offset = resource->index; /* FIXME: array end */
@@ -4315,7 +4319,7 @@ static void write_sm4_dcl_textures(const struct tpf_writer *tpf, const struct ex
     struct sm4_instruction instr;
     unsigned int i;
 
-    assert(resource->regset == regset);
+    VKD3D_ASSERT(resource->regset == regset);
 
     component_type = hlsl_type_get_component_type(tpf->ctx, resource->data_type, 0);
 
@@ -4337,7 +4341,7 @@ static void write_sm4_dcl_textures(const struct tpf_writer *tpf, const struct ex
 
         if (hlsl_version_ge(tpf->ctx, 5, 1))
         {
-            assert(!i);
+            VKD3D_ASSERT(!i);
             instr.dsts[0].reg.idx[0].offset = resource->id;
             instr.dsts[0].reg.idx[1].offset = resource->index;
             instr.dsts[0].reg.idx[2].offset = resource->index; /* FIXME: array end */
@@ -4589,7 +4593,7 @@ static void write_sm4_unary_op_with_two_destinations(const struct tpf_writer *tp
     memset(&instr, 0, sizeof(instr));
     instr.opcode = opcode;
 
-    assert(dst_idx < ARRAY_SIZE(instr.dsts));
+    VKD3D_ASSERT(dst_idx < ARRAY_SIZE(instr.dsts));
     sm4_dst_from_node(&instr.dsts[dst_idx], dst);
     instr.dsts[1 - dst_idx].reg.type = VKD3DSPR_NULL;
     instr.dsts[1 - dst_idx].reg.dimension = VSIR_DIMENSION_NONE;
@@ -4648,7 +4652,7 @@ static void write_sm4_binary_op_with_two_destinations(const struct tpf_writer *t
     memset(&instr, 0, sizeof(instr));
     instr.opcode = opcode;
 
-    assert(dst_idx < ARRAY_SIZE(instr.dsts));
+    VKD3D_ASSERT(dst_idx < ARRAY_SIZE(instr.dsts));
     sm4_dst_from_node(&instr.dsts[dst_idx], dst);
     instr.dsts[1 - dst_idx].reg.type = VKD3DSPR_NULL;
     instr.dsts[1 - dst_idx].reg.dimension = VSIR_DIMENSION_NONE;
@@ -4846,7 +4850,7 @@ static void write_sm4_sampleinfo(const struct tpf_writer *tpf, const struct hlsl
     const struct hlsl_ir_node *dst = &load->node;
     struct sm4_instruction instr;
 
-    assert(dst->data_type->e.numeric.type == HLSL_TYPE_UINT || dst->data_type->e.numeric.type == HLSL_TYPE_FLOAT);
+    VKD3D_ASSERT(dst->data_type->e.numeric.type == HLSL_TYPE_UINT || dst->data_type->e.numeric.type == HLSL_TYPE_FLOAT);
 
     memset(&instr, 0, sizeof(instr));
     instr.opcode = VKD3D_SM4_OP_SAMPLE_INFO;
@@ -4875,7 +4879,7 @@ static void write_sm4_resinfo(const struct tpf_writer *tpf, const struct hlsl_ir
         return;
     }
 
-    assert(dst->data_type->e.numeric.type == HLSL_TYPE_UINT || dst->data_type->e.numeric.type == HLSL_TYPE_FLOAT);
+    VKD3D_ASSERT(dst->data_type->e.numeric.type == HLSL_TYPE_UINT || dst->data_type->e.numeric.type == HLSL_TYPE_FLOAT);
 
     memset(&instr, 0, sizeof(instr));
     instr.opcode = VKD3D_SM4_OP_RESINFO;
@@ -4929,7 +4933,7 @@ static void write_sm4_cast(const struct tpf_writer *tpf, const struct hlsl_ir_ex
     const struct hlsl_type *src_type = arg1->data_type;
 
     /* Narrowing casts were already lowered. */
-    assert(src_type->dimx == dst_type->dimx);
+    VKD3D_ASSERT(src_type->dimx == dst_type->dimx);
 
     switch (dst_type->e.numeric.type)
     {
@@ -5071,7 +5075,7 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
     const struct hlsl_type *dst_type = expr->node.data_type;
     struct vkd3d_string_buffer *dst_type_string;
 
-    assert(expr->node.reg.allocated);
+    VKD3D_ASSERT(expr->node.reg.allocated);
 
     if (!(dst_type_string = hlsl_type_to_string(tpf->ctx, dst_type)))
         return;
@@ -5099,7 +5103,7 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
             break;
 
         case HLSL_OP1_BIT_NOT:
-            assert(type_is_integer(dst_type));
+            VKD3D_ASSERT(type_is_integer(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_NOT, &expr->node, arg1, 0);
             break;
 
@@ -5108,67 +5112,73 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
             break;
 
         case HLSL_OP1_CEIL:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_ROUND_PI, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_COS:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op_with_two_destinations(tpf, VKD3D_SM4_OP_SINCOS, &expr->node, 1, arg1);
             break;
 
         case HLSL_OP1_DSX:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_DERIV_RTX, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_DSX_COARSE:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM5_OP_DERIV_RTX_COARSE, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_DSX_FINE:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM5_OP_DERIV_RTX_FINE, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_DSY:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_DERIV_RTY, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_DSY_COARSE:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM5_OP_DERIV_RTY_COARSE, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_DSY_FINE:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM5_OP_DERIV_RTY_FINE, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_EXP2:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_EXP, &expr->node, arg1, 0);
             break;
 
+        case HLSL_OP1_F16TOF32:
+            VKD3D_ASSERT(type_is_float(dst_type));
+            VKD3D_ASSERT(hlsl_version_ge(tpf->ctx, 5, 0));
+            write_sm4_unary_op(tpf, VKD3D_SM5_OP_F16TOF32, &expr->node, arg1, 0);
+            break;
+
         case HLSL_OP1_FLOOR:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_ROUND_NI, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_FRACT:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_FRC, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_LOG2:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_LOG, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_LOGIC_NOT:
-            assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+            VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_NOT, &expr->node, arg1, 0);
             break;
 
@@ -5204,7 +5214,7 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
                         struct sm4_instruction instr;
                         struct hlsl_constant_value one;
 
-                        assert(type_is_float(dst_type));
+                        VKD3D_ASSERT(type_is_float(dst_type));
 
                         memset(&instr, 0, sizeof(instr));
                         instr.opcode = VKD3D_SM4_OP_DIV;
@@ -5232,34 +5242,34 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
             break;
 
         case HLSL_OP1_ROUND:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_ROUND_NE, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_RSQ:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_RSQ, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_SAT:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_MOV
                     | (VKD3D_SM4_INSTRUCTION_FLAG_SATURATE << VKD3D_SM4_INSTRUCTION_FLAGS_SHIFT),
                     &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_SIN:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op_with_two_destinations(tpf, VKD3D_SM4_OP_SINCOS, &expr->node, 0, arg1);
             break;
 
         case HLSL_OP1_SQRT:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_SQRT, &expr->node, arg1, 0);
             break;
 
         case HLSL_OP1_TRUNC:
-            assert(type_is_float(dst_type));
+            VKD3D_ASSERT(type_is_float(dst_type));
             write_sm4_unary_op(tpf, VKD3D_SM4_OP_ROUND_Z, &expr->node, arg1, 0);
             break;
 
@@ -5281,17 +5291,17 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
             break;
 
         case HLSL_OP2_BIT_AND:
-            assert(type_is_integer(dst_type));
+            VKD3D_ASSERT(type_is_integer(dst_type));
             write_sm4_binary_op(tpf, VKD3D_SM4_OP_AND, &expr->node, arg1, arg2);
             break;
 
         case HLSL_OP2_BIT_OR:
-            assert(type_is_integer(dst_type));
+            VKD3D_ASSERT(type_is_integer(dst_type));
             write_sm4_binary_op(tpf, VKD3D_SM4_OP_OR, &expr->node, arg1, arg2);
             break;
 
         case HLSL_OP2_BIT_XOR:
-            assert(type_is_integer(dst_type));
+            VKD3D_ASSERT(type_is_integer(dst_type));
             write_sm4_binary_op(tpf, VKD3D_SM4_OP_XOR, &expr->node, arg1, arg2);
             break;
 
@@ -5344,7 +5354,7 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
         {
             const struct hlsl_type *src_type = arg1->data_type;
 
-            assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+            VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
 
             switch (src_type->e.numeric.type)
             {
@@ -5370,7 +5380,7 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
         {
             const struct hlsl_type *src_type = arg1->data_type;
 
-            assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+            VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
 
             switch (src_type->e.numeric.type)
             {
@@ -5399,7 +5409,7 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
         {
             const struct hlsl_type *src_type = arg1->data_type;
 
-            assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+            VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
 
             switch (src_type->e.numeric.type)
             {
@@ -5425,18 +5435,18 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
         }
 
         case HLSL_OP2_LOGIC_AND:
-            assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+            VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
             write_sm4_binary_op(tpf, VKD3D_SM4_OP_AND, &expr->node, arg1, arg2);
             break;
 
         case HLSL_OP2_LOGIC_OR:
-            assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+            VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
             write_sm4_binary_op(tpf, VKD3D_SM4_OP_OR, &expr->node, arg1, arg2);
             break;
 
         case HLSL_OP2_LSHIFT:
-            assert(type_is_integer(dst_type));
-            assert(dst_type->e.numeric.type != HLSL_TYPE_BOOL);
+            VKD3D_ASSERT(type_is_integer(dst_type));
+            VKD3D_ASSERT(dst_type->e.numeric.type != HLSL_TYPE_BOOL);
             write_sm4_binary_op(tpf, VKD3D_SM4_OP_ISHL, &expr->node, arg1, arg2);
             break;
 
@@ -5515,7 +5525,7 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
         {
             const struct hlsl_type *src_type = arg1->data_type;
 
-            assert(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
+            VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
 
             switch (src_type->e.numeric.type)
             {
@@ -5538,8 +5548,8 @@ static void write_sm4_expr(const struct tpf_writer *tpf, const struct hlsl_ir_ex
         }
 
         case HLSL_OP2_RSHIFT:
-            assert(type_is_integer(dst_type));
-            assert(dst_type->e.numeric.type != HLSL_TYPE_BOOL);
+            VKD3D_ASSERT(type_is_integer(dst_type));
+            VKD3D_ASSERT(dst_type->e.numeric.type != HLSL_TYPE_BOOL);
             write_sm4_binary_op(tpf, dst_type->e.numeric.type == HLSL_TYPE_INT ? VKD3D_SM4_OP_ISHR : VKD3D_SM4_OP_USHR,
                     &expr->node, arg1, arg2);
             break;
@@ -5563,7 +5573,7 @@ static void write_sm4_if(const struct tpf_writer *tpf, const struct hlsl_ir_if *
         .src_count = 1,
     };
 
-    assert(iff->condition.node->data_type->dimx == 1);
+    VKD3D_ASSERT(iff->condition.node->data_type->dimx == 1);
 
     sm4_src_from_node(tpf, &instr.srcs[0], iff->condition.node, VKD3DSP_WRITEMASK_ALL);
     write_sm4_instruction(tpf, &instr);
@@ -5641,7 +5651,7 @@ static void write_sm4_load(const struct tpf_writer *tpf, const struct hlsl_ir_lo
     sm4_dst_from_node(&instr.dsts[0], &load->node);
     instr.dst_count = 1;
 
-    assert(hlsl_is_numeric_type(type));
+    VKD3D_ASSERT(hlsl_is_numeric_type(type));
     if (type->e.numeric.type == HLSL_TYPE_BOOL && var_is_user_input(tpf->ctx, load->src.var))
     {
         struct hlsl_constant_value value;
@@ -5758,7 +5768,7 @@ static void write_sm4_resource_load(const struct tpf_writer *tpf, const struct h
         case HLSL_RESOURCE_SAMPLE_LOD_BIAS:
         case HLSL_RESOURCE_SAMPLE_GRAD:
             /* Combined sample expressions were lowered. */
-            assert(load->sampler.var);
+            VKD3D_ASSERT(load->sampler.var);
             write_sm4_sample(tpf, load);
             break;
 
@@ -5911,7 +5921,7 @@ static void write_sm4_block(const struct tpf_writer *tpf, const struct hlsl_bloc
 
             if (!instr->reg.allocated)
             {
-                assert(instr->type == HLSL_IR_CONSTANT);
+                VKD3D_ASSERT(instr->type == HLSL_IR_CONSTANT);
                 continue;
             }
         }
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index fdbde019111..3c1ffcdbee3 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -62,7 +62,7 @@ void vkd3d_string_buffer_init(struct vkd3d_string_buffer *buffer)
     buffer->buffer_size = 16;
     buffer->content_size = 0;
     buffer->buffer = vkd3d_malloc(buffer->buffer_size);
-    assert(buffer->buffer);
+    VKD3D_ASSERT(buffer->buffer);
     memset(buffer->buffer, 0, buffer->buffer_size);
 }
 
@@ -230,7 +230,7 @@ void vkd3d_string_buffer_release(struct vkd3d_string_buffer_cache *cache, struct
 {
     if (!buffer)
         return;
-    assert(cache->count + 1 <= cache->max_count);
+    VKD3D_ASSERT(cache->count + 1 <= cache->max_count);
     cache->buffers[cache->count++] = buffer;
 }
 
@@ -431,7 +431,7 @@ static void bytecode_set_bytes(struct vkd3d_bytecode_buffer *buffer, size_t offs
     if (buffer->status)
         return;
 
-    assert(vkd3d_bound_range(offset, size, buffer->size));
+    VKD3D_ASSERT(vkd3d_bound_range(offset, size, buffer->size));
     memcpy(buffer->data + offset, value, size);
 }
 
@@ -644,7 +644,7 @@ static bool vkd3d_shader_signature_from_shader_signature(struct vkd3d_shader_sig
     signature->element_count = src->element_count;
     if (!src->elements)
     {
-        assert(!signature->element_count);
+        VKD3D_ASSERT(!signature->element_count);
         signature->elements = NULL;
         return true;
     }
@@ -789,7 +789,7 @@ static struct vkd3d_shader_cf_info *vkd3d_shader_scan_push_cf_info(struct vkd3d_
 
 static void vkd3d_shader_scan_pop_cf_info(struct vkd3d_shader_scan_context *context)
 {
-    assert(context->cf_info_count);
+    VKD3D_ASSERT(context->cf_info_count);
 
     --context->cf_info_count;
 }
@@ -2067,7 +2067,7 @@ bool shader_instruction_array_reserve(struct vkd3d_shader_instruction_array *ins
 bool shader_instruction_array_insert_at(struct vkd3d_shader_instruction_array *instructions,
         unsigned int idx, unsigned int count)
 {
-    assert(idx <= instructions->count);
+    VKD3D_ASSERT(idx <= instructions->count);
 
     if (!shader_instruction_array_reserve(instructions, instructions->count + count))
         return false;
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index 7aff22e3420..13b4dab76d1 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -1311,14 +1311,14 @@ void *shader_param_allocator_get(struct vkd3d_shader_param_allocator *allocator,
 static inline struct vkd3d_shader_src_param *shader_src_param_allocator_get(
         struct vkd3d_shader_param_allocator *allocator, unsigned int count)
 {
-    assert(allocator->stride == sizeof(struct vkd3d_shader_src_param));
+    VKD3D_ASSERT(allocator->stride == sizeof(struct vkd3d_shader_src_param));
     return shader_param_allocator_get(allocator, count);
 }
 
 static inline struct vkd3d_shader_dst_param *shader_dst_param_allocator_get(
         struct vkd3d_shader_param_allocator *allocator, unsigned int count)
 {
-    assert(allocator->stride == sizeof(struct vkd3d_shader_dst_param));
+    VKD3D_ASSERT(allocator->stride == sizeof(struct vkd3d_shader_dst_param));
     return shader_param_allocator_get(allocator, count);
 }
 
@@ -1678,7 +1678,7 @@ static inline unsigned int vsir_write_mask_get_component_idx(uint32_t write_mask
 {
     unsigned int i;
 
-    assert(write_mask);
+    VKD3D_ASSERT(write_mask);
     for (i = 0; i < VKD3D_VEC4_SIZE; ++i)
     {
         if (write_mask & (VKD3DSP_WRITEMASK_0 << i))
@@ -1692,13 +1692,13 @@ static inline unsigned int vsir_write_mask_get_component_idx(uint32_t write_mask
 static inline unsigned int vsir_write_mask_component_count(uint32_t write_mask)
 {
     unsigned int count = vkd3d_popcount(write_mask & VKD3DSP_WRITEMASK_ALL);
-    assert(1 <= count && count <= VKD3D_VEC4_SIZE);
+    VKD3D_ASSERT(1 <= count && count <= VKD3D_VEC4_SIZE);
     return count;
 }
 
 static inline unsigned int vkd3d_write_mask_from_component_count(unsigned int component_count)
 {
-    assert(component_count <= VKD3D_VEC4_SIZE);
+    VKD3D_ASSERT(component_count <= VKD3D_VEC4_SIZE);
     return (VKD3DSP_WRITEMASK_0 << component_count) - 1;
 }
 
diff --git a/libs/vkd3d/libs/vkd3d/cache.c b/libs/vkd3d/libs/vkd3d/cache.c
index a0a29ed30cb..11d87ac1d98 100644
--- a/libs/vkd3d/libs/vkd3d/cache.c
+++ b/libs/vkd3d/libs/vkd3d/cache.c
@@ -69,7 +69,14 @@ static int vkd3d_shader_cache_compare_key(const void *key, const struct rb_entry
 static void vkd3d_shader_cache_add_entry(struct vkd3d_shader_cache *cache,
         struct shader_cache_entry *e)
 {
-    rb_put(&cache->tree, &e->h.hash, &e->entry);
+    const struct shader_cache_key k =
+    {
+        .hash = e->h.hash,
+        .key_size = e->h.key_size,
+        .key = e->payload
+    };
+
+    rb_put(&cache->tree, &k, &e->entry);
 }
 
 int vkd3d_shader_open_cache(struct vkd3d_shader_cache **cache)
diff --git a/libs/vkd3d/libs/vkd3d/command.c b/libs/vkd3d/libs/vkd3d/command.c
index a484da94092..dcc7690876f 100644
--- a/libs/vkd3d/libs/vkd3d/command.c
+++ b/libs/vkd3d/libs/vkd3d/command.c
@@ -93,7 +93,7 @@ VkQueue vkd3d_queue_acquire(struct vkd3d_queue *queue)
 
     vkd3d_mutex_lock(&queue->mutex);
 
-    assert(queue->vk_queue);
+    VKD3D_ASSERT(queue->vk_queue);
     return queue->vk_queue;
 }
 
@@ -423,7 +423,7 @@ static HRESULT vkd3d_fence_worker_stop(struct vkd3d_fence_worker *worker,
 static const struct d3d12_root_parameter *root_signature_get_parameter(
         const struct d3d12_root_signature *root_signature, unsigned int index)
 {
-    assert(index < root_signature->parameter_count);
+    VKD3D_ASSERT(index < root_signature->parameter_count);
     return &root_signature->parameters[index];
 }
 
@@ -431,7 +431,7 @@ static const struct d3d12_root_descriptor_table *root_signature_get_descriptor_t
         const struct d3d12_root_signature *root_signature, unsigned int index)
 {
     const struct d3d12_root_parameter *p = root_signature_get_parameter(root_signature, index);
-    assert(p->parameter_type == D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE);
+    VKD3D_ASSERT(p->parameter_type == D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE);
     return &p->u.descriptor_table;
 }
 
@@ -439,7 +439,7 @@ static const struct d3d12_root_constant *root_signature_get_32bit_constants(
         const struct d3d12_root_signature *root_signature, unsigned int index)
 {
     const struct d3d12_root_parameter *p = root_signature_get_parameter(root_signature, index);
-    assert(p->parameter_type == D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS);
+    VKD3D_ASSERT(p->parameter_type == D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS);
     return &p->u.constant;
 }
 
@@ -447,7 +447,7 @@ static const struct d3d12_root_parameter *root_signature_get_root_descriptor(
         const struct d3d12_root_signature *root_signature, unsigned int index)
 {
     const struct d3d12_root_parameter *p = root_signature_get_parameter(root_signature, index);
-    assert(p->parameter_type == D3D12_ROOT_PARAMETER_TYPE_CBV
+    VKD3D_ASSERT(p->parameter_type == D3D12_ROOT_PARAMETER_TYPE_CBV
         || p->parameter_type == D3D12_ROOT_PARAMETER_TYPE_SRV
         || p->parameter_type == D3D12_ROOT_PARAMETER_TYPE_UAV);
     return p;
@@ -528,7 +528,7 @@ static void d3d12_fence_garbage_collect_vk_semaphores_locked(struct d3d12_fence
 
         if (current->u.binary.vk_fence)
             WARN("Destroying potentially pending semaphore.\n");
-        assert(!current->u.binary.is_acquired);
+        VKD3D_ASSERT(!current->u.binary.is_acquired);
 
         VK_CALL(vkDestroySemaphore(device->vk_device, current->u.binary.vk_semaphore, NULL));
         fence->semaphores[i] = fence->semaphores[--fence->semaphore_count];
@@ -599,7 +599,7 @@ static void d3d12_fence_remove_vk_semaphore(struct d3d12_fence *fence, struct vk
 {
     vkd3d_mutex_lock(&fence->mutex);
 
-    assert(semaphore->u.binary.is_acquired);
+    VKD3D_ASSERT(semaphore->u.binary.is_acquired);
 
     *semaphore = fence->semaphores[--fence->semaphore_count];
 
@@ -610,7 +610,7 @@ static void d3d12_fence_release_vk_semaphore(struct d3d12_fence *fence, struct v
 {
     vkd3d_mutex_lock(&fence->mutex);
 
-    assert(semaphore->u.binary.is_acquired);
+    VKD3D_ASSERT(semaphore->u.binary.is_acquired);
     semaphore->u.binary.is_acquired = false;
 
     vkd3d_mutex_unlock(&fence->mutex);
@@ -1154,7 +1154,7 @@ static struct d3d12_fence *unsafe_impl_from_ID3D12Fence(ID3D12Fence *iface)
 
     if (!(iface1 = (ID3D12Fence1 *)iface))
         return NULL;
-    assert(iface1->lpVtbl == &d3d12_fence_vtbl);
+    VKD3D_ASSERT(iface1->lpVtbl == &d3d12_fence_vtbl);
     return impl_from_ID3D12Fence1(iface1);
 }
 
@@ -1792,7 +1792,7 @@ static struct d3d12_command_allocator *unsafe_impl_from_ID3D12CommandAllocator(I
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == &d3d12_command_allocator_vtbl);
+    VKD3D_ASSERT(iface->lpVtbl == &d3d12_command_allocator_vtbl);
     return impl_from_ID3D12CommandAllocator(iface);
 }
 
@@ -1942,9 +1942,9 @@ static void d3d12_command_signature_decref(struct d3d12_command_signature *signa
 }
 
 /* ID3D12CommandList */
-static inline struct d3d12_command_list *impl_from_ID3D12GraphicsCommandList5(ID3D12GraphicsCommandList5 *iface)
+static inline struct d3d12_command_list *impl_from_ID3D12GraphicsCommandList6(ID3D12GraphicsCommandList6 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d12_command_list, ID3D12GraphicsCommandList5_iface);
+    return CONTAINING_RECORD(iface, struct d3d12_command_list, ID3D12GraphicsCommandList6_iface);
 }
 
 static void d3d12_command_list_invalidate_current_framebuffer(struct d3d12_command_list *list)
@@ -2168,7 +2168,7 @@ static bool vk_barrier_parameters_from_d3d12_resource_state(unsigned int state,
     }
 
     /* Handle read-only states. */
-    assert(!is_write_resource_state(state));
+    VKD3D_ASSERT(!is_write_resource_state(state));
 
     if (state & D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER)
     {
@@ -2242,7 +2242,7 @@ static void d3d12_command_list_transition_resource_to_initial_state(struct d3d12
     VkPipelineStageFlags src_stage_mask, dst_stage_mask;
     VkImageMemoryBarrier barrier;
 
-    assert(d3d12_resource_is_texture(resource));
+    VKD3D_ASSERT(d3d12_resource_is_texture(resource));
 
     barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
     barrier.pNext = NULL;
@@ -2289,12 +2289,13 @@ static void d3d12_command_list_track_resource_usage(struct d3d12_command_list *l
     }
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_QueryInterface(ID3D12GraphicsCommandList5 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_QueryInterface(ID3D12GraphicsCommandList6 *iface,
         REFIID iid, void **object)
 {
     TRACE("iface %p, iid %s, object %p.\n", iface, debugstr_guid(iid), object);
 
-    if (IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList5)
+    if (IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList6)
+            || IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList5)
             || IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList4)
             || IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList3)
             || IsEqualGUID(iid, &IID_ID3D12GraphicsCommandList2)
@@ -2305,7 +2306,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_list_QueryInterface(ID3D12Graphic
             || IsEqualGUID(iid, &IID_ID3D12Object)
             || IsEqualGUID(iid, &IID_IUnknown))
     {
-        ID3D12GraphicsCommandList5_AddRef(iface);
+        ID3D12GraphicsCommandList6_AddRef(iface);
         *object = iface;
         return S_OK;
     }
@@ -2316,9 +2317,9 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_list_QueryInterface(ID3D12Graphic
     return E_NOINTERFACE;
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_command_list_AddRef(ID3D12GraphicsCommandList5 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_command_list_AddRef(ID3D12GraphicsCommandList6 *iface)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     unsigned int refcount = vkd3d_atomic_increment_u32(&list->refcount);
 
     TRACE("%p increasing refcount to %u.\n", list, refcount);
@@ -2331,9 +2332,9 @@ static void vkd3d_pipeline_bindings_cleanup(struct vkd3d_pipeline_bindings *bind
     vkd3d_free(bindings->vk_uav_counter_views);
 }
 
-static ULONG STDMETHODCALLTYPE d3d12_command_list_Release(ID3D12GraphicsCommandList5 *iface)
+static ULONG STDMETHODCALLTYPE d3d12_command_list_Release(ID3D12GraphicsCommandList6 *iface)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     unsigned int refcount = vkd3d_atomic_decrement_u32(&list->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", list, refcount);
@@ -2359,66 +2360,67 @@ static ULONG STDMETHODCALLTYPE d3d12_command_list_Release(ID3D12GraphicsCommandL
     return refcount;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_GetPrivateData(ID3D12GraphicsCommandList5 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_GetPrivateData(ID3D12GraphicsCommandList6 *iface,
         REFGUID guid, UINT *data_size, void *data)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, guid %s, data_size %p, data %p.\n", iface, debugstr_guid(guid), data_size, data);
 
     return vkd3d_get_private_data(&list->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetPrivateData(ID3D12GraphicsCommandList5 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetPrivateData(ID3D12GraphicsCommandList6 *iface,
         REFGUID guid, UINT data_size, const void *data)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, guid %s, data_size %u, data %p.\n", iface, debugstr_guid(guid), data_size, data);
 
     return vkd3d_set_private_data(&list->private_store, guid, data_size, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetPrivateDataInterface(ID3D12GraphicsCommandList5 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetPrivateDataInterface(ID3D12GraphicsCommandList6 *iface,
         REFGUID guid, const IUnknown *data)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, guid %s, data %p.\n", iface, debugstr_guid(guid), data);
 
     return vkd3d_set_private_data_interface(&list->private_store, guid, data);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetName(ID3D12GraphicsCommandList5 *iface, const WCHAR *name)
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_SetName(ID3D12GraphicsCommandList6 *iface, const WCHAR *name)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, name %s.\n", iface, debugstr_w(name, list->device->wchar_size));
 
     return name ? S_OK : E_INVALIDARG;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_GetDevice(ID3D12GraphicsCommandList5 *iface, REFIID iid, void **device)
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_GetDevice(ID3D12GraphicsCommandList6 *iface,
+        REFIID iid, void **device)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, iid %s, device %p.\n", iface, debugstr_guid(iid), device);
 
     return d3d12_device_query_interface(list->device, iid, device);
 }
 
-static D3D12_COMMAND_LIST_TYPE STDMETHODCALLTYPE d3d12_command_list_GetType(ID3D12GraphicsCommandList5 *iface)
+static D3D12_COMMAND_LIST_TYPE STDMETHODCALLTYPE d3d12_command_list_GetType(ID3D12GraphicsCommandList6 *iface)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p.\n", iface);
 
     return list->type;
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_Close(ID3D12GraphicsCommandList5 *iface)
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_Close(ID3D12GraphicsCommandList6 *iface)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     VkResult vr;
 
@@ -2462,7 +2464,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_list_Close(ID3D12GraphicsCommandL
 static void d3d12_command_list_reset_state(struct d3d12_command_list *list,
         ID3D12PipelineState *initial_pipeline_state)
 {
-    ID3D12GraphicsCommandList5 *iface = &list->ID3D12GraphicsCommandList5_iface;
+    ID3D12GraphicsCommandList6 *iface = &list->ID3D12GraphicsCommandList6_iface;
 
     memset(list->strides, 0, sizeof(list->strides));
     list->primitive_topology = D3D_PRIMITIVE_TOPOLOGY_POINTLIST;
@@ -2498,14 +2500,14 @@ static void d3d12_command_list_reset_state(struct d3d12_command_list *list,
 
     list->descriptor_heap_count = 0;
 
-    ID3D12GraphicsCommandList5_SetPipelineState(iface, initial_pipeline_state);
+    ID3D12GraphicsCommandList6_SetPipelineState(iface, initial_pipeline_state);
 }
 
-static HRESULT STDMETHODCALLTYPE d3d12_command_list_Reset(ID3D12GraphicsCommandList5 *iface,
+static HRESULT STDMETHODCALLTYPE d3d12_command_list_Reset(ID3D12GraphicsCommandList6 *iface,
         ID3D12CommandAllocator *allocator, ID3D12PipelineState *initial_pipeline_state)
 {
     struct d3d12_command_allocator *allocator_impl = unsafe_impl_from_ID3D12CommandAllocator(allocator);
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     HRESULT hr;
 
     TRACE("iface %p, allocator %p, initial_pipeline_state %p.\n",
@@ -2532,7 +2534,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_list_Reset(ID3D12GraphicsCommandL
     return hr;
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearState(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearState(ID3D12GraphicsCommandList6 *iface,
         ID3D12PipelineState *pipeline_state)
 {
     FIXME("iface %p, pipeline_state %p stub!\n", iface, pipeline_state);
@@ -2542,7 +2544,7 @@ static bool d3d12_command_list_has_depth_stencil_view(struct d3d12_command_list
 {
     struct d3d12_graphics_pipeline_state *graphics;
 
-    assert(d3d12_pipeline_state_is_graphics(list->state));
+    VKD3D_ASSERT(d3d12_pipeline_state_is_graphics(list->state));
     graphics = &list->state->u.graphics;
 
     return graphics->dsv_format || (d3d12_pipeline_state_has_unknown_dsv_format(list->state) && list->dsv_format);
@@ -3051,7 +3053,7 @@ static void d3d12_command_list_update_uav_counter_descriptors(struct d3d12_comma
         const struct vkd3d_shader_uav_counter_binding *uav_counter = &state->uav_counters.bindings[i];
         const VkBufferView *vk_uav_counter_views = bindings->vk_uav_counter_views;
 
-        assert(vk_uav_counter_views[i]);
+        VKD3D_ASSERT(vk_uav_counter_views[i]);
 
         vk_descriptor_writes[i].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
         vk_descriptor_writes[i].pNext = NULL;
@@ -3324,7 +3326,7 @@ static bool d3d12_command_list_begin_render_pass(struct d3d12_command_list *list
         return true;
 
     vk_render_pass = list->pso_render_pass;
-    assert(vk_render_pass);
+    VKD3D_ASSERT(vk_render_pass);
 
     begin_desc.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
     begin_desc.pNext = NULL;
@@ -3380,11 +3382,11 @@ static void d3d12_command_list_check_index_buffer_strip_cut_value(struct d3d12_c
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_DrawInstanced(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_DrawInstanced(ID3D12GraphicsCommandList6 *iface,
         UINT vertex_count_per_instance, UINT instance_count, UINT start_vertex_location,
         UINT start_instance_location)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, vertex_count_per_instance %u, instance_count %u, "
@@ -3404,11 +3406,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_DrawInstanced(ID3D12GraphicsCom
             instance_count, start_vertex_location, start_instance_location));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_DrawIndexedInstanced(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_DrawIndexedInstanced(ID3D12GraphicsCommandList6 *iface,
         UINT index_count_per_instance, UINT instance_count, UINT start_vertex_location,
         INT base_vertex_location, UINT start_instance_location)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, index_count_per_instance %u, instance_count %u, start_vertex_location %u, "
@@ -3430,10 +3432,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_DrawIndexedInstanced(ID3D12Grap
             instance_count, start_vertex_location, base_vertex_location, start_instance_location));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_Dispatch(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_Dispatch(ID3D12GraphicsCommandList6 *iface,
         UINT x, UINT y, UINT z)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, x %u, y %u, z %u.\n", iface, x, y, z);
@@ -3449,10 +3451,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_Dispatch(ID3D12GraphicsCommandL
     VK_CALL(vkCmdDispatch(list->vk_command_buffer, x, y, z));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_CopyBufferRegion(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_CopyBufferRegion(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *dst, UINT64 dst_offset, ID3D12Resource *src, UINT64 src_offset, UINT64 byte_count)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct d3d12_resource *dst_resource, *src_resource;
     const struct vkd3d_vk_device_procs *vk_procs;
     VkBufferCopy buffer_copy;
@@ -3464,9 +3466,9 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyBufferRegion(ID3D12Graphics
     vk_procs = &list->device->vk_procs;
 
     dst_resource = unsafe_impl_from_ID3D12Resource(dst);
-    assert(d3d12_resource_is_buffer(dst_resource));
+    VKD3D_ASSERT(d3d12_resource_is_buffer(dst_resource));
     src_resource = unsafe_impl_from_ID3D12Resource(src);
-    assert(d3d12_resource_is_buffer(src_resource));
+    VKD3D_ASSERT(d3d12_resource_is_buffer(src_resource));
 
     d3d12_command_list_track_resource_usage(list, dst_resource);
     d3d12_command_list_track_resource_usage(list, src_resource);
@@ -3667,11 +3669,11 @@ static void d3d12_command_list_copy_incompatible_texture_region(struct d3d12_com
             src_format->dxgi_format, src_format->vk_format,
             dst_format->dxgi_format, dst_format->vk_format);
 
-    assert(d3d12_resource_is_texture(dst_resource));
-    assert(d3d12_resource_is_texture(src_resource));
-    assert(!vkd3d_format_is_compressed(dst_format));
-    assert(!vkd3d_format_is_compressed(src_format));
-    assert(dst_format->byte_count == src_format->byte_count);
+    VKD3D_ASSERT(d3d12_resource_is_texture(dst_resource));
+    VKD3D_ASSERT(d3d12_resource_is_texture(src_resource));
+    VKD3D_ASSERT(!vkd3d_format_is_compressed(dst_format));
+    VKD3D_ASSERT(!vkd3d_format_is_compressed(src_format));
+    VKD3D_ASSERT(dst_format->byte_count == src_format->byte_count);
 
     buffer_image_copy.bufferOffset = 0;
     buffer_image_copy.bufferRowLength = 0;
@@ -3715,11 +3717,11 @@ static void d3d12_command_list_copy_incompatible_texture_region(struct d3d12_com
     buffer_image_copy.imageSubresource.layerCount = layer_count;
     dst_miplevel_idx = buffer_image_copy.imageSubresource.mipLevel;
 
-    assert(d3d12_resource_desc_get_width(src_desc, src_miplevel_idx) ==
+    VKD3D_ASSERT(d3d12_resource_desc_get_width(src_desc, src_miplevel_idx) ==
             d3d12_resource_desc_get_width(dst_desc, dst_miplevel_idx));
-    assert(d3d12_resource_desc_get_height(src_desc, src_miplevel_idx) ==
+    VKD3D_ASSERT(d3d12_resource_desc_get_height(src_desc, src_miplevel_idx) ==
             d3d12_resource_desc_get_height(dst_desc, dst_miplevel_idx));
-    assert(d3d12_resource_desc_get_depth(src_desc, src_miplevel_idx) ==
+    VKD3D_ASSERT(d3d12_resource_desc_get_depth(src_desc, src_miplevel_idx) ==
             d3d12_resource_desc_get_depth(dst_desc, dst_miplevel_idx));
 
     VK_CALL(vkCmdCopyBufferToImage(list->vk_command_buffer,
@@ -3734,11 +3736,11 @@ static bool validate_d3d12_box(const D3D12_BOX *box)
             && box->back > box->front;
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_CopyTextureRegion(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_CopyTextureRegion(ID3D12GraphicsCommandList6 *iface,
         const D3D12_TEXTURE_COPY_LOCATION *dst, UINT dst_x, UINT dst_y, UINT dst_z,
         const D3D12_TEXTURE_COPY_LOCATION *src, const D3D12_BOX *src_box)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct d3d12_resource *dst_resource, *src_resource;
     const struct vkd3d_format *src_format, *dst_format;
     const struct vkd3d_vk_device_procs *vk_procs;
@@ -3767,8 +3769,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyTextureRegion(ID3D12Graphic
     if (src->Type == D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX
             && dst->Type == D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT)
     {
-        assert(d3d12_resource_is_buffer(dst_resource));
-        assert(d3d12_resource_is_texture(src_resource));
+        VKD3D_ASSERT(d3d12_resource_is_buffer(dst_resource));
+        VKD3D_ASSERT(d3d12_resource_is_texture(src_resource));
 
         if (!(dst_format = vkd3d_format_from_d3d12_resource_desc(list->device,
                 &src_resource->desc, dst->u.PlacedFootprint.Footprint.Format)))
@@ -3796,8 +3798,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyTextureRegion(ID3D12Graphic
     else if (src->Type == D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT
             && dst->Type == D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX)
     {
-        assert(d3d12_resource_is_texture(dst_resource));
-        assert(d3d12_resource_is_buffer(src_resource));
+        VKD3D_ASSERT(d3d12_resource_is_texture(dst_resource));
+        VKD3D_ASSERT(d3d12_resource_is_buffer(src_resource));
 
         if (!(src_format = vkd3d_format_from_d3d12_resource_desc(list->device,
                 &dst_resource->desc, src->u.PlacedFootprint.Footprint.Format)))
@@ -3825,8 +3827,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyTextureRegion(ID3D12Graphic
     else if (src->Type == D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX
             && dst->Type == D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX)
     {
-        assert(d3d12_resource_is_texture(dst_resource));
-        assert(d3d12_resource_is_texture(src_resource));
+        VKD3D_ASSERT(d3d12_resource_is_texture(dst_resource));
+        VKD3D_ASSERT(d3d12_resource_is_texture(src_resource));
 
         dst_format = dst_resource->format;
         src_format = src_resource->format;
@@ -3859,10 +3861,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyTextureRegion(ID3D12Graphic
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_CopyResource(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_CopyResource(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *dst, ID3D12Resource *src)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct d3d12_resource *dst_resource, *src_resource;
     const struct vkd3d_format *dst_format, *src_format;
     const struct vkd3d_vk_device_procs *vk_procs;
@@ -3885,8 +3887,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyResource(ID3D12GraphicsComm
 
     if (d3d12_resource_is_buffer(dst_resource))
     {
-        assert(d3d12_resource_is_buffer(src_resource));
-        assert(src_resource->desc.Width == dst_resource->desc.Width);
+        VKD3D_ASSERT(d3d12_resource_is_buffer(src_resource));
+        VKD3D_ASSERT(src_resource->desc.Width == dst_resource->desc.Width);
 
         vk_buffer_copy.srcOffset = 0;
         vk_buffer_copy.dstOffset = 0;
@@ -3900,10 +3902,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyResource(ID3D12GraphicsComm
         dst_format = dst_resource->format;
         src_format = src_resource->format;
 
-        assert(d3d12_resource_is_texture(dst_resource));
-        assert(d3d12_resource_is_texture(src_resource));
-        assert(dst_resource->desc.MipLevels == src_resource->desc.MipLevels);
-        assert(layer_count == d3d12_resource_desc_get_layer_count(&src_resource->desc));
+        VKD3D_ASSERT(d3d12_resource_is_texture(dst_resource));
+        VKD3D_ASSERT(d3d12_resource_is_texture(src_resource));
+        VKD3D_ASSERT(dst_resource->desc.MipLevels == src_resource->desc.MipLevels);
+        VKD3D_ASSERT(layer_count == d3d12_resource_desc_get_layer_count(&src_resource->desc));
 
         if (src_format->vk_aspect_mask != dst_format->vk_aspect_mask)
         {
@@ -3929,7 +3931,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyResource(ID3D12GraphicsComm
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_CopyTiles(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_CopyTiles(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *tiled_resource, const D3D12_TILED_RESOURCE_COORDINATE *tile_region_start_coordinate,
         const D3D12_TILE_REGION_SIZE *tile_region_size, ID3D12Resource *buffer, UINT64 buffer_offset,
         D3D12_TILE_COPY_FLAGS flags)
@@ -3940,11 +3942,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_CopyTiles(ID3D12GraphicsCommand
             buffer, buffer_offset, flags);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresource(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresource(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *dst, UINT dst_sub_resource_idx,
         ID3D12Resource *src, UINT src_sub_resource_idx, DXGI_FORMAT format)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_format *src_format, *dst_format, *vk_format;
     struct d3d12_resource *dst_resource, *src_resource;
     const struct vkd3d_vk_device_procs *vk_procs;
@@ -3960,8 +3962,8 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresource(ID3D12Graphi
     dst_resource = unsafe_impl_from_ID3D12Resource(dst);
     src_resource = unsafe_impl_from_ID3D12Resource(src);
 
-    assert(d3d12_resource_is_texture(dst_resource));
-    assert(d3d12_resource_is_texture(src_resource));
+    VKD3D_ASSERT(d3d12_resource_is_texture(dst_resource));
+    VKD3D_ASSERT(d3d12_resource_is_texture(src_resource));
 
     d3d12_command_list_track_resource_usage(list, dst_resource);
     d3d12_command_list_track_resource_usage(list, src_resource);
@@ -4007,10 +4009,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresource(ID3D12Graphi
             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &vk_image_resolve));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_IASetPrimitiveTopology(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_IASetPrimitiveTopology(ID3D12GraphicsCommandList6 *iface,
         D3D12_PRIMITIVE_TOPOLOGY topology)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, topology %#x.\n", iface, topology);
 
@@ -4021,11 +4023,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_IASetPrimitiveTopology(ID3D12Gr
     d3d12_command_list_invalidate_current_pipeline(list);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_RSSetViewports(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_RSSetViewports(ID3D12GraphicsCommandList6 *iface,
         UINT viewport_count, const D3D12_VIEWPORT *viewports)
 {
     VkViewport vk_viewports[D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE];
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     unsigned int i;
 
@@ -4059,10 +4061,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_RSSetViewports(ID3D12GraphicsCo
     VK_CALL(vkCmdSetViewport(list->vk_command_buffer, 0, viewport_count, vk_viewports));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_RSSetScissorRects(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_RSSetScissorRects(ID3D12GraphicsCommandList6 *iface,
         UINT rect_count, const D3D12_RECT *rects)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     VkRect2D vk_rects[D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE];
     const struct vkd3d_vk_device_procs *vk_procs;
     unsigned int i;
@@ -4087,10 +4089,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_RSSetScissorRects(ID3D12Graphic
     VK_CALL(vkCmdSetScissor(list->vk_command_buffer, 0, rect_count, vk_rects));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_OMSetBlendFactor(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_OMSetBlendFactor(ID3D12GraphicsCommandList6 *iface,
         const FLOAT blend_factor[4])
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, blend_factor %p.\n", iface, blend_factor);
@@ -4099,10 +4101,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_OMSetBlendFactor(ID3D12Graphics
     VK_CALL(vkCmdSetBlendConstants(list->vk_command_buffer, blend_factor));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_OMSetStencilRef(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_OMSetStencilRef(ID3D12GraphicsCommandList6 *iface,
         UINT stencil_ref)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
 
     TRACE("iface %p, stencil_ref %u.\n", iface, stencil_ref);
@@ -4111,11 +4113,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_OMSetStencilRef(ID3D12GraphicsC
     VK_CALL(vkCmdSetStencilReference(list->vk_command_buffer, VK_STENCIL_FRONT_AND_BACK, stencil_ref));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetPipelineState(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetPipelineState(ID3D12GraphicsCommandList6 *iface,
         ID3D12PipelineState *pipeline_state)
 {
     struct d3d12_pipeline_state *state = unsafe_impl_from_ID3D12PipelineState(pipeline_state);
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, pipeline_state %p.\n", iface, pipeline_state);
 
@@ -4166,10 +4168,10 @@ static unsigned int d3d12_find_ds_multiplanar_transition(const D3D12_RESOURCE_BA
     return 0;
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ResourceBarrier(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ResourceBarrier(ID3D12GraphicsCommandList6 *iface,
         UINT barrier_count, const D3D12_RESOURCE_BARRIER *barriers)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     bool have_aliasing_barriers = false, have_split_barriers = false;
     const struct vkd3d_vk_device_procs *vk_procs;
     const struct vkd3d_vulkan_info *vk_info;
@@ -4395,13 +4397,13 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResourceBarrier(ID3D12GraphicsC
         WARN("Issuing split barrier(s) on D3D12_RESOURCE_BARRIER_FLAG_END_ONLY.\n");
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ExecuteBundle(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ExecuteBundle(ID3D12GraphicsCommandList6 *iface,
         ID3D12GraphicsCommandList *command_list)
 {
     FIXME("iface %p, command_list %p stub!\n", iface, command_list);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetDescriptorHeaps(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetDescriptorHeaps(ID3D12GraphicsCommandList6 *iface,
         UINT heap_count, ID3D12DescriptorHeap *const *heaps)
 {
     TRACE("iface %p, heap_count %u, heaps %p.\n", iface, heap_count, heaps);
@@ -4427,10 +4429,10 @@ static void d3d12_command_list_set_root_signature(struct d3d12_command_list *lis
     d3d12_command_list_invalidate_root_parameters(list, bind_point);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootSignature(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootSignature(ID3D12GraphicsCommandList6 *iface,
         ID3D12RootSignature *root_signature)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_signature %p.\n", iface, root_signature);
 
@@ -4438,10 +4440,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootSignature(ID3D12G
             unsafe_impl_from_ID3D12RootSignature(root_signature));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootSignature(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootSignature(ID3D12GraphicsCommandList6 *iface,
         ID3D12RootSignature *root_signature)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_signature %p.\n", iface, root_signature);
 
@@ -4457,9 +4459,9 @@ static void d3d12_command_list_set_descriptor_table(struct d3d12_command_list *l
     struct d3d12_descriptor_heap *descriptor_heap;
     struct d3d12_desc *desc;
 
-    assert(root_signature_get_descriptor_table(root_signature, index));
+    VKD3D_ASSERT(root_signature_get_descriptor_table(root_signature, index));
 
-    assert(index < ARRAY_SIZE(bindings->descriptor_tables));
+    VKD3D_ASSERT(index < ARRAY_SIZE(bindings->descriptor_tables));
     desc = d3d12_desc_from_gpu_handle(base_descriptor);
 
     if (bindings->descriptor_tables[index] == desc)
@@ -4480,10 +4482,10 @@ static void d3d12_command_list_set_descriptor_table(struct d3d12_command_list *l
     bindings->descriptor_table_active_mask |= (uint64_t)1 << index;
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootDescriptorTable(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootDescriptorTable(ID3D12GraphicsCommandList6 *iface,
         UINT root_parameter_index, D3D12_GPU_DESCRIPTOR_HANDLE base_descriptor)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, base_descriptor %s.\n",
             iface, root_parameter_index, debug_gpu_handle(base_descriptor));
@@ -4492,10 +4494,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootDescriptorTable(I
             root_parameter_index, base_descriptor);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootDescriptorTable(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootDescriptorTable(ID3D12GraphicsCommandList6 *iface,
         UINT root_parameter_index, D3D12_GPU_DESCRIPTOR_HANDLE base_descriptor)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, base_descriptor %s.\n",
             iface, root_parameter_index, debug_gpu_handle(base_descriptor));
@@ -4517,10 +4519,10 @@ static void d3d12_command_list_set_root_constants(struct d3d12_command_list *lis
             c->stage_flags, c->offset + offset * sizeof(uint32_t), count * sizeof(uint32_t), data));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstant(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstant(ID3D12GraphicsCommandList6 *iface,
         UINT root_parameter_index, UINT data, UINT dst_offset)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, data 0x%08x, dst_offset %u.\n",
             iface, root_parameter_index, data, dst_offset);
@@ -4529,10 +4531,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstant(ID3
             root_parameter_index, dst_offset, 1, &data);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstant(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstant(ID3D12GraphicsCommandList6 *iface,
         UINT root_parameter_index, UINT data, UINT dst_offset)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, data 0x%08x, dst_offset %u.\n",
             iface, root_parameter_index, data, dst_offset);
@@ -4541,10 +4543,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstant(ID
             root_parameter_index, dst_offset, 1, &data);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstants(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstants(ID3D12GraphicsCommandList6 *iface,
         UINT root_parameter_index, UINT constant_count, const void *data, UINT dst_offset)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, constant_count %u, data %p, dst_offset %u.\n",
             iface, root_parameter_index, constant_count, data, dst_offset);
@@ -4553,10 +4555,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRoot32BitConstants(ID
             root_parameter_index, dst_offset, constant_count, data);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstants(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRoot32BitConstants(ID3D12GraphicsCommandList6 *iface,
         UINT root_parameter_index, UINT constant_count, const void *data, UINT dst_offset)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, constant_count %u, data %p, dst_offset %u.\n",
             iface, root_parameter_index, constant_count, data, dst_offset);
@@ -4578,7 +4580,7 @@ static void d3d12_command_list_set_root_cbv(struct d3d12_command_list *list,
     struct d3d12_resource *resource;
 
     root_parameter = root_signature_get_root_descriptor(root_signature, index);
-    assert(root_parameter->parameter_type == D3D12_ROOT_PARAMETER_TYPE_CBV);
+    VKD3D_ASSERT(root_parameter->parameter_type == D3D12_ROOT_PARAMETER_TYPE_CBV);
 
     if (gpu_address)
     {
@@ -4609,7 +4611,7 @@ static void d3d12_command_list_set_root_cbv(struct d3d12_command_list *list,
                 root_parameter, bindings->descriptor_sets[0], NULL, &buffer_info);
         VK_CALL(vkUpdateDescriptorSets(list->device->vk_device, 1, &descriptor_write, 0, NULL));
 
-        assert(index < ARRAY_SIZE(bindings->push_descriptors));
+        VKD3D_ASSERT(index < ARRAY_SIZE(bindings->push_descriptors));
         bindings->push_descriptors[index].u.cbv.vk_buffer = buffer_info.buffer;
         bindings->push_descriptors[index].u.cbv.offset = buffer_info.offset;
         bindings->push_descriptor_dirty_mask |= 1u << index;
@@ -4618,9 +4620,9 @@ static void d3d12_command_list_set_root_cbv(struct d3d12_command_list *list,
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootConstantBufferView(
-        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList6 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4629,9 +4631,9 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootConstantBufferVie
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootConstantBufferView(
-        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList6 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4652,7 +4654,7 @@ static void d3d12_command_list_set_root_descriptor(struct d3d12_command_list *li
     VkBufferView vk_buffer_view;
 
     root_parameter = root_signature_get_root_descriptor(root_signature, index);
-    assert(root_parameter->parameter_type != D3D12_ROOT_PARAMETER_TYPE_CBV);
+    VKD3D_ASSERT(root_parameter->parameter_type != D3D12_ROOT_PARAMETER_TYPE_CBV);
 
     /* FIXME: Re-use buffer views. */
     if (!vkd3d_create_raw_buffer_view(list->device, gpu_address, root_parameter->parameter_type, &vk_buffer_view))
@@ -4682,7 +4684,7 @@ static void d3d12_command_list_set_root_descriptor(struct d3d12_command_list *li
                 root_parameter, bindings->descriptor_sets[0], &vk_buffer_view,  NULL);
         VK_CALL(vkUpdateDescriptorSets(list->device->vk_device, 1, &descriptor_write, 0, NULL));
 
-        assert(index < ARRAY_SIZE(bindings->push_descriptors));
+        VKD3D_ASSERT(index < ARRAY_SIZE(bindings->push_descriptors));
         bindings->push_descriptors[index].u.vk_buffer_view = vk_buffer_view;
         bindings->push_descriptor_dirty_mask |= 1u << index;
         bindings->push_descriptor_active_mask |= 1u << index;
@@ -4690,9 +4692,9 @@ static void d3d12_command_list_set_root_descriptor(struct d3d12_command_list *li
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootShaderResourceView(
-        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList6 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4702,9 +4704,9 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootShaderResourceVie
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootShaderResourceView(
-        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList6 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4714,9 +4716,9 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootShaderResourceVi
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootUnorderedAccessView(
-        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList6 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4726,9 +4728,9 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetComputeRootUnorderedAccessVi
 }
 
 static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootUnorderedAccessView(
-        ID3D12GraphicsCommandList5 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
+        ID3D12GraphicsCommandList6 *iface, UINT root_parameter_index, D3D12_GPU_VIRTUAL_ADDRESS address)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
 
     TRACE("iface %p, root_parameter_index %u, address %#"PRIx64".\n",
             iface, root_parameter_index, address);
@@ -4737,10 +4739,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetGraphicsRootUnorderedAccessV
             root_parameter_index, address);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_IASetIndexBuffer(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_IASetIndexBuffer(ID3D12GraphicsCommandList6 *iface,
         const D3D12_INDEX_BUFFER_VIEW *view)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_vk_device_procs *vk_procs;
     struct d3d12_resource *resource;
     enum VkIndexType index_type;
@@ -4780,10 +4782,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_IASetIndexBuffer(ID3D12Graphics
             view->BufferLocation - resource->gpu_address, index_type));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_IASetVertexBuffers(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_IASetVertexBuffers(ID3D12GraphicsCommandList6 *iface,
         UINT start_slot, UINT view_count, const D3D12_VERTEX_BUFFER_VIEW *views)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct vkd3d_null_resources *null_resources;
     struct vkd3d_gpu_va_allocator *gpu_va_allocator;
     VkDeviceSize offsets[ARRAY_SIZE(list->strides)];
@@ -4832,10 +4834,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_IASetVertexBuffers(ID3D12Graphi
         d3d12_command_list_invalidate_current_pipeline(list);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SOSetTargets(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SOSetTargets(ID3D12GraphicsCommandList6 *iface,
         UINT start_slot, UINT view_count, const D3D12_STREAM_OUTPUT_BUFFER_VIEW *views)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     VkDeviceSize offsets[ARRAY_SIZE(list->so_counter_buffers)];
     VkDeviceSize sizes[ARRAY_SIZE(list->so_counter_buffers)];
     VkBuffer buffers[ARRAY_SIZE(list->so_counter_buffers)];
@@ -4897,11 +4899,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_SOSetTargets(ID3D12GraphicsComm
         VK_CALL(vkCmdBindTransformFeedbackBuffersEXT(list->vk_command_buffer, first, count, buffers, offsets, sizes));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_OMSetRenderTargets(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_OMSetRenderTargets(ID3D12GraphicsCommandList6 *iface,
         UINT render_target_descriptor_count, const D3D12_CPU_DESCRIPTOR_HANDLE *render_target_descriptors,
         BOOL single_descriptor_handle, const D3D12_CPU_DESCRIPTOR_HANDLE *depth_stencil_descriptor)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct d3d12_rtv_desc *rtv_desc;
     const struct d3d12_dsv_desc *dsv_desc;
     VkFormat prev_dsv_format;
@@ -5102,12 +5104,12 @@ static void d3d12_command_list_clear(struct d3d12_command_list *list,
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearDepthStencilView(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearDepthStencilView(ID3D12GraphicsCommandList6 *iface,
         D3D12_CPU_DESCRIPTOR_HANDLE dsv, D3D12_CLEAR_FLAGS flags, float depth, UINT8 stencil,
         UINT rect_count, const D3D12_RECT *rects)
 {
     const union VkClearValue clear_value = {.depthStencil = {depth, stencil}};
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct d3d12_dsv_desc *dsv_desc = d3d12_dsv_desc_from_cpu_handle(dsv);
     struct VkAttachmentDescription attachment_desc;
     struct VkAttachmentReference ds_reference;
@@ -5151,10 +5153,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_ClearDepthStencilView(ID3D12Gra
             &clear_value, rect_count, rects);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearRenderTargetView(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearRenderTargetView(ID3D12GraphicsCommandList6 *iface,
         D3D12_CPU_DESCRIPTOR_HANDLE rtv, const FLOAT color[4], UINT rect_count, const D3D12_RECT *rects)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const struct d3d12_rtv_desc *rtv_desc = d3d12_rtv_desc_from_cpu_handle(rtv);
     struct VkAttachmentDescription attachment_desc;
     struct VkAttachmentReference color_reference;
@@ -5481,11 +5483,11 @@ static struct vkd3d_view *create_uint_view(struct d3d12_device *device, const st
     return uint_view;
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewUint(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewUint(ID3D12GraphicsCommandList6 *iface,
         D3D12_GPU_DESCRIPTOR_HANDLE gpu_handle, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle, ID3D12Resource *resource,
         const UINT values[4], UINT rect_count, const D3D12_RECT *rects)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct vkd3d_view *descriptor, *uint_view = NULL;
     struct d3d12_device *device = list->device;
     const struct vkd3d_resource_view *view;
@@ -5514,11 +5516,11 @@ static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewUint(ID
         vkd3d_view_decref(uint_view, device);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewFloat(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewFloat(ID3D12GraphicsCommandList6 *iface,
         D3D12_GPU_DESCRIPTOR_HANDLE gpu_handle, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle, ID3D12Resource *resource,
         const float values[4], UINT rect_count, const D3D12_RECT *rects)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct vkd3d_view *descriptor, *uint_view = NULL;
     struct d3d12_device *device = list->device;
     const struct vkd3d_resource_view *view;
@@ -5547,16 +5549,16 @@ static void STDMETHODCALLTYPE d3d12_command_list_ClearUnorderedAccessViewFloat(I
         vkd3d_view_decref(uint_view, device);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_DiscardResource(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_DiscardResource(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *resource, const D3D12_DISCARD_REGION *region)
 {
     FIXME_ONCE("iface %p, resource %p, region %p stub!\n", iface, resource, region);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_BeginQuery(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_BeginQuery(ID3D12GraphicsCommandList6 *iface,
         ID3D12QueryHeap *heap, D3D12_QUERY_TYPE type, UINT index)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct d3d12_query_heap *query_heap = unsafe_impl_from_ID3D12QueryHeap(heap);
     const struct vkd3d_vk_device_procs *vk_procs;
     VkQueryControlFlags flags = 0;
@@ -5583,10 +5585,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_BeginQuery(ID3D12GraphicsComman
     VK_CALL(vkCmdBeginQuery(list->vk_command_buffer, query_heap->vk_query_pool, index, flags));
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_EndQuery(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_EndQuery(ID3D12GraphicsCommandList6 *iface,
         ID3D12QueryHeap *heap, D3D12_QUERY_TYPE type, UINT index)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct d3d12_query_heap *query_heap = unsafe_impl_from_ID3D12QueryHeap(heap);
     const struct vkd3d_vk_device_procs *vk_procs;
 
@@ -5628,12 +5630,12 @@ static size_t get_query_stride(D3D12_QUERY_TYPE type)
     return sizeof(uint64_t);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ResolveQueryData(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ResolveQueryData(ID3D12GraphicsCommandList6 *iface,
         ID3D12QueryHeap *heap, D3D12_QUERY_TYPE type, UINT start_index, UINT query_count,
         ID3D12Resource *dst_buffer, UINT64 aligned_dst_buffer_offset)
 {
     const struct d3d12_query_heap *query_heap = unsafe_impl_from_ID3D12QueryHeap(heap);
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct d3d12_resource *buffer = unsafe_impl_from_ID3D12Resource(dst_buffer);
     const struct vkd3d_vk_device_procs *vk_procs;
     unsigned int i, first, count;
@@ -5709,10 +5711,10 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResolveQueryData(ID3D12Graphics
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetPredication(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetPredication(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *buffer, UINT64 aligned_buffer_offset, D3D12_PREDICATION_OP operation)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct d3d12_resource *resource = unsafe_impl_from_ID3D12Resource(buffer);
     const struct vkd3d_vulkan_info *vk_info = &list->device->vk_info;
     const struct vkd3d_vk_device_procs *vk_procs;
@@ -5781,19 +5783,19 @@ static void STDMETHODCALLTYPE d3d12_command_list_SetPredication(ID3D12GraphicsCo
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetMarker(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetMarker(ID3D12GraphicsCommandList6 *iface,
         UINT metadata, const void *data, UINT size)
 {
     FIXME("iface %p, metadata %#x, data %p, size %u stub!\n", iface, metadata, data, size);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_BeginEvent(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_BeginEvent(ID3D12GraphicsCommandList6 *iface,
         UINT metadata, const void *data, UINT size)
 {
     FIXME("iface %p, metadata %#x, data %p, size %u stub!\n", iface, metadata, data, size);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_EndEvent(ID3D12GraphicsCommandList5 *iface)
+static void STDMETHODCALLTYPE d3d12_command_list_EndEvent(ID3D12GraphicsCommandList6 *iface)
 {
     FIXME("iface %p stub!\n", iface);
 }
@@ -5802,14 +5804,14 @@ STATIC_ASSERT(sizeof(VkDispatchIndirectCommand) == sizeof(D3D12_DISPATCH_ARGUMEN
 STATIC_ASSERT(sizeof(VkDrawIndexedIndirectCommand) == sizeof(D3D12_DRAW_INDEXED_ARGUMENTS));
 STATIC_ASSERT(sizeof(VkDrawIndirectCommand) == sizeof(D3D12_DRAW_ARGUMENTS));
 
-static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(ID3D12GraphicsCommandList6 *iface,
         ID3D12CommandSignature *command_signature, UINT max_command_count, ID3D12Resource *arg_buffer,
         UINT64 arg_buffer_offset, ID3D12Resource *count_buffer, UINT64 count_buffer_offset)
 {
     struct d3d12_command_signature *sig_impl = unsafe_impl_from_ID3D12CommandSignature(command_signature);
     struct d3d12_resource *count_impl = unsafe_impl_from_ID3D12Resource(count_buffer);
     struct d3d12_resource *arg_impl = unsafe_impl_from_ID3D12Resource(arg_buffer);
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     const D3D12_COMMAND_SIGNATURE_DESC *signature_desc;
     const struct vkd3d_vk_device_procs *vk_procs;
     unsigned int i;
@@ -5908,7 +5910,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_ExecuteIndirect(ID3D12GraphicsC
     d3d12_command_signature_decref(sig_impl);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *dst_buffer, UINT64 dst_offset,
         ID3D12Resource *src_buffer, UINT64 src_offset,
         UINT dependent_resource_count, ID3D12Resource * const *dependent_resources,
@@ -5921,7 +5923,7 @@ static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT(ID3D12Grap
             dependent_resource_count, dependent_resources, dependent_sub_resource_ranges);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT64(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT64(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *dst_buffer, UINT64 dst_offset,
         ID3D12Resource *src_buffer, UINT64 src_offset,
         UINT dependent_resource_count, ID3D12Resource * const *dependent_resources,
@@ -5934,20 +5936,20 @@ static void STDMETHODCALLTYPE d3d12_command_list_AtomicCopyBufferUINT64(ID3D12Gr
             dependent_resource_count, dependent_resources, dependent_sub_resource_ranges);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_OMSetDepthBounds(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_OMSetDepthBounds(ID3D12GraphicsCommandList6 *iface,
         FLOAT min, FLOAT max)
 {
     FIXME("iface %p, min %.8e, max %.8e stub!\n", iface, min, max);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetSamplePositions(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetSamplePositions(ID3D12GraphicsCommandList6 *iface,
         UINT sample_count, UINT pixel_count, D3D12_SAMPLE_POSITION *sample_positions)
 {
     FIXME("iface %p, sample_count %u, pixel_count %u, sample_positions %p stub!\n",
             iface, sample_count, pixel_count, sample_positions);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresourceRegion(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresourceRegion(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *dst_resource, UINT dst_sub_resource_idx, UINT dst_x, UINT dst_y,
         ID3D12Resource *src_resource, UINT src_sub_resource_idx,
         D3D12_RECT *src_rect, DXGI_FORMAT format, D3D12_RESOLVE_MODE mode)
@@ -5959,16 +5961,16 @@ static void STDMETHODCALLTYPE d3d12_command_list_ResolveSubresourceRegion(ID3D12
             src_resource, src_sub_resource_idx, src_rect, format, mode);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetViewInstanceMask(ID3D12GraphicsCommandList5 *iface, UINT mask)
+static void STDMETHODCALLTYPE d3d12_command_list_SetViewInstanceMask(ID3D12GraphicsCommandList6 *iface, UINT mask)
 {
     FIXME("iface %p, mask %#x stub!\n", iface, mask);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_WriteBufferImmediate(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_WriteBufferImmediate(ID3D12GraphicsCommandList6 *iface,
         UINT count, const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *parameters,
         const D3D12_WRITEBUFFERIMMEDIATE_MODE *modes)
 {
-    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
+    struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList6(iface);
     struct d3d12_resource *resource;
     unsigned int i;
 
@@ -5981,13 +5983,13 @@ static void STDMETHODCALLTYPE d3d12_command_list_WriteBufferImmediate(ID3D12Grap
     }
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetProtectedResourceSession(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetProtectedResourceSession(ID3D12GraphicsCommandList6 *iface,
         ID3D12ProtectedResourceSession *protected_session)
 {
     FIXME("iface %p, protected_session %p stub!\n", iface, protected_session);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_BeginRenderPass(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_BeginRenderPass(ID3D12GraphicsCommandList6 *iface,
         UINT count, const D3D12_RENDER_PASS_RENDER_TARGET_DESC *render_targets,
         const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC *depth_stencil, D3D12_RENDER_PASS_FLAGS flags)
 {
@@ -5995,74 +5997,78 @@ static void STDMETHODCALLTYPE d3d12_command_list_BeginRenderPass(ID3D12GraphicsC
             count, render_targets, depth_stencil, flags);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_EndRenderPass(ID3D12GraphicsCommandList5 *iface)
+static void STDMETHODCALLTYPE d3d12_command_list_EndRenderPass(ID3D12GraphicsCommandList6 *iface)
 {
     FIXME("iface %p stub!\n", iface);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_InitializeMetaCommand(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_InitializeMetaCommand(ID3D12GraphicsCommandList6 *iface,
         ID3D12MetaCommand *meta_command, const void *parameters_data, SIZE_T data_size_in_bytes)
 {
     FIXME("iface %p, meta_command %p, parameters_data %p, data_size_in_bytes %"PRIuPTR" stub!\n", iface,
             meta_command, parameters_data, (uintptr_t)data_size_in_bytes);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_ExecuteMetaCommand(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_ExecuteMetaCommand(ID3D12GraphicsCommandList6 *iface,
         ID3D12MetaCommand *meta_command, const void *parameters_data, SIZE_T data_size_in_bytes)
 {
     FIXME("iface %p, meta_command %p, parameters_data %p, data_size_in_bytes %"PRIuPTR" stub!\n", iface,
             meta_command, parameters_data, (uintptr_t)data_size_in_bytes);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_BuildRaytracingAccelerationStructure(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_BuildRaytracingAccelerationStructure(ID3D12GraphicsCommandList6 *iface,
         const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC *desc, UINT count,
         const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *postbuild_info_descs)
 {
     FIXME("iface %p, desc %p, count %u, postbuild_info_descs %p stub!\n", iface, desc, count, postbuild_info_descs);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_EmitRaytracingAccelerationStructurePostbuildInfo(ID3D12GraphicsCommandList5 *iface,
-        const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *desc,
+static void STDMETHODCALLTYPE d3d12_command_list_EmitRaytracingAccelerationStructurePostbuildInfo(
+        ID3D12GraphicsCommandList6 *iface, const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *desc,
         UINT structures_count, const D3D12_GPU_VIRTUAL_ADDRESS *src_structure_data)
 {
     FIXME("iface %p, desc %p, structures_count %u, src_structure_data %p stub!\n",
             iface, desc, structures_count, src_structure_data);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_CopyRaytracingAccelerationStructure(ID3D12GraphicsCommandList5 *iface,
-        D3D12_GPU_VIRTUAL_ADDRESS dst_structure_data,
-        D3D12_GPU_VIRTUAL_ADDRESS src_structure_data,
+static void STDMETHODCALLTYPE d3d12_command_list_CopyRaytracingAccelerationStructure(ID3D12GraphicsCommandList6 *iface,
+        D3D12_GPU_VIRTUAL_ADDRESS dst_structure_data, D3D12_GPU_VIRTUAL_ADDRESS src_structure_data,
         D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE mode)
 {
     FIXME("iface %p, dst_structure_data %#"PRIx64", src_structure_data %#"PRIx64", mode %u stub!\n",
             iface, dst_structure_data, src_structure_data, mode);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_SetPipelineState1(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_SetPipelineState1(ID3D12GraphicsCommandList6 *iface,
         ID3D12StateObject *state_object)
 {
     FIXME("iface %p, state_object %p stub!\n", iface, state_object);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_DispatchRays(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_DispatchRays(ID3D12GraphicsCommandList6 *iface,
         const D3D12_DISPATCH_RAYS_DESC *desc)
 {
     FIXME("iface %p, desc %p stub!\n", iface, desc);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_RSSetShadingRate(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_RSSetShadingRate(ID3D12GraphicsCommandList6 *iface,
         D3D12_SHADING_RATE rate, const D3D12_SHADING_RATE_COMBINER *combiners)
 {
     FIXME("iface %p, rate %#x, combiners %p stub!\n", iface, rate, combiners);
 }
 
-static void STDMETHODCALLTYPE d3d12_command_list_RSSetShadingRateImage(ID3D12GraphicsCommandList5 *iface,
+static void STDMETHODCALLTYPE d3d12_command_list_RSSetShadingRateImage(ID3D12GraphicsCommandList6 *iface,
         ID3D12Resource *rate_image)
 {
     FIXME("iface %p, rate_image %p stub!\n", iface, rate_image);
 }
 
-static const struct ID3D12GraphicsCommandList5Vtbl d3d12_command_list_vtbl =
+static void STDMETHODCALLTYPE d3d12_command_list_DispatchMesh(ID3D12GraphicsCommandList6 *iface, UINT x, UINT y, UINT z)
+{
+    FIXME("iface %p, x %u, y %u, z %u stub!\n", iface, x, y, z);
+}
+
+static const struct ID3D12GraphicsCommandList6Vtbl d3d12_command_list_vtbl =
 {
     /* IUnknown methods */
     d3d12_command_list_QueryInterface,
@@ -6153,14 +6159,16 @@ static const struct ID3D12GraphicsCommandList5Vtbl d3d12_command_list_vtbl =
     /* ID3D12GraphicsCommandList5 methods */
     d3d12_command_list_RSSetShadingRate,
     d3d12_command_list_RSSetShadingRateImage,
+    /* ID3D12GraphicsCommandList6 methods */
+    d3d12_command_list_DispatchMesh,
 };
 
 static struct d3d12_command_list *unsafe_impl_from_ID3D12CommandList(ID3D12CommandList *iface)
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == (struct ID3D12CommandListVtbl *)&d3d12_command_list_vtbl);
-    return CONTAINING_RECORD(iface, struct d3d12_command_list, ID3D12GraphicsCommandList5_iface);
+    VKD3D_ASSERT(iface->lpVtbl == (struct ID3D12CommandListVtbl *)&d3d12_command_list_vtbl);
+    return CONTAINING_RECORD(iface, struct d3d12_command_list, ID3D12GraphicsCommandList6_iface);
 }
 
 static HRESULT d3d12_command_list_init(struct d3d12_command_list *list, struct d3d12_device *device,
@@ -6169,7 +6177,7 @@ static HRESULT d3d12_command_list_init(struct d3d12_command_list *list, struct d
 {
     HRESULT hr;
 
-    list->ID3D12GraphicsCommandList5_iface.lpVtbl = &d3d12_command_list_vtbl;
+    list->ID3D12GraphicsCommandList6_iface.lpVtbl = &d3d12_command_list_vtbl;
     list->refcount = 1;
 
     list->type = type;
@@ -6773,7 +6781,7 @@ static HRESULT d3d12_command_queue_signal(struct d3d12_command_queue *command_qu
         }
 
         vk_semaphore = fence->timeline_semaphore;
-        assert(vk_semaphore);
+        VKD3D_ASSERT(vk_semaphore);
     }
     else
     {
@@ -6846,7 +6854,7 @@ static HRESULT d3d12_command_queue_signal(struct d3d12_command_queue *command_qu
             return hr;
 
         vk_semaphore = fence->timeline_semaphore;
-        assert(vk_semaphore);
+        VKD3D_ASSERT(vk_semaphore);
 
         return vkd3d_enqueue_timeline_semaphore(&command_queue->fence_worker,
                 vk_semaphore, fence, timeline_value, vkd3d_queue);
@@ -7015,7 +7023,7 @@ static HRESULT d3d12_command_queue_wait_locked(struct d3d12_command_queue *comma
      * until we have submitted, so the semaphore cannot be destroyed before the call to vkQueueSubmit. */
     vkd3d_mutex_unlock(&fence->mutex);
 
-    assert(fence->timeline_semaphore);
+    VKD3D_ASSERT(fence->timeline_semaphore);
     timeline_submit_info.sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR;
     timeline_submit_info.pNext = NULL;
     timeline_submit_info.waitSemaphoreValueCount = 1;
@@ -7279,7 +7287,7 @@ static HRESULT d3d12_command_queue_flush_ops_locked(struct d3d12_command_queue *
 
     queue->is_flushing = true;
 
-    assert(queue->aux_op_queue.count == 0);
+    VKD3D_ASSERT(queue->aux_op_queue.count == 0);
 
     while (queue->op_queue.count != 0)
     {
@@ -7569,7 +7577,7 @@ struct d3d12_command_signature *unsafe_impl_from_ID3D12CommandSignature(ID3D12Co
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == &d3d12_command_signature_vtbl);
+    VKD3D_ASSERT(iface->lpVtbl == &d3d12_command_signature_vtbl);
     return CONTAINING_RECORD(iface, struct d3d12_command_signature, ID3D12CommandSignature_iface);
 }
 
diff --git a/libs/vkd3d/libs/vkd3d/device.c b/libs/vkd3d/libs/vkd3d/device.c
index 5fe381af90c..01841c89692 100644
--- a/libs/vkd3d/libs/vkd3d/device.c
+++ b/libs/vkd3d/libs/vkd3d/device.c
@@ -308,7 +308,7 @@ static unsigned int vkd3d_check_extensions(const VkExtensionProperties *extensio
     for (i = 0; i < required_extension_count; ++i)
     {
         if (!has_extension(extensions, count, required_extensions[i]))
-            ERR("Required %s extension %s is not supported.\n",
+            WARN("Required %s extension %s is not supported.\n",
                     extension_type, debugstr_a(required_extensions[i]));
         ++extension_count;
     }
@@ -336,12 +336,12 @@ static unsigned int vkd3d_check_extensions(const VkExtensionProperties *extensio
     for (i = 0; i < user_extension_count; ++i)
     {
         if (!has_extension(extensions, count, user_extensions[i]))
-            ERR("Required user %s extension %s is not supported.\n",
+            WARN("Required user %s extension %s is not supported.\n",
                     extension_type, debugstr_a(user_extensions[i]));
         ++extension_count;
     }
 
-    assert(!optional_user_extension_count || user_extension_supported);
+    VKD3D_ASSERT(!optional_user_extension_count || user_extension_supported);
     for (i = 0; i < optional_user_extension_count; ++i)
     {
         if (has_extension(extensions, count, optional_user_extensions[i]))
@@ -403,7 +403,7 @@ static unsigned int vkd3d_enable_extensions(const char *extensions[],
     {
         extension_count = vkd3d_append_extension(extensions, extension_count, user_extensions[i]);
     }
-    assert(!optional_user_extension_count || user_extension_supported);
+    VKD3D_ASSERT(!optional_user_extension_count || user_extension_supported);
     for (i = 0; i < optional_user_extension_count; ++i)
     {
         if (!user_extension_supported[i])
@@ -584,7 +584,7 @@ static HRESULT vkd3d_instance_init(struct vkd3d_instance *instance,
 
     if (!create_info->pfn_signal_event)
     {
-        ERR("Invalid signal event function pointer.\n");
+        WARN("Invalid signal event function pointer.\n");
         return E_INVALIDARG;
     }
     if (!create_info->pfn_create_thread != !create_info->pfn_join_thread)
@@ -594,7 +594,7 @@ static HRESULT vkd3d_instance_init(struct vkd3d_instance *instance,
     }
     if (create_info->wchar_size != 2 && create_info->wchar_size != 4)
     {
-        ERR("Unexpected WCHAR size %zu.\n", create_info->wchar_size);
+        WARN("Unexpected WCHAR size %zu.\n", create_info->wchar_size);
         return E_INVALIDARG;
     }
 
@@ -1507,7 +1507,7 @@ static bool d3d12_device_supports_typed_uav_load_additional_formats(const struct
     for (i = 0; i < ARRAY_SIZE(additional_formats); ++i)
     {
         format = vkd3d_get_format(device, additional_formats[i], false);
-        assert(format);
+        VKD3D_ASSERT(format);
 
         VK_CALL(vkGetPhysicalDeviceFormatProperties(device->vk_physical_device, format->vk_format, &properties));
         if (!((properties.linearTilingFeatures | properties.optimalTilingFeatures) & VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT))
@@ -2155,7 +2155,7 @@ static HRESULT vkd3d_create_vk_device(struct d3d12_device *device,
     vkd3d_free(extensions);
     if (vr < 0)
     {
-        ERR("Failed to create Vulkan device, vr %d.\n", vr);
+        WARN("Failed to create Vulkan device, vr %d.\n", vr);
         return hresult_from_vk_result(vr);
     }
 
@@ -2547,7 +2547,7 @@ static void device_init_descriptor_pool_sizes(struct d3d12_device *device)
         return;
     }
 
-    assert(ARRAY_SIZE(device->vk_pool_sizes) >= 6);
+    VKD3D_ASSERT(ARRAY_SIZE(device->vk_pool_sizes) >= 6);
     pool_sizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
     pool_sizes[0].descriptorCount = min(limits->uniform_buffer_max_descriptors,
             VKD3D_MAX_VIRTUAL_HEAP_DESCRIPTORS_PER_TYPE);
@@ -3119,8 +3119,8 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CreateCommandList(ID3D12Device9 *i
             initial_pipeline_state, &object)))
         return hr;
 
-    return return_interface(&object->ID3D12GraphicsCommandList5_iface,
-            &IID_ID3D12GraphicsCommandList5, riid, command_list);
+    return return_interface(&object->ID3D12GraphicsCommandList6_iface,
+            &IID_ID3D12GraphicsCommandList6, riid, command_list);
 }
 
 /* Direct3D feature levels restrict which formats can be optionally supported. */
@@ -5254,7 +5254,7 @@ struct d3d12_device *unsafe_impl_from_ID3D12Device9(ID3D12Device9 *iface)
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == &d3d12_device_vtbl);
+    VKD3D_ASSERT(iface->lpVtbl == &d3d12_device_vtbl);
     return impl_from_ID3D12Device9(iface);
 }
 
diff --git a/libs/vkd3d/libs/vkd3d/resource.c b/libs/vkd3d/libs/vkd3d/resource.c
index 7d7f40c0953..ac29088b9cb 100644
--- a/libs/vkd3d/libs/vkd3d/resource.c
+++ b/libs/vkd3d/libs/vkd3d/resource.c
@@ -312,7 +312,7 @@ static ULONG STDMETHODCALLTYPE d3d12_heap_AddRef(ID3D12Heap *iface)
 
     TRACE("%p increasing refcount to %u.\n", heap, refcount);
 
-    assert(!heap->is_private);
+    VKD3D_ASSERT(!heap->is_private);
 
     return refcount;
 }
@@ -443,7 +443,7 @@ struct d3d12_heap *unsafe_impl_from_ID3D12Heap(ID3D12Heap *iface)
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == &d3d12_heap_vtbl);
+    VKD3D_ASSERT(iface->lpVtbl == &d3d12_heap_vtbl);
     return impl_from_ID3D12Heap(iface);
 }
 
@@ -950,8 +950,8 @@ HRESULT vkd3d_get_image_allocation_info(struct d3d12_device *device,
     bool tiled;
     HRESULT hr;
 
-    assert(desc->Dimension != D3D12_RESOURCE_DIMENSION_BUFFER);
-    assert(d3d12_resource_validate_desc(desc, device) == S_OK);
+    VKD3D_ASSERT(desc->Dimension != D3D12_RESOURCE_DIMENSION_BUFFER);
+    VKD3D_ASSERT(d3d12_resource_validate_desc(desc, device) == S_OK);
 
     if (!desc->MipLevels)
     {
@@ -1044,7 +1044,7 @@ static bool d3d12_resource_validate_box(const struct d3d12_resource *resource,
     depth = d3d12_resource_desc_get_depth(&resource->desc, mip_level);
 
     vkd3d_format = resource->format;
-    assert(vkd3d_format);
+    VKD3D_ASSERT(vkd3d_format);
     width_mask = vkd3d_format->block_width - 1;
     height_mask = vkd3d_format->block_height - 1;
 
@@ -1162,7 +1162,7 @@ static bool d3d12_resource_init_tiles(struct d3d12_resource *resource, struct d3
 
     if (d3d12_resource_is_buffer(resource))
     {
-        assert(subresource_count == 1);
+        VKD3D_ASSERT(subresource_count == 1);
 
         VK_CALL(vkGetBufferMemoryRequirements(device->vk_device, resource->u.vk_buffer, &requirements));
         if (requirements.alignment > D3D12_TILED_RESOURCE_TILE_SIZE_IN_BYTES)
@@ -1381,7 +1381,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_resource_GetDevice(ID3D12Resource2 *iface
 
 static void *d3d12_resource_get_map_ptr(struct d3d12_resource *resource)
 {
-    assert(resource->heap->map_ptr);
+    VKD3D_ASSERT(resource->heap->map_ptr);
     return (uint8_t *)resource->heap->map_ptr + resource->heap_offset;
 }
 
@@ -1771,7 +1771,7 @@ struct d3d12_resource *unsafe_impl_from_ID3D12Resource(ID3D12Resource *iface)
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == (ID3D12ResourceVtbl *)&d3d12_resource_vtbl);
+    VKD3D_ASSERT(iface->lpVtbl == (ID3D12ResourceVtbl *)&d3d12_resource_vtbl);
     return impl_from_ID3D12Resource(iface);
 }
 
@@ -2165,7 +2165,7 @@ static HRESULT vkd3d_bind_heap_memory(struct d3d12_device *device,
 
     if (heap_offset > heap->desc.SizeInBytes || requirements.size > heap->desc.SizeInBytes - heap_offset)
     {
-        ERR("Heap too small for the resource (offset %"PRIu64", resource size %"PRIu64", heap size %"PRIu64".\n",
+        WARN("Heap too small for the resource (offset %"PRIu64", resource size %"PRIu64", heap size %"PRIu64".\n",
                 heap_offset, requirements.size, heap->desc.SizeInBytes);
         return E_INVALIDARG;
     }
@@ -2406,7 +2406,7 @@ static struct vkd3d_view *vkd3d_view_create(uint32_t magic, VkDescriptorType vk_
 {
     struct vkd3d_view *view;
 
-    assert(magic);
+    VKD3D_ASSERT(magic);
 
     if (!(view = vkd3d_desc_object_cache_get(&device->view_desc_cache)))
     {
@@ -2536,7 +2536,7 @@ static void d3d12_desc_write_vk_heap_null_descriptor(struct d3d12_descriptor_hea
                 writes->vk_descriptor_writes[i].pTexelBufferView = &writes->null_vk_buffer_view;
                 break;
             default:
-                assert(false);
+                VKD3D_ASSERT(false);
                 break;
         }
         if (++i < ARRAY_SIZE(writes->vk_descriptor_writes) - 1)
@@ -2725,7 +2725,7 @@ void d3d12_desc_copy(struct d3d12_desc *dst, const struct d3d12_desc *src, struc
 {
     struct d3d12_desc tmp;
 
-    assert(dst != src);
+    VKD3D_ASSERT(dst != src);
 
     tmp.s.u.object = d3d12_desc_get_object_ref(src, device);
     descriptor_heap_write_atomic(dst_heap, dst, &tmp, device);
@@ -2748,7 +2748,7 @@ static VkDeviceSize vkd3d_get_required_texel_buffer_alignment(const struct d3d12
         if (properties->storageTexelBufferOffsetSingleTexelAlignment
                 && properties->uniformTexelBufferOffsetSingleTexelAlignment)
         {
-            assert(!vkd3d_format_is_compressed(format));
+            VKD3D_ASSERT(!vkd3d_format_is_compressed(format));
             return min(format->byte_count, alignment);
         }
 
@@ -2848,7 +2848,7 @@ static bool vkd3d_create_buffer_view_for_resource(struct d3d12_device *device,
         return false;
     }
 
-    assert(d3d12_resource_is_buffer(resource));
+    VKD3D_ASSERT(d3d12_resource_is_buffer(resource));
 
     return vkd3d_create_buffer_view(device, magic, resource->u.vk_buffer,
             format, offset * element_size, size * element_size, view);
@@ -2979,7 +2979,7 @@ static VkComponentSwizzle swizzle_vk_component(const VkComponentMapping *compone
             break;
     }
 
-    assert(component != VK_COMPONENT_SWIZZLE_IDENTITY);
+    VKD3D_ASSERT(component != VK_COMPONENT_SWIZZLE_IDENTITY);
     return component;
 }
 
@@ -3511,8 +3511,8 @@ static void vkd3d_create_buffer_uav(struct d3d12_desc *descriptor, struct d3d12_
     {
         const struct vkd3d_format *format;
 
-        assert(d3d12_resource_is_buffer(counter_resource));
-        assert(desc->u.Buffer.StructureByteStride);
+        VKD3D_ASSERT(d3d12_resource_is_buffer(counter_resource));
+        VKD3D_ASSERT(desc->u.Buffer.StructureByteStride);
 
         format = vkd3d_get_format(device, DXGI_FORMAT_R32_UINT, false);
         if (!vkd3d_create_vk_buffer_view(device, counter_resource->u.vk_buffer, format,
@@ -3632,7 +3632,7 @@ bool vkd3d_create_raw_buffer_view(struct d3d12_device *device,
     }
 
     resource = vkd3d_gpu_va_allocator_dereference(&device->gpu_va_allocator, gpu_address);
-    assert(d3d12_resource_is_buffer(resource));
+    VKD3D_ASSERT(d3d12_resource_is_buffer(resource));
     return vkd3d_create_vk_buffer_view(device, resource->u.vk_buffer, format,
             gpu_address - resource->gpu_address, VK_WHOLE_SIZE, vk_buffer_view);
 }
@@ -3904,7 +3904,7 @@ void d3d12_rtv_desc_create_rtv(struct d3d12_rtv_desc *rtv_desc, struct d3d12_dev
         vkd3d_desc.layer_count = resource->desc.DepthOrArraySize;
     }
 
-    assert(d3d12_resource_is_texture(resource));
+    VKD3D_ASSERT(d3d12_resource_is_texture(resource));
 
     if (!vkd3d_create_texture_view(device, VKD3D_DESCRIPTOR_MAGIC_RTV, resource->u.vk_image, &vkd3d_desc, &view))
         return;
@@ -3990,7 +3990,7 @@ void d3d12_dsv_desc_create_dsv(struct d3d12_dsv_desc *dsv_desc, struct d3d12_dev
         }
     }
 
-    assert(d3d12_resource_is_texture(resource));
+    VKD3D_ASSERT(d3d12_resource_is_texture(resource));
 
     if (!vkd3d_create_texture_view(device, VKD3D_DESCRIPTOR_MAGIC_DSV, resource->u.vk_image, &vkd3d_desc, &view))
         return;
@@ -4559,7 +4559,7 @@ struct d3d12_query_heap *unsafe_impl_from_ID3D12QueryHeap(ID3D12QueryHeap *iface
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == &d3d12_query_heap_vtbl);
+    VKD3D_ASSERT(iface->lpVtbl == &d3d12_query_heap_vtbl);
     return impl_from_ID3D12QueryHeap(iface);
 }
 
diff --git a/libs/vkd3d/libs/vkd3d/state.c b/libs/vkd3d/libs/vkd3d/state.c
index bbfaaad47dd..0bdb7ea524d 100644
--- a/libs/vkd3d/libs/vkd3d/state.c
+++ b/libs/vkd3d/libs/vkd3d/state.c
@@ -194,7 +194,7 @@ struct d3d12_root_signature *unsafe_impl_from_ID3D12RootSignature(ID3D12RootSign
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == &d3d12_root_signature_vtbl);
+    VKD3D_ASSERT(iface->lpVtbl == &d3d12_root_signature_vtbl);
     return impl_from_ID3D12RootSignature(iface);
 }
 
@@ -345,15 +345,93 @@ struct d3d12_root_signature_info
     unsigned int sampler_unbounded_range_count;
 
     size_t cost;
+
+    struct d3d12_root_signature_info_range
+    {
+        enum vkd3d_shader_descriptor_type type;
+        unsigned int space;
+        unsigned int base_idx;
+        unsigned int count;
+        D3D12_SHADER_VISIBILITY visibility;
+    } *ranges;
+    size_t range_count, range_capacity;
 };
 
+static HRESULT d3d12_root_signature_info_add_range(struct d3d12_root_signature_info *info,
+        enum vkd3d_shader_descriptor_type type,  D3D12_SHADER_VISIBILITY visibility,
+        unsigned int space, unsigned int base_idx, unsigned int count)
+{
+    struct d3d12_root_signature_info_range *range;
+
+    if (!vkd3d_array_reserve((void **)&info->ranges, &info->range_capacity, info->range_count + 1,
+            sizeof(*info->ranges)))
+        return E_OUTOFMEMORY;
+
+    range = &info->ranges[info->range_count++];
+    range->type = type;
+    range->space = space;
+    range->base_idx = base_idx;
+    range->count = count;
+    range->visibility = visibility;
+
+    return S_OK;
+}
+
+static int d3d12_root_signature_info_range_compare(const void *a, const void *b)
+{
+    const struct d3d12_root_signature_info_range *range_a = a, *range_b = b;
+    int ret;
+
+    if ((ret = vkd3d_u32_compare(range_a->type, range_b->type)))
+        return ret;
+
+    if ((ret = vkd3d_u32_compare(range_a->space, range_b->space)))
+        return ret;
+
+    return vkd3d_u32_compare(range_a->base_idx, range_b->base_idx);
+}
+
+static HRESULT d3d12_root_signature_info_range_validate(const struct d3d12_root_signature_info_range *ranges,
+        unsigned int count, D3D12_SHADER_VISIBILITY visibility)
+{
+    const struct d3d12_root_signature_info_range *range, *next;
+    unsigned int i = 0, j;
+
+    while (i < count)
+    {
+        range = &ranges[i];
+
+        for (j = i + 1; j < count; ++j)
+        {
+            next = &ranges[j];
+
+            if (range->visibility != D3D12_SHADER_VISIBILITY_ALL
+                    && next->visibility != D3D12_SHADER_VISIBILITY_ALL
+                    && range->visibility != next->visibility)
+                continue;
+
+            if (range->type == next->type && range->space == next->space
+                    && range->base_idx + range->count > next->base_idx)
+                return E_INVALIDARG;
+
+            break;
+        }
+
+        i = j;
+    }
+
+    return S_OK;
+}
+
 static HRESULT d3d12_root_signature_info_count_descriptors(struct d3d12_root_signature_info *info,
-        const D3D12_ROOT_DESCRIPTOR_TABLE *table, bool use_array)
+        const D3D12_ROOT_PARAMETER *param, bool use_array)
 {
     bool cbv_unbounded_range = false, srv_unbounded_range = false, uav_unbounded_range = false;
+    const D3D12_ROOT_DESCRIPTOR_TABLE *table = &param->u.DescriptorTable;
     bool sampler_unbounded_range = false;
     bool unbounded = false;
     unsigned int i, count;
+    HRESULT hr;
 
     for (i = 0; i < table->NumDescriptorRanges; ++i)
     {
@@ -381,6 +459,12 @@ static HRESULT d3d12_root_signature_info_count_descriptors(struct d3d12_root_sig
         }
 
         count = range->NumDescriptors;
+
+        if (FAILED(hr = d3d12_root_signature_info_add_range(info,
+                vkd3d_descriptor_type_from_d3d12_range_type(range->RangeType),
+                param->ShaderVisibility, range->RegisterSpace, range->BaseShaderRegister, count)))
+            return hr;
+
         if (range->NumDescriptors == UINT_MAX)
         {
             unbounded = true;
@@ -453,7 +537,7 @@ static HRESULT d3d12_root_signature_info_from_desc(struct d3d12_root_signature_i
         {
             case D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE:
                 if (FAILED(hr = d3d12_root_signature_info_count_descriptors(info,
-                        &p->u.DescriptorTable, use_array)))
+                        p, use_array)))
                     return hr;
                 ++info->cost;
                 break;
@@ -463,23 +547,41 @@ static HRESULT d3d12_root_signature_info_from_desc(struct d3d12_root_signature_i
                 ++info->cbv_count;
                 ++info->binding_count;
                 info->cost += 2;
+                if (FAILED(hr = d3d12_root_signature_info_add_range(info,
+                        VKD3D_SHADER_DESCRIPTOR_TYPE_CBV, p->ShaderVisibility,
+                        p->u.Descriptor.RegisterSpace, p->u.Descriptor.ShaderRegister, 1)))
+                    return hr;
                 break;
+
             case D3D12_ROOT_PARAMETER_TYPE_SRV:
                 ++info->root_descriptor_count;
                 ++info->srv_count;
                 ++info->binding_count;
                 info->cost += 2;
+                if (FAILED(hr = d3d12_root_signature_info_add_range(info,
+                        VKD3D_SHADER_DESCRIPTOR_TYPE_SRV, p->ShaderVisibility,
+                        p->u.Descriptor.RegisterSpace, p->u.Descriptor.ShaderRegister, 1)))
+                    return hr;
                 break;
+
             case D3D12_ROOT_PARAMETER_TYPE_UAV:
                 ++info->root_descriptor_count;
                 ++info->uav_count;
                 ++info->binding_count;
                 info->cost += 2;
+                if (FAILED(hr = d3d12_root_signature_info_add_range(info,
+                        VKD3D_SHADER_DESCRIPTOR_TYPE_UAV, p->ShaderVisibility,
+                        p->u.Descriptor.RegisterSpace, p->u.Descriptor.ShaderRegister, 1)))
+                    return hr;
                 break;
 
             case D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS:
                 ++info->root_constant_count;
                 info->cost += p->u.Constants.Num32BitValues;
+                if (FAILED(hr = d3d12_root_signature_info_add_range(info,
+                        VKD3D_SHADER_DESCRIPTOR_TYPE_CBV, p->ShaderVisibility,
+                        p->u.Constants.RegisterSpace, p->u.Constants.ShaderRegister, 1)))
+                    return hr;
                 break;
 
             default:
@@ -491,6 +593,30 @@ static HRESULT d3d12_root_signature_info_from_desc(struct d3d12_root_signature_i
     info->binding_count += desc->NumStaticSamplers;
     info->sampler_count += desc->NumStaticSamplers;
 
+    for (i = 0; i < desc->NumStaticSamplers; ++i)
+    {
+        const D3D12_STATIC_SAMPLER_DESC *s = &desc->pStaticSamplers[i];
+
+        if (FAILED(hr = d3d12_root_signature_info_add_range(info,
+                VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER, s->ShaderVisibility,
+                s->RegisterSpace, s->ShaderRegister, 1)))
+            return hr;
+    }
+
+    qsort(info->ranges, info->range_count, sizeof(*info->ranges),
+            d3d12_root_signature_info_range_compare);
+
+    for (i = D3D12_SHADER_VISIBILITY_VERTEX; i <= D3D12_SHADER_VISIBILITY_MESH; ++i)
+    {
+        if (FAILED(hr = d3d12_root_signature_info_range_validate(info->ranges, info->range_count, i)))
+            return hr;
+    }
+
+    vkd3d_free(info->ranges);
+    info->ranges = NULL;
+    info->range_count = 0;
+    info->range_capacity = 0;
+
     return S_OK;
 }
 
@@ -512,7 +638,7 @@ static HRESULT d3d12_root_signature_init_push_constants(struct d3d12_root_signat
         if (p->ParameterType != D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS)
             continue;
 
-        assert(p->ShaderVisibility <= D3D12_SHADER_VISIBILITY_PIXEL);
+        VKD3D_ASSERT(p->ShaderVisibility <= D3D12_SHADER_VISIBILITY_PIXEL);
         push_constants[p->ShaderVisibility].stageFlags = use_vk_heaps ? VK_SHADER_STAGE_ALL
                 : stage_flags_from_visibility(p->ShaderVisibility);
         push_constants[p->ShaderVisibility].size += align(p->u.Constants.Num32BitValues, 4) * sizeof(uint32_t);
@@ -963,20 +1089,6 @@ static void d3d12_root_signature_map_descriptor_unbounded_binding(struct d3d12_r
             descriptor_offset, is_buffer, shader_visibility, context);
 }
 
-static int compare_register_range(const void *a, const void *b)
-{
-    const struct d3d12_root_descriptor_table_range *range_a = a, *range_b = b;
-    int ret;
-
-    if ((ret = vkd3d_u32_compare(range_a->type, range_b->type)))
-        return ret;
-
-    if ((ret = vkd3d_u32_compare(range_a->register_space, range_b->register_space)))
-        return ret;
-
-    return vkd3d_u32_compare(range_a->base_register_idx, range_b->base_register_idx);
-}
-
 static int compare_descriptor_range(const void *a, const void *b)
 {
     const struct d3d12_root_descriptor_table_range *range_a = a, *range_b = b;
@@ -991,25 +1103,6 @@ static int compare_descriptor_range(const void *a, const void *b)
     return (range_a->descriptor_count == UINT_MAX) - (range_b->descriptor_count == UINT_MAX);
 }
 
-static HRESULT validate_descriptor_register_ranges(const struct d3d12_root_descriptor_table_range *ranges,
-        unsigned int count)
-{
-    const struct d3d12_root_descriptor_table_range *range, *prev;
-    unsigned int i;
-
-    for (i = 1; i < count; ++i)
-    {
-        range = &ranges[i];
-        prev = &ranges[i - 1];
-
-        if (range->type == prev->type && range->register_space == prev->register_space
-                && range->base_register_idx - prev->base_register_idx < prev->descriptor_count)
-            return E_INVALIDARG;
-    }
-
-    return S_OK;
-}
-
 static HRESULT d3d12_root_signature_init_root_descriptor_tables(struct d3d12_root_signature *root_signature,
         const D3D12_ROOT_SIGNATURE_DESC *desc, const struct d3d12_root_signature_info *info,
         struct vkd3d_descriptor_set_context *context)
@@ -1070,10 +1163,6 @@ static HRESULT d3d12_root_signature_init_root_descriptor_tables(struct d3d12_roo
             offset += range->NumDescriptors;
         }
 
-        qsort(table->ranges, range_count, sizeof(*table->ranges), compare_register_range);
-        if (FAILED(hr = validate_descriptor_register_ranges(table->ranges, range_count)))
-            return hr;
-
         qsort(table->ranges, range_count, sizeof(*table->ranges), compare_descriptor_range);
 
         for (j = 0; j < range_count; ++j)
@@ -1226,7 +1315,7 @@ static HRESULT d3d12_root_signature_init_static_samplers(struct d3d12_root_signa
     unsigned int i;
     HRESULT hr;
 
-    assert(root_signature->static_sampler_count == desc->NumStaticSamplers);
+    VKD3D_ASSERT(root_signature->static_sampler_count == desc->NumStaticSamplers);
     for (i = 0; i < desc->NumStaticSamplers; ++i)
     {
         const D3D12_STATIC_SAMPLER_DESC *s = &desc->pStaticSamplers[i];
@@ -1612,7 +1701,7 @@ static HRESULT vkd3d_render_pass_cache_create_pass_locked(struct vkd3d_render_pa
 
     have_depth_stencil = key->depth_enable || key->stencil_enable;
     rt_count = have_depth_stencil ? key->attachment_count - 1 : key->attachment_count;
-    assert(rt_count <= D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT);
+    VKD3D_ASSERT(rt_count <= D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT);
 
     for (index = 0, attachment_index = 0; index < rt_count; ++index)
     {
@@ -2152,7 +2241,7 @@ struct d3d12_pipeline_state *unsafe_impl_from_ID3D12PipelineState(ID3D12Pipeline
 {
     if (!iface)
         return NULL;
-    assert(iface->lpVtbl == &d3d12_pipeline_state_vtbl);
+    VKD3D_ASSERT(iface->lpVtbl == &d3d12_pipeline_state_vtbl);
     return impl_from_ID3D12PipelineState(iface);
 }
 
@@ -2308,7 +2397,7 @@ static HRESULT d3d12_pipeline_state_init_uav_counters(struct d3d12_pipeline_stat
     unsigned int i, j;
     HRESULT hr;
 
-    assert(vkd3d_popcount(stage_flags) == 1);
+    VKD3D_ASSERT(vkd3d_popcount(stage_flags) == 1);
 
     for (i = 0; i < shader_info->descriptor_count; ++i)
     {
@@ -2923,7 +3012,7 @@ static HRESULT d3d12_graphics_pipeline_state_create_render_pass(
 
     if (dsv_format)
     {
-        assert(graphics->ds_desc.front.writeMask == graphics->ds_desc.back.writeMask);
+        VKD3D_ASSERT(graphics->ds_desc.front.writeMask == graphics->ds_desc.back.writeMask);
         key.depth_enable = graphics->ds_desc.depthTestEnable;
         key.stencil_enable = graphics->ds_desc.stencilTestEnable;
         key.depth_stencil_write = graphics->ds_desc.depthWriteEnable
@@ -2940,7 +3029,7 @@ static HRESULT d3d12_graphics_pipeline_state_create_render_pass(
     if (key.attachment_count != ARRAY_SIZE(key.vk_formats))
         key.vk_formats[ARRAY_SIZE(key.vk_formats) - 1] = VK_FORMAT_UNDEFINED;
     for (i = key.attachment_count; i < ARRAY_SIZE(key.vk_formats); ++i)
-        assert(key.vk_formats[i] == VK_FORMAT_UNDEFINED);
+        VKD3D_ASSERT(key.vk_formats[i] == VK_FORMAT_UNDEFINED);
 
     key.padding = 0;
     key.sample_count = graphics->ms_desc.rasterizationSamples;
@@ -3488,7 +3577,7 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     graphics->ms_desc.pSampleMask = NULL;
     if (desc->sample_mask != ~0u)
     {
-        assert(DIV_ROUND_UP(sample_count, 32) <= ARRAY_SIZE(graphics->sample_mask));
+        VKD3D_ASSERT(DIV_ROUND_UP(sample_count, 32) <= ARRAY_SIZE(graphics->sample_mask));
         graphics->sample_mask[0] = desc->sample_mask;
         graphics->sample_mask[1] = 0xffffffffu;
         graphics->ms_desc.pSampleMask = graphics->sample_mask;
@@ -3781,7 +3870,7 @@ VkPipeline d3d12_pipeline_state_get_or_create_pipeline(struct d3d12_pipeline_sta
         .pDynamicStates = dynamic_states,
     };
 
-    assert(d3d12_pipeline_state_is_graphics(state));
+    VKD3D_ASSERT(d3d12_pipeline_state_is_graphics(state));
 
     memset(&pipeline_key, 0, sizeof(pipeline_key));
     pipeline_key.topology = topology;
diff --git a/libs/vkd3d/libs/vkd3d/utils.c b/libs/vkd3d/libs/vkd3d/utils.c
index 11029c9f5f9..831dc07af56 100644
--- a/libs/vkd3d/libs/vkd3d/utils.c
+++ b/libs/vkd3d/libs/vkd3d/utils.c
@@ -331,7 +331,7 @@ static HRESULT vkd3d_init_format_compatibility_lists(struct d3d12_device *device
 
         if (j >= current_list->format_count)
         {
-            assert(current_list->format_count < VKD3D_MAX_COMPATIBLE_FORMAT_COUNT);
+            VKD3D_ASSERT(current_list->format_count < VKD3D_MAX_COMPATIBLE_FORMAT_COUNT);
             current_list->vk_formats[current_list->format_count++] = vk_format;
         }
     }
@@ -427,7 +427,7 @@ static const struct vkd3d_format *vkd3d_get_depth_stencil_format(const struct d3
     const struct vkd3d_format *formats;
     unsigned int i;
 
-    assert(device);
+    VKD3D_ASSERT(device);
     formats = device->depth_stencil_formats;
 
     for (i = 0; i < ARRAY_SIZE(vkd3d_depth_stencil_formats); ++i)
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_main.c b/libs/vkd3d/libs/vkd3d/vkd3d_main.c
index c7431bd821b..9eccec111c7 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_main.c
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_main.c
@@ -38,12 +38,12 @@ HRESULT vkd3d_create_device(const struct vkd3d_device_create_info *create_info,
     }
     if (!create_info->instance && !create_info->instance_create_info)
     {
-        ERR("Instance or instance create info is required.\n");
+        WARN("Instance or instance create info is required.\n");
         return E_INVALIDARG;
     }
     if (create_info->instance && create_info->instance_create_info)
     {
-        ERR("Instance and instance create info are mutually exclusive parameters.\n");
+        WARN("Instance and instance create info are mutually exclusive parameters.\n");
         return E_INVALIDARG;
     }
 
@@ -153,7 +153,7 @@ static const D3D12_ROOT_SIGNATURE_DESC * STDMETHODCALLTYPE d3d12_root_signature_
 
     TRACE("iface %p.\n", iface);
 
-    assert(deserializer->desc.d3d12.Version == D3D_ROOT_SIGNATURE_VERSION_1_0);
+    VKD3D_ASSERT(deserializer->desc.d3d12.Version == D3D_ROOT_SIGNATURE_VERSION_1_0);
     return &deserializer->desc.d3d12.u.Desc_1_0;
 }
 
@@ -354,7 +354,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_versioned_root_signature_deserializer_Get
         }
     }
 
-    assert(deserializer->other_desc.d3d12.Version == version);
+    VKD3D_ASSERT(deserializer->other_desc.d3d12.Version == version);
     *desc = &deserializer->other_desc.d3d12;
     return S_OK;
 }
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
index cae8aa69c8b..a4bd2202f39 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -787,8 +787,8 @@ extern const enum vkd3d_vk_descriptor_set_index vk_descriptor_set_index_table[];
 static inline enum vkd3d_vk_descriptor_set_index vkd3d_vk_descriptor_set_index_from_vk_descriptor_type(
         VkDescriptorType type)
 {
-    assert(type <= VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER);
-    assert(vk_descriptor_set_index_table[type] < VKD3D_SET_INDEX_COUNT);
+    VKD3D_ASSERT(type <= VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER);
+    VKD3D_ASSERT(vk_descriptor_set_index_table[type] < VKD3D_SET_INDEX_COUNT);
 
     return vk_descriptor_set_index_table[type];
 }
@@ -1232,7 +1232,7 @@ enum vkd3d_pipeline_bind_point
 /* ID3D12CommandList */
 struct d3d12_command_list
 {
-    ID3D12GraphicsCommandList5 ID3D12GraphicsCommandList5_iface;
+    ID3D12GraphicsCommandList6 ID3D12GraphicsCommandList6_iface;
     unsigned int refcount;
 
     D3D12_COMMAND_LIST_TYPE type;
@@ -1768,7 +1768,7 @@ static inline void vkd3d_prepend_struct(void *header, void *structure)
         const void *next;
     } *vkd3d_header = header, *vkd3d_structure = structure;
 
-    assert(!vkd3d_structure->next);
+    VKD3D_ASSERT(!vkd3d_structure->next);
     vkd3d_structure->next = vkd3d_header->next;
     vkd3d_header->next = vkd3d_structure;
 }
-- 
2.43.0

