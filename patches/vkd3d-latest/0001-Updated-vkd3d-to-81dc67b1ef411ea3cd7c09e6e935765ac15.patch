From 956e5ccfaad86d4bd16956d5485970c1ddc4bf89 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 21 Feb 2025 09:15:01 +1100
Subject: [PATCH] Updated vkd3d to 81dc67b1ef411ea3cd7c09e6e935765ac1583d28.

---
 libs/vkd3d/include/private/spirv_grammar.h    | 10103 ++++++++++++++++
 libs/vkd3d/include/private/vkd3d_common.h     |     5 +-
 .../include/private/vkd3d_shader_utils.h      |     4 -
 libs/vkd3d/include/private/vkd3d_version.h    |     2 +-
 libs/vkd3d/include/vkd3d_shader.h             |    15 +-
 libs/vkd3d/libs/vkd3d-common/blob.c           |     1 +
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c        |    23 +-
 libs/vkd3d/libs/vkd3d-shader/dxbc.c           |    34 +-
 libs/vkd3d/libs/vkd3d-shader/dxil.c           |    95 +-
 libs/vkd3d/libs/vkd3d-shader/fx.c             |  1467 ++-
 libs/vkd3d/libs/vkd3d-shader/hlsl.c           |   263 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.h           |    69 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.y           |   578 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c   |  1287 +-
 .../libs/vkd3d-shader/hlsl_constant_ops.c     |    71 +-
 libs/vkd3d/libs/vkd3d-shader/ir.c             |   222 +-
 libs/vkd3d/libs/vkd3d-shader/preproc.l        |     1 +
 libs/vkd3d/libs/vkd3d-shader/preproc.y        |    10 +
 libs/vkd3d/libs/vkd3d-shader/spirv.c          |   427 +-
 libs/vkd3d/libs/vkd3d-shader/tpf.c            |    25 +-
 .../libs/vkd3d-shader/vkd3d_shader_main.c     |    81 +-
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |     6 +-
 .../vkd3d/libs/vkd3d-utils/vkd3d_utils_main.c |     2 +
 libs/vkd3d/libs/vkd3d/command.c               |    50 +-
 libs/vkd3d/libs/vkd3d/device.c                |    37 +-
 libs/vkd3d/libs/vkd3d/resource.c              |    14 +-
 libs/vkd3d/libs/vkd3d/state.c                 |   118 +-
 libs/vkd3d/libs/vkd3d/vkd3d_private.h         |     2 +-
 28 files changed, 13284 insertions(+), 1728 deletions(-)
 create mode 100644 libs/vkd3d/include/private/spirv_grammar.h

diff --git a/libs/vkd3d/include/private/spirv_grammar.h b/libs/vkd3d/include/private/spirv_grammar.h
new file mode 100644
index 00000000000..2aac5a6558c
--- /dev/null
+++ b/libs/vkd3d/include/private/spirv_grammar.h
@@ -0,0 +1,10103 @@
+/* This file is automatically generated from version 1.6.4 of the
+ * machine-readable SPIR-V grammar.
+ *
+ * The original source is covered by the following license:
+ *
+ * Copyright (c) 2014-2024 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and/or associated documentation files (the "Materials"),
+ * to deal in the Materials without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Materials, and to permit persons to whom the
+ * Materials are furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Materials.
+ *
+ * MODIFICATIONS TO THIS FILE MAY MEAN IT NO LONGER ACCURATELY REFLECTS KHRONOS
+ * STANDARDS. THE UNMODIFIED, NORMATIVE VERSIONS OF KHRONOS SPECIFICATIONS AND
+ * HEADER INFORMATION ARE LOCATED AT https://www.khronos.org/registry/
+ *
+ * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM,OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS
+ * IN THE MATERIALS.
+ */
+
+enum spirv_parser_operand_category
+{
+    SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM,
+    SPIRV_PARSER_OPERAND_CATEGORY_COMPOSITE,
+    SPIRV_PARSER_OPERAND_CATEGORY_ID,
+    SPIRV_PARSER_OPERAND_CATEGORY_LITERAL,
+    SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM,
+};
+
+enum spirv_parser_operand_type
+{
+    SPIRV_PARSER_OPERAND_TYPE_ACCESS_QUALIFIER,
+    SPIRV_PARSER_OPERAND_TYPE_ADDRESSING_MODEL,
+    SPIRV_PARSER_OPERAND_TYPE_BUILT_IN,
+    SPIRV_PARSER_OPERAND_TYPE_CAPABILITY,
+    SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_LAYOUT,
+    SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_OPERANDS,
+    SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_REDUCE,
+    SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_USE,
+    SPIRV_PARSER_OPERAND_TYPE_DECORATION,
+    SPIRV_PARSER_OPERAND_TYPE_DIM,
+    SPIRV_PARSER_OPERAND_TYPE_EXECUTION_MODE,
+    SPIRV_PARSER_OPERAND_TYPE_EXECUTION_MODEL,
+    SPIRV_PARSER_OPERAND_TYPE_FPDENORM_MODE,
+    SPIRV_PARSER_OPERAND_TYPE_FPENCODING,
+    SPIRV_PARSER_OPERAND_TYPE_FPFAST_MATH_MODE,
+    SPIRV_PARSER_OPERAND_TYPE_FPOPERATION_MODE,
+    SPIRV_PARSER_OPERAND_TYPE_FPROUNDING_MODE,
+    SPIRV_PARSER_OPERAND_TYPE_FRAGMENT_SHADING_RATE,
+    SPIRV_PARSER_OPERAND_TYPE_FUNCTION_CONTROL,
+    SPIRV_PARSER_OPERAND_TYPE_FUNCTION_PARAMETER_ATTRIBUTE,
+    SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION,
+    SPIRV_PARSER_OPERAND_TYPE_HOST_ACCESS_QUALIFIER,
+    SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS,
+    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+    SPIRV_PARSER_OPERAND_TYPE_ID_RESULT,
+    SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE,
+    SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE,
+    SPIRV_PARSER_OPERAND_TYPE_IMAGE_CHANNEL_DATA_TYPE,
+    SPIRV_PARSER_OPERAND_TYPE_IMAGE_CHANNEL_ORDER,
+    SPIRV_PARSER_OPERAND_TYPE_IMAGE_FORMAT,
+    SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS,
+    SPIRV_PARSER_OPERAND_TYPE_INITIALIZATION_MODE_QUALIFIER,
+    SPIRV_PARSER_OPERAND_TYPE_KERNEL_ENQUEUE_FLAGS,
+    SPIRV_PARSER_OPERAND_TYPE_KERNEL_PROFILING_INFO,
+    SPIRV_PARSER_OPERAND_TYPE_LINKAGE_TYPE,
+    SPIRV_PARSER_OPERAND_TYPE_LITERAL_CONTEXT_DEPENDENT_NUMBER,
+    SPIRV_PARSER_OPERAND_TYPE_LITERAL_EXT_INST_INTEGER,
+    SPIRV_PARSER_OPERAND_TYPE_LITERAL_FLOAT,
+    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+    SPIRV_PARSER_OPERAND_TYPE_LITERAL_SPEC_CONSTANT_OP_INTEGER,
+    SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING,
+    SPIRV_PARSER_OPERAND_TYPE_LOAD_CACHE_CONTROL,
+    SPIRV_PARSER_OPERAND_TYPE_LOOP_CONTROL,
+    SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS,
+    SPIRV_PARSER_OPERAND_TYPE_MEMORY_MODEL,
+    SPIRV_PARSER_OPERAND_TYPE_MEMORY_SEMANTICS,
+    SPIRV_PARSER_OPERAND_TYPE_NAMED_MAXIMUM_NUMBER_OF_REGISTERS,
+    SPIRV_PARSER_OPERAND_TYPE_OVERFLOW_MODES,
+    SPIRV_PARSER_OPERAND_TYPE_PACKED_VECTOR_FORMAT,
+    SPIRV_PARSER_OPERAND_TYPE_PAIR_ID_REF_ID_REF,
+    SPIRV_PARSER_OPERAND_TYPE_PAIR_ID_REF_LITERAL_INTEGER,
+    SPIRV_PARSER_OPERAND_TYPE_PAIR_LITERAL_INTEGER_ID_REF,
+    SPIRV_PARSER_OPERAND_TYPE_QUANTIZATION_MODES,
+    SPIRV_PARSER_OPERAND_TYPE_RAW_ACCESS_CHAIN_OPERANDS,
+    SPIRV_PARSER_OPERAND_TYPE_RAY_FLAGS,
+    SPIRV_PARSER_OPERAND_TYPE_RAY_QUERY_CANDIDATE_INTERSECTION_TYPE,
+    SPIRV_PARSER_OPERAND_TYPE_RAY_QUERY_COMMITTED_INTERSECTION_TYPE,
+    SPIRV_PARSER_OPERAND_TYPE_RAY_QUERY_INTERSECTION,
+    SPIRV_PARSER_OPERAND_TYPE_SAMPLER_ADDRESSING_MODE,
+    SPIRV_PARSER_OPERAND_TYPE_SAMPLER_FILTER_MODE,
+    SPIRV_PARSER_OPERAND_TYPE_SCOPE,
+    SPIRV_PARSER_OPERAND_TYPE_SELECTION_CONTROL,
+    SPIRV_PARSER_OPERAND_TYPE_SOURCE_LANGUAGE,
+    SPIRV_PARSER_OPERAND_TYPE_STORAGE_CLASS,
+    SPIRV_PARSER_OPERAND_TYPE_STORE_CACHE_CONTROL,
+    SPIRV_PARSER_OPERAND_TYPE_TENSOR_ADDRESSING_OPERANDS,
+    SPIRV_PARSER_OPERAND_TYPE_TENSOR_CLAMP_MODE,
+};
+
+static const struct spirv_parser_operand_type_info
+{
+    const char *name;
+    enum spirv_parser_operand_category category;
+    size_t enumerant_count;
+    const struct spirv_parser_enumerant
+    {
+        uint32_t value;
+        const char *name;
+        size_t parameter_count;
+        enum spirv_parser_operand_type *parameters;
+    } *enumerants;
+}
+spirv_parser_operand_type_info[] =
+{
+    [SPIRV_PARSER_OPERAND_TYPE_ACCESS_QUALIFIER] =
+    {
+        "AccessQualifier", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 3,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "ReadOnly"},
+            {0x1, "WriteOnly"},
+            {0x2, "ReadWrite"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_ADDRESSING_MODEL] =
+    {
+        "AddressingModel", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 4,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Logical"},
+            {0x1, "Physical32"},
+            {0x2, "Physical64"},
+            {0x14e4, "PhysicalStorageBuffer64"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_BUILT_IN] =
+    {
+        "BuiltIn", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 116,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Position"},
+            {0x1, "PointSize"},
+            {0x3, "ClipDistance"},
+            {0x4, "CullDistance"},
+            {0x5, "VertexId"},
+            {0x6, "InstanceId"},
+            {0x7, "PrimitiveId"},
+            {0x8, "InvocationId"},
+            {0x9, "Layer"},
+            {0xa, "ViewportIndex"},
+            {0xb, "TessLevelOuter"},
+            {0xc, "TessLevelInner"},
+            {0xd, "TessCoord"},
+            {0xe, "PatchVertices"},
+            {0xf, "FragCoord"},
+            {0x10, "PointCoord"},
+            {0x11, "FrontFacing"},
+            {0x12, "SampleId"},
+            {0x13, "SamplePosition"},
+            {0x14, "SampleMask"},
+            {0x16, "FragDepth"},
+            {0x17, "HelperInvocation"},
+            {0x18, "NumWorkgroups"},
+            {0x19, "WorkgroupSize"},
+            {0x1a, "WorkgroupId"},
+            {0x1b, "LocalInvocationId"},
+            {0x1c, "GlobalInvocationId"},
+            {0x1d, "LocalInvocationIndex"},
+            {0x1e, "WorkDim"},
+            {0x1f, "GlobalSize"},
+            {0x20, "EnqueuedWorkgroupSize"},
+            {0x21, "GlobalOffset"},
+            {0x22, "GlobalLinearId"},
+            {0x24, "SubgroupSize"},
+            {0x25, "SubgroupMaxSize"},
+            {0x26, "NumSubgroups"},
+            {0x27, "NumEnqueuedSubgroups"},
+            {0x28, "SubgroupId"},
+            {0x29, "SubgroupLocalInvocationId"},
+            {0x2a, "VertexIndex"},
+            {0x2b, "InstanceIndex"},
+            {0x1040, "CoreIDARM"},
+            {0x1041, "CoreCountARM"},
+            {0x1042, "CoreMaxIDARM"},
+            {0x1043, "WarpIDARM"},
+            {0x1044, "WarpMaxIDARM"},
+            {0x1140, "SubgroupEqMask"},
+            {0x1141, "SubgroupGeMask"},
+            {0x1142, "SubgroupGtMask"},
+            {0x1143, "SubgroupLeMask"},
+            {0x1144, "SubgroupLtMask"},
+            {0x1148, "BaseVertex"},
+            {0x1149, "BaseInstance"},
+            {0x114a, "DrawIndex"},
+            {0x1150, "PrimitiveShadingRateKHR"},
+            {0x1156, "DeviceIndex"},
+            {0x1158, "ViewIndex"},
+            {0x115c, "ShadingRateKHR"},
+            {0x1380, "BaryCoordNoPerspAMD"},
+            {0x1381, "BaryCoordNoPerspCentroidAMD"},
+            {0x1382, "BaryCoordNoPerspSampleAMD"},
+            {0x1383, "BaryCoordSmoothAMD"},
+            {0x1384, "BaryCoordSmoothCentroidAMD"},
+            {0x1385, "BaryCoordSmoothSampleAMD"},
+            {0x1386, "BaryCoordPullModelAMD"},
+            {0x1396, "FragStencilRefEXT"},
+            {0x139d, "RemainingRecursionLevelsAMDX"},
+            {0x13d1, "ShaderIndexAMDX"},
+            {0x1485, "ViewportMaskNV"},
+            {0x1489, "SecondaryPositionNV"},
+            {0x148a, "SecondaryViewportMaskNV"},
+            {0x148d, "PositionPerViewNV"},
+            {0x148e, "ViewportMaskPerViewNV"},
+            {0x1490, "FullyCoveredEXT"},
+            {0x149a, "TaskCountNV"},
+            {0x149b, "PrimitiveCountNV"},
+            {0x149c, "PrimitiveIndicesNV"},
+            {0x149d, "ClipDistancePerViewNV"},
+            {0x149e, "CullDistancePerViewNV"},
+            {0x149f, "LayerPerViewNV"},
+            {0x14a0, "MeshViewCountNV"},
+            {0x14a1, "MeshViewIndicesNV"},
+            {0x14a6, "BaryCoordKHR"},
+            {0x14a7, "BaryCoordNoPerspKHR"},
+            {0x14ac, "FragSizeEXT"},
+            {0x14ad, "FragInvocationCountEXT"},
+            {0x14ae, "PrimitivePointIndicesEXT"},
+            {0x14af, "PrimitiveLineIndicesEXT"},
+            {0x14b0, "PrimitiveTriangleIndicesEXT"},
+            {0x14b3, "CullPrimitiveEXT"},
+            {0x14c7, "LaunchIdKHR"},
+            {0x14c8, "LaunchSizeKHR"},
+            {0x14c9, "WorldRayOriginKHR"},
+            {0x14ca, "WorldRayDirectionKHR"},
+            {0x14cb, "ObjectRayOriginKHR"},
+            {0x14cc, "ObjectRayDirectionKHR"},
+            {0x14cd, "RayTminKHR"},
+            {0x14ce, "RayTmaxKHR"},
+            {0x14cf, "InstanceCustomIndexKHR"},
+            {0x14d2, "ObjectToWorldKHR"},
+            {0x14d3, "WorldToObjectKHR"},
+            {0x14d4, "HitTNV"},
+            {0x14d5, "HitKindKHR"},
+            {0x14d6, "CurrentRayTimeNV"},
+            {0x14d7, "HitTriangleVertexPositionsKHR"},
+            {0x14d9, "HitMicroTriangleVertexPositionsNV"},
+            {0x14e0, "HitMicroTriangleVertexBarycentricsNV"},
+            {0x14e7, "IncomingRayFlagsKHR"},
+            {0x14e8, "RayGeometryIndexKHR"},
+            {0x14fe, "WarpsPerSMNV"},
+            {0x14ff, "SMCountNV"},
+            {0x1500, "WarpIDNV"},
+            {0x1501, "SMIDNV"},
+            {0x151d, "HitKindFrontFacingMicroTriangleNV"},
+            {0x151e, "HitKindBackFacingMicroTriangleNV"},
+            {0x1785, "CullMaskKHR"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_CAPABILITY] =
+    {
+        "Capability", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 245,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Matrix"},
+            {0x1, "Shader"},
+            {0x2, "Geometry"},
+            {0x3, "Tessellation"},
+            {0x4, "Addresses"},
+            {0x5, "Linkage"},
+            {0x6, "Kernel"},
+            {0x7, "Vector16"},
+            {0x8, "Float16Buffer"},
+            {0x9, "Float16"},
+            {0xa, "Float64"},
+            {0xb, "Int64"},
+            {0xc, "Int64Atomics"},
+            {0xd, "ImageBasic"},
+            {0xe, "ImageReadWrite"},
+            {0xf, "ImageMipmap"},
+            {0x11, "Pipes"},
+            {0x12, "Groups"},
+            {0x13, "DeviceEnqueue"},
+            {0x14, "LiteralSampler"},
+            {0x15, "AtomicStorage"},
+            {0x16, "Int16"},
+            {0x17, "TessellationPointSize"},
+            {0x18, "GeometryPointSize"},
+            {0x19, "ImageGatherExtended"},
+            {0x1b, "StorageImageMultisample"},
+            {0x1c, "UniformBufferArrayDynamicIndexing"},
+            {0x1d, "SampledImageArrayDynamicIndexing"},
+            {0x1e, "StorageBufferArrayDynamicIndexing"},
+            {0x1f, "StorageImageArrayDynamicIndexing"},
+            {0x20, "ClipDistance"},
+            {0x21, "CullDistance"},
+            {0x22, "ImageCubeArray"},
+            {0x23, "SampleRateShading"},
+            {0x24, "ImageRect"},
+            {0x25, "SampledRect"},
+            {0x26, "GenericPointer"},
+            {0x27, "Int8"},
+            {0x28, "InputAttachment"},
+            {0x29, "SparseResidency"},
+            {0x2a, "MinLod"},
+            {0x2b, "Sampled1D"},
+            {0x2c, "Image1D"},
+            {0x2d, "SampledCubeArray"},
+            {0x2e, "SampledBuffer"},
+            {0x2f, "ImageBuffer"},
+            {0x30, "ImageMSArray"},
+            {0x31, "StorageImageExtendedFormats"},
+            {0x32, "ImageQuery"},
+            {0x33, "DerivativeControl"},
+            {0x34, "InterpolationFunction"},
+            {0x35, "TransformFeedback"},
+            {0x36, "GeometryStreams"},
+            {0x37, "StorageImageReadWithoutFormat"},
+            {0x38, "StorageImageWriteWithoutFormat"},
+            {0x39, "MultiViewport"},
+            {0x3a, "SubgroupDispatch"},
+            {0x3b, "NamedBarrier"},
+            {0x3c, "PipeStorage"},
+            {0x3d, "GroupNonUniform"},
+            {0x3e, "GroupNonUniformVote"},
+            {0x3f, "GroupNonUniformArithmetic"},
+            {0x40, "GroupNonUniformBallot"},
+            {0x41, "GroupNonUniformShuffle"},
+            {0x42, "GroupNonUniformShuffleRelative"},
+            {0x43, "GroupNonUniformClustered"},
+            {0x44, "GroupNonUniformQuad"},
+            {0x45, "ShaderLayer"},
+            {0x46, "ShaderViewportIndex"},
+            {0x47, "UniformDecoration"},
+            {0x1045, "CoreBuiltinsARM"},
+            {0x1046, "TileImageColorReadAccessEXT"},
+            {0x1047, "TileImageDepthReadAccessEXT"},
+            {0x1048, "TileImageStencilReadAccessEXT"},
+            {0x1069, "CooperativeMatrixLayoutsARM"},
+            {0x1146, "FragmentShadingRateKHR"},
+            {0x1147, "SubgroupBallotKHR"},
+            {0x114b, "DrawParameters"},
+            {0x114c, "WorkgroupMemoryExplicitLayoutKHR"},
+            {0x114d, "WorkgroupMemoryExplicitLayout8BitAccessKHR"},
+            {0x114e, "WorkgroupMemoryExplicitLayout16BitAccessKHR"},
+            {0x114f, "SubgroupVoteKHR"},
+            {0x1151, "StorageBuffer16BitAccess"},
+            {0x1152, "UniformAndStorageBuffer16BitAccess"},
+            {0x1153, "StoragePushConstant16"},
+            {0x1154, "StorageInputOutput16"},
+            {0x1155, "DeviceGroup"},
+            {0x1157, "MultiView"},
+            {0x1159, "VariablePointersStorageBuffer"},
+            {0x115a, "VariablePointers"},
+            {0x115d, "AtomicStorageOps"},
+            {0x115f, "SampleMaskPostDepthCoverage"},
+            {0x1160, "StorageBuffer8BitAccess"},
+            {0x1161, "UniformAndStorageBuffer8BitAccess"},
+            {0x1162, "StoragePushConstant8"},
+            {0x1170, "DenormPreserve"},
+            {0x1171, "DenormFlushToZero"},
+            {0x1172, "SignedZeroInfNanPreserve"},
+            {0x1173, "RoundingModeRTE"},
+            {0x1174, "RoundingModeRTZ"},
+            {0x1177, "RayQueryProvisionalKHR"},
+            {0x1178, "RayQueryKHR"},
+            {0x1179, "UntypedPointersKHR"},
+            {0x117e, "RayTraversalPrimitiveCullingKHR"},
+            {0x117f, "RayTracingKHR"},
+            {0x1184, "TextureSampleWeightedQCOM"},
+            {0x1185, "TextureBoxFilterQCOM"},
+            {0x1186, "TextureBlockMatchQCOM"},
+            {0x1192, "TextureBlockMatch2QCOM"},
+            {0x1390, "Float16ImageAMD"},
+            {0x1391, "ImageGatherBiasLodAMD"},
+            {0x1392, "FragmentMaskAMD"},
+            {0x1395, "StencilExportEXT"},
+            {0x1397, "ImageReadWriteLodAMD"},
+            {0x1398, "Int64ImageEXT"},
+            {0x13bf, "ShaderClockKHR"},
+            {0x13cb, "ShaderEnqueueAMDX"},
+            {0x13df, "QuadControlKHR"},
+            {0x1481, "SampleMaskOverrideCoverageNV"},
+            {0x1483, "GeometryShaderPassthroughNV"},
+            {0x1486, "ShaderViewportIndexLayerEXT"},
+            {0x1487, "ShaderViewportMaskNV"},
+            {0x148b, "ShaderStereoViewNV"},
+            {0x148c, "PerViewAttributesNV"},
+            {0x1491, "FragmentFullyCoveredEXT"},
+            {0x1492, "MeshShadingNV"},
+            {0x14a2, "ImageFootprintNV"},
+            {0x14a3, "MeshShadingEXT"},
+            {0x14a4, "FragmentBarycentricKHR"},
+            {0x14a8, "ComputeDerivativeGroupQuadsKHR"},
+            {0x14ab, "FragmentDensityEXT"},
+            {0x14b1, "GroupNonUniformPartitionedNV"},
+            {0x14b5, "ShaderNonUniform"},
+            {0x14b6, "RuntimeDescriptorArray"},
+            {0x14b7, "InputAttachmentArrayDynamicIndexing"},
+            {0x14b8, "UniformTexelBufferArrayDynamicIndexing"},
+            {0x14b9, "StorageTexelBufferArrayDynamicIndexing"},
+            {0x14ba, "UniformBufferArrayNonUniformIndexing"},
+            {0x14bb, "SampledImageArrayNonUniformIndexing"},
+            {0x14bc, "StorageBufferArrayNonUniformIndexing"},
+            {0x14bd, "StorageImageArrayNonUniformIndexing"},
+            {0x14be, "InputAttachmentArrayNonUniformIndexing"},
+            {0x14bf, "UniformTexelBufferArrayNonUniformIndexing"},
+            {0x14c0, "StorageTexelBufferArrayNonUniformIndexing"},
+            {0x14d8, "RayTracingPositionFetchKHR"},
+            {0x14dc, "RayTracingNV"},
+            {0x14dd, "RayTracingMotionBlurNV"},
+            {0x14e1, "VulkanMemoryModel"},
+            {0x14e2, "VulkanMemoryModelDeviceScope"},
+            {0x14e3, "PhysicalStorageBufferAddresses"},
+            {0x14e6, "ComputeDerivativeGroupLinearKHR"},
+            {0x14e9, "RayTracingProvisionalKHR"},
+            {0x14ed, "CooperativeMatrixNV"},
+            {0x14f3, "FragmentShaderSampleInterlockEXT"},
+            {0x14fc, "FragmentShaderShadingRateInterlockEXT"},
+            {0x14fd, "ShaderSMBuiltinsNV"},
+            {0x1502, "FragmentShaderPixelInterlockEXT"},
+            {0x1503, "DemoteToHelperInvocation"},
+            {0x1504, "DisplacementMicromapNV"},
+            {0x1505, "RayTracingOpacityMicromapEXT"},
+            {0x1507, "ShaderInvocationReorderNV"},
+            {0x150e, "BindlessTextureNV"},
+            {0x150f, "RayQueryPositionFetchKHR"},
+            {0x151c, "AtomicFloat16VectorNV"},
+            {0x1521, "RayTracingDisplacementMicromapNV"},
+            {0x1526, "RawAccessChainsNV"},
+            {0x1536, "CooperativeMatrixReductionsNV"},
+            {0x1537, "CooperativeMatrixConversionsNV"},
+            {0x1538, "CooperativeMatrixPerElementOperationsNV"},
+            {0x1539, "CooperativeMatrixTensorAddressingNV"},
+            {0x153a, "CooperativeMatrixBlockLoadsNV"},
+            {0x153f, "TensorAddressingNV"},
+            {0x15c0, "SubgroupShuffleINTEL"},
+            {0x15c1, "SubgroupBufferBlockIOINTEL"},
+            {0x15c2, "SubgroupImageBlockIOINTEL"},
+            {0x15cb, "SubgroupImageMediaBlockIOINTEL"},
+            {0x15ce, "RoundToInfinityINTEL"},
+            {0x15cf, "FloatingPointModeINTEL"},
+            {0x15d0, "IntegerFunctions2INTEL"},
+            {0x15e3, "FunctionPointersINTEL"},
+            {0x15e4, "IndirectReferencesINTEL"},
+            {0x15e6, "AsmINTEL"},
+            {0x15ec, "AtomicFloat32MinMaxEXT"},
+            {0x15ed, "AtomicFloat64MinMaxEXT"},
+            {0x15f0, "AtomicFloat16MinMaxEXT"},
+            {0x15f1, "VectorComputeINTEL"},
+            {0x15f3, "VectorAnyINTEL"},
+            {0x15fd, "ExpectAssumeKHR"},
+            {0x1640, "SubgroupAvcMotionEstimationINTEL"},
+            {0x1641, "SubgroupAvcMotionEstimationIntraINTEL"},
+            {0x1642, "SubgroupAvcMotionEstimationChromaINTEL"},
+            {0x16b9, "VariableLengthArrayINTEL"},
+            {0x16bd, "FunctionFloatControlINTEL"},
+            {0x16c0, "FPGAMemoryAttributesINTEL"},
+            {0x16cd, "FPFastMathModeINTEL"},
+            {0x16d4, "ArbitraryPrecisionIntegersINTEL"},
+            {0x16d5, "ArbitraryPrecisionFloatingPointINTEL"},
+            {0x16fe, "UnstructuredLoopControlsINTEL"},
+            {0x1700, "FPGALoopControlsINTEL"},
+            {0x1704, "KernelAttributesINTEL"},
+            {0x1709, "FPGAKernelAttributesINTEL"},
+            {0x170a, "FPGAMemoryAccessesINTEL"},
+            {0x1710, "FPGAClusterAttributesINTEL"},
+            {0x1712, "LoopFuseINTEL"},
+            {0x1714, "FPGADSPControlINTEL"},
+            {0x1716, "MemoryAccessAliasingINTEL"},
+            {0x171c, "FPGAInvocationPipeliningAttributesINTEL"},
+            {0x1720, "FPGABufferLocationINTEL"},
+            {0x1722, "ArbitraryPrecisionFixedPointINTEL"},
+            {0x172f, "USMStorageClassesINTEL"},
+            {0x1733, "RuntimeAlignedAttributeINTEL"},
+            {0x1737, "IOPipesINTEL"},
+            {0x1739, "BlockingPipesINTEL"},
+            {0x173c, "FPGARegINTEL"},
+            {0x1780, "DotProductInputAll"},
+            {0x1781, "DotProductInput4x8Bit"},
+            {0x1782, "DotProductInput4x8BitPacked"},
+            {0x1783, "DotProduct"},
+            {0x1784, "RayCullMaskKHR"},
+            {0x1786, "CooperativeMatrixKHR"},
+            {0x1788, "ReplicatedCompositesEXT"},
+            {0x1789, "BitInstructions"},
+            {0x178a, "GroupNonUniformRotateKHR"},
+            {0x178d, "FloatControls2"},
+            {0x1791, "AtomicFloat32AddEXT"},
+            {0x1792, "AtomicFloat64AddEXT"},
+            {0x17c9, "LongCompositesINTEL"},
+            {0x17ce, "OptNoneEXT"},
+            {0x17cf, "AtomicFloat16AddEXT"},
+            {0x17e2, "DebugInfoModuleINTEL"},
+            {0x17e3, "BFloat16ConversionINTEL"},
+            {0x17fd, "SplitBarrierINTEL"},
+            {0x1800, "ArithmeticFenceEXT"},
+            {0x1806, "FPGAClusterAttributesV2INTEL"},
+            {0x1811, "FPGAKernelAttributesv2INTEL"},
+            {0x1819, "FPMaxErrorINTEL"},
+            {0x181b, "FPGALatencyControlINTEL"},
+            {0x181e, "FPGAArgumentInterfacesINTEL"},
+            {0x182b, "GlobalVariableHostAccessINTEL"},
+            {0x182d, "GlobalVariableFPGADecorationsINTEL"},
+            {0x184c, "SubgroupBufferPrefetchINTEL"},
+            {0x1900, "GroupUniformArithmeticKHR"},
+            {0x191b, "MaskedGatherScatterINTEL"},
+            {0x1929, "CacheControlsINTEL"},
+            {0x193c, "RegisterLimitsINTEL"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_LAYOUT] =
+    {
+        "CooperativeMatrixLayout", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 4,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "RowMajorKHR"},
+            {0x1, "ColumnMajorKHR"},
+            {0x106a, "RowBlockedInterleavedARM"},
+            {0x106b, "ColumnBlockedInterleavedARM"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_OPERANDS] =
+    {
+        "CooperativeMatrixOperands", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 6,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "NoneKHR"},
+            {0x1, "MatrixASignedComponentsKHR"},
+            {0x2, "MatrixBSignedComponentsKHR"},
+            {0x4, "MatrixCSignedComponentsKHR"},
+            {0x8, "MatrixResultSignedComponentsKHR"},
+            {0x10, "SaturatingAccumulationKHR"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_REDUCE] =
+    {
+        "CooperativeMatrixReduce", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 3,
+        (struct spirv_parser_enumerant[])
+        {
+            {0x1, "Row"},
+            {0x2, "Column"},
+            {0x4, "2x2"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_USE] =
+    {
+        "CooperativeMatrixUse", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 3,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "MatrixAKHR"},
+            {0x1, "MatrixBKHR"},
+            {0x2, "MatrixAccumulatorKHR"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_DECORATION] =
+    {
+        "Decoration", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 142,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "RelaxedPrecision"},
+            {
+                0x1, "SpecId", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x2, "Block"},
+            {0x3, "BufferBlock"},
+            {0x4, "RowMajor"},
+            {0x5, "ColMajor"},
+            {
+                0x6, "ArrayStride", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x7, "MatrixStride", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x8, "GLSLShared"},
+            {0x9, "GLSLPacked"},
+            {0xa, "CPacked"},
+            {
+                0xb, "BuiltIn", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_BUILT_IN,
+                }
+            },
+            {0xd, "NoPerspective"},
+            {0xe, "Flat"},
+            {0xf, "Patch"},
+            {0x10, "Centroid"},
+            {0x11, "Sample"},
+            {0x12, "Invariant"},
+            {0x13, "Restrict"},
+            {0x14, "Aliased"},
+            {0x15, "Volatile"},
+            {0x16, "Constant"},
+            {0x17, "Coherent"},
+            {0x18, "NonWritable"},
+            {0x19, "NonReadable"},
+            {0x1a, "Uniform"},
+            {
+                0x1b, "UniformId", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE,
+                }
+            },
+            {0x1c, "SaturatedConversion"},
+            {
+                0x1d, "Stream", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1e, "Location", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1f, "Component", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x20, "Index", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x21, "Binding", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x22, "DescriptorSet", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x23, "Offset", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x24, "XfbBuffer", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x25, "XfbStride", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x26, "FuncParamAttr", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_FUNCTION_PARAMETER_ATTRIBUTE,
+                }
+            },
+            {
+                0x27, "FPRoundingMode", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_FPROUNDING_MODE,
+                }
+            },
+            {
+                0x28, "FPFastMathMode", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_FPFAST_MATH_MODE,
+                }
+            },
+            {
+                0x29, "LinkageAttributes", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING,
+                    SPIRV_PARSER_OPERAND_TYPE_LINKAGE_TYPE,
+                }
+            },
+            {0x2a, "NoContraction"},
+            {
+                0x2b, "InputAttachmentIndex", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x2c, "Alignment", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x2d, "MaxByteOffset", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x2e, "AlignmentId", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x2f, "MaxByteOffsetId", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {0x1175, "NoSignedWrap"},
+            {0x1176, "NoUnsignedWrap"},
+            {0x1187, "WeightTextureQCOM"},
+            {0x1188, "BlockMatchTextureQCOM"},
+            {0x1193, "BlockMatchSamplerQCOM"},
+            {0x1387, "ExplicitInterpAMD"},
+            {
+                0x139b, "NodeSharesPayloadLimitsWithAMDX", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x139c, "NodeMaxPayloadsAMDX", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {0x13d6, "TrackFinishWritingAMDX"},
+            {
+                0x13e3, "PayloadNodeNameAMDX", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x13ea, "PayloadNodeBaseIndexAMDX", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {0x13eb, "PayloadNodeSparseArrayAMDX"},
+            {
+                0x13ec, "PayloadNodeArraySizeAMDX", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {0x13f1, "PayloadDispatchIndirectAMDX"},
+            {0x1480, "OverrideCoverageNV"},
+            {0x1482, "PassthroughNV"},
+            {0x1484, "ViewportRelativeNV"},
+            {
+                0x1488, "SecondaryViewportRelativeNV", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x1497, "PerPrimitiveEXT"},
+            {0x1498, "PerViewNV"},
+            {0x1499, "PerTaskNV"},
+            {0x14a5, "PerVertexKHR"},
+            {0x14b4, "NonUniform"},
+            {0x14eb, "RestrictPointer"},
+            {0x14ec, "AliasedPointer"},
+            {0x150a, "HitObjectShaderRecordBufferNV"},
+            {0x1516, "BindlessSamplerNV"},
+            {0x1517, "BindlessImageNV"},
+            {0x1518, "BoundSamplerNV"},
+            {0x1519, "BoundImageNV"},
+            {
+                0x15df, "SIMTCallINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x15e2, "ReferencedIndirectlyINTEL"},
+            {
+                0x15e7, "ClobberINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING,
+                }
+            },
+            {0x15e8, "SideEffectsINTEL"},
+            {0x15f8, "VectorComputeVariableINTEL"},
+            {
+                0x15f9, "FuncParamIOKindINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x15fa, "VectorComputeFunctionINTEL"},
+            {0x15fb, "StackCallINTEL"},
+            {
+                0x15fc, "GlobalVariableOffsetINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1602, "CounterBuffer", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x1603, "UserSemantic", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING,
+                }
+            },
+            {
+                0x1604, "UserTypeGOOGLE", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING,
+                }
+            },
+            {
+                0x16be, "FunctionRoundingModeINTEL", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_FPROUNDING_MODE,
+                }
+            },
+            {
+                0x16bf, "FunctionDenormModeINTEL", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_FPDENORM_MODE,
+                }
+            },
+            {0x16c1, "RegisterINTEL"},
+            {
+                0x16c2, "MemoryINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING,
+                }
+            },
+            {
+                0x16c3, "NumbanksINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x16c4, "BankwidthINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x16c5, "MaxPrivateCopiesINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x16c6, "SinglepumpINTEL"},
+            {0x16c7, "DoublepumpINTEL"},
+            {
+                0x16c8, "MaxReplicatesINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x16c9, "SimpleDualPortINTEL"},
+            {
+                0x16ca, "MergeINTEL", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING,
+                }
+            },
+            {
+                0x16cb, "BankBitsINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x16cc, "ForcePow2DepthINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x16fb, "StridesizeINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x16fc, "WordsizeINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x16fd, "TrueDualPortINTEL"},
+            {0x170b, "BurstCoalesceINTEL"},
+            {
+                0x170c, "CacheSizeINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x170d, "DontStaticallyCoalesceINTEL"},
+            {
+                0x170e, "PrefetchINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x1711, "StallEnableINTEL"},
+            {0x1713, "FuseLoopsInFunctionINTEL"},
+            {
+                0x1715, "MathOpDSPModeINTEL", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x171a, "AliasScopeINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x171b, "NoAliasINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x171d, "InitiationIntervalINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x171e, "MaxConcurrencyINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x171f, "PipelineEnableINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1721, "BufferLocationINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1738, "IOPipeStorageINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x17c0, "FunctionFloatingPointModeINTEL", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_FPOPERATION_MODE,
+                }
+            },
+            {0x17c5, "SingleElementVectorINTEL"},
+            {0x17c7, "VectorComputeCallableFunctionINTEL"},
+            {0x17fc, "MediaBlockIOINTEL"},
+            {0x1807, "StallFreeINTEL"},
+            {
+                0x181a, "FPMaxErrorDecorationINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_FLOAT,
+                }
+            },
+            {
+                0x181c, "LatencyControlLabelINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x181d, "LatencyControlConstraintINTEL", 3,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x181f, "ConduitKernelArgumentINTEL"},
+            {0x1820, "RegisterMapKernelArgumentINTEL"},
+            {
+                0x1821, "MMHostInterfaceAddressWidthINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1822, "MMHostInterfaceDataWidthINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1823, "MMHostInterfaceLatencyINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1824, "MMHostInterfaceReadWriteModeINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ACCESS_QUALIFIER,
+                }
+            },
+            {
+                0x1825, "MMHostInterfaceMaxBurstINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1826, "MMHostInterfaceWaitRequestINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x1827, "StableKernelArgumentINTEL"},
+            {
+                0x182c, "HostAccessINTEL", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_HOST_ACCESS_QUALIFIER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING,
+                }
+            },
+            {
+                0x182e, "InitModeINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_INITIALIZATION_MODE_QUALIFIER,
+                }
+            },
+            {
+                0x182f, "ImplementInRegisterMapINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x192a, "CacheControlLoadINTEL", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LOAD_CACHE_CONTROL,
+                }
+            },
+            {
+                0x192b, "CacheControlStoreINTEL", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_STORE_CACHE_CONTROL,
+                }
+            },
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_DIM] =
+    {
+        "Dim", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 8,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "1D"},
+            {0x1, "2D"},
+            {0x2, "3D"},
+            {0x3, "Cube"},
+            {0x4, "Rect"},
+            {0x5, "Buffer"},
+            {0x6, "SubpassData"},
+            {0x104d, "TileImageDataEXT"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_EXECUTION_MODE] =
+    {
+        "ExecutionMode", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 94,
+        (struct spirv_parser_enumerant[])
+        {
+            {
+                0, "Invocations", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x1, "SpacingEqual"},
+            {0x2, "SpacingFractionalEven"},
+            {0x3, "SpacingFractionalOdd"},
+            {0x4, "VertexOrderCw"},
+            {0x5, "VertexOrderCcw"},
+            {0x6, "PixelCenterInteger"},
+            {0x7, "OriginUpperLeft"},
+            {0x8, "OriginLowerLeft"},
+            {0x9, "EarlyFragmentTests"},
+            {0xa, "PointMode"},
+            {0xb, "Xfb"},
+            {0xc, "DepthReplacing"},
+            {0xe, "DepthGreater"},
+            {0xf, "DepthLess"},
+            {0x10, "DepthUnchanged"},
+            {
+                0x11, "LocalSize", 3,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x12, "LocalSizeHint", 3,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x13, "InputPoints"},
+            {0x14, "InputLines"},
+            {0x15, "InputLinesAdjacency"},
+            {0x16, "Triangles"},
+            {0x17, "InputTrianglesAdjacency"},
+            {0x18, "Quads"},
+            {0x19, "Isolines"},
+            {
+                0x1a, "OutputVertices", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x1b, "OutputPoints"},
+            {0x1c, "OutputLineStrip"},
+            {0x1d, "OutputTriangleStrip"},
+            {
+                0x1e, "VecTypeHint", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x1f, "ContractionOff"},
+            {0x21, "Initializer"},
+            {0x22, "Finalizer"},
+            {
+                0x23, "SubgroupSize", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x24, "SubgroupsPerWorkgroup", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x25, "SubgroupsPerWorkgroupId", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x26, "LocalSizeId", 3,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x27, "LocalSizeHintId", 3,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {0x1049, "NonCoherentColorAttachmentReadEXT"},
+            {0x104a, "NonCoherentDepthAttachmentReadEXT"},
+            {0x104b, "NonCoherentStencilAttachmentReadEXT"},
+            {0x1145, "SubgroupUniformControlFlowKHR"},
+            {0x115e, "PostDepthCoverage"},
+            {
+                0x116b, "DenormPreserve", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x116c, "DenormFlushToZero", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x116d, "SignedZeroInfNanPreserve", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x116e, "RoundingModeRTE", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x116f, "RoundingModeRTZ", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x1399, "EarlyAndLateFragmentTestsAMD"},
+            {0x13a3, "StencilRefReplacingEXT"},
+            {0x13cd, "CoalescingAMDX"},
+            {
+                0x13ce, "IsApiEntryAMDX", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x13cf, "MaxNodeRecursionAMDX", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x13d0, "StaticNumWorkgroupsAMDX", 3,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x13d1, "ShaderIndexAMDX", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x13d5, "MaxNumWorkgroupsAMDX", 3,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {0x13d7, "StencilRefUnchangedFrontAMD"},
+            {0x13d8, "StencilRefGreaterFrontAMD"},
+            {0x13d9, "StencilRefLessFrontAMD"},
+            {0x13da, "StencilRefUnchangedBackAMD"},
+            {0x13db, "StencilRefGreaterBackAMD"},
+            {0x13dc, "StencilRefLessBackAMD"},
+            {0x13e0, "QuadDerivativesKHR"},
+            {0x13e1, "RequireFullQuadsKHR"},
+            {
+                0x13ee, "SharesInputWithAMDX", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {0x1495, "OutputLinesEXT"},
+            {
+                0x1496, "OutputPrimitivesEXT", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x14a9, "DerivativeGroupQuadsKHR"},
+            {0x14aa, "DerivativeGroupLinearKHR"},
+            {0x14b2, "OutputTrianglesEXT"},
+            {0x14f6, "PixelInterlockOrderedEXT"},
+            {0x14f7, "PixelInterlockUnorderedEXT"},
+            {0x14f8, "SampleInterlockOrderedEXT"},
+            {0x14f9, "SampleInterlockUnorderedEXT"},
+            {0x14fa, "ShadingRateInterlockOrderedEXT"},
+            {0x14fb, "ShadingRateInterlockUnorderedEXT"},
+            {
+                0x15f2, "SharedLocalMemorySizeINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x15f4, "RoundingModeRTPINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x15f5, "RoundingModeRTNINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x15f6, "FloatingPointModeALTINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x15f7, "FloatingPointModeIEEEINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1705, "MaxWorkgroupSizeINTEL", 3,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1706, "MaxWorkDimINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x1707, "NoGlobalOffsetINTEL"},
+            {
+                0x1708, "NumSIMDWorkitemsINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x170f, "SchedulerTargetFmaxMhzINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x1787, "MaximallyReconvergesKHR"},
+            {
+                0x178c, "FPFastMathDefault", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x180a, "StreamingInterfaceINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1810, "RegisterMapInterfaceINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x1911, "NamedBarrierCountINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x193d, "MaximumRegistersINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x193e, "MaximumRegistersIdINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x193f, "NamedMaximumRegistersINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_NAMED_MAXIMUM_NUMBER_OF_REGISTERS,
+                }
+            },
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_EXECUTION_MODEL] =
+    {
+        "ExecutionModel", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 17,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Vertex"},
+            {0x1, "TessellationControl"},
+            {0x2, "TessellationEvaluation"},
+            {0x3, "Geometry"},
+            {0x4, "Fragment"},
+            {0x5, "GLCompute"},
+            {0x6, "Kernel"},
+            {0x1493, "TaskNV"},
+            {0x1494, "MeshNV"},
+            {0x14c1, "RayGenerationKHR"},
+            {0x14c2, "IntersectionKHR"},
+            {0x14c3, "AnyHitKHR"},
+            {0x14c4, "ClosestHitKHR"},
+            {0x14c5, "MissKHR"},
+            {0x14c6, "CallableKHR"},
+            {0x14f4, "TaskEXT"},
+            {0x14f5, "MeshEXT"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_FPDENORM_MODE] =
+    {
+        "FPDenormMode", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 2,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Preserve"},
+            {0x1, "FlushToZero"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_FPENCODING] =
+    {
+        "FPEncoding", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_FPFAST_MATH_MODE] =
+    {
+        "FPFastMathMode", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 9,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {0x1, "NotNaN"},
+            {0x2, "NotInf"},
+            {0x4, "NSZ"},
+            {0x8, "AllowRecip"},
+            {0x10, "Fast"},
+            {0x10000, "AllowContract"},
+            {0x20000, "AllowReassoc"},
+            {0x40000, "AllowTransform"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_FPOPERATION_MODE] =
+    {
+        "FPOperationMode", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 2,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "IEEE"},
+            {0x1, "ALT"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_FPROUNDING_MODE] =
+    {
+        "FPRoundingMode", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 4,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "RTE"},
+            {0x1, "RTZ"},
+            {0x2, "RTP"},
+            {0x3, "RTN"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_FRAGMENT_SHADING_RATE] =
+    {
+        "FragmentShadingRate", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 4,
+        (struct spirv_parser_enumerant[])
+        {
+            {0x1, "Vertical2Pixels"},
+            {0x2, "Vertical4Pixels"},
+            {0x4, "Horizontal2Pixels"},
+            {0x8, "Horizontal4Pixels"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_FUNCTION_CONTROL] =
+    {
+        "FunctionControl", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 6,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {0x1, "Inline"},
+            {0x2, "DontInline"},
+            {0x4, "Pure"},
+            {0x8, "Const"},
+            {0x10000, "OptNoneEXT"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_FUNCTION_PARAMETER_ATTRIBUTE] =
+    {
+        "FunctionParameterAttribute", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 9,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Zext"},
+            {0x1, "Sext"},
+            {0x2, "ByVal"},
+            {0x3, "Sret"},
+            {0x4, "NoAlias"},
+            {0x5, "NoCapture"},
+            {0x6, "NoWrite"},
+            {0x7, "NoReadWrite"},
+            {0x1734, "RuntimeAlignedINTEL"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION] =
+    {
+        "GroupOperation", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 7,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Reduce"},
+            {0x1, "InclusiveScan"},
+            {0x2, "ExclusiveScan"},
+            {0x3, "ClusteredReduce"},
+            {0x6, "PartitionedReduceNV"},
+            {0x7, "PartitionedInclusiveScanNV"},
+            {0x8, "PartitionedExclusiveScanNV"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_HOST_ACCESS_QUALIFIER] =
+    {
+        "HostAccessQualifier", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 4,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "NoneINTEL"},
+            {0x1, "ReadINTEL"},
+            {0x2, "WriteINTEL"},
+            {0x3, "ReadWriteINTEL"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS] =
+    {
+        "IdMemorySemantics", SPIRV_PARSER_OPERAND_CATEGORY_ID
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_ID_REF] =
+    {
+        "IdRef", SPIRV_PARSER_OPERAND_CATEGORY_ID
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_ID_RESULT] =
+    {
+        "IdResult", SPIRV_PARSER_OPERAND_CATEGORY_ID
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE] =
+    {
+        "IdResultType", SPIRV_PARSER_OPERAND_CATEGORY_ID
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE] =
+    {
+        "IdScope", SPIRV_PARSER_OPERAND_CATEGORY_ID
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_IMAGE_CHANNEL_DATA_TYPE] =
+    {
+        "ImageChannelDataType", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 20,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "SnormInt8"},
+            {0x1, "SnormInt16"},
+            {0x2, "UnormInt8"},
+            {0x3, "UnormInt16"},
+            {0x4, "UnormShort565"},
+            {0x5, "UnormShort555"},
+            {0x6, "UnormInt101010"},
+            {0x7, "SignedInt8"},
+            {0x8, "SignedInt16"},
+            {0x9, "SignedInt32"},
+            {0xa, "UnsignedInt8"},
+            {0xb, "UnsignedInt16"},
+            {0xc, "UnsignedInt32"},
+            {0xd, "HalfFloat"},
+            {0xe, "Float"},
+            {0xf, "UnormInt24"},
+            {0x10, "UnormInt101010_2"},
+            {0x13, "UnsignedIntRaw10EXT"},
+            {0x14, "UnsignedIntRaw12EXT"},
+            {0x15, "UnormInt2_101010EXT"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_IMAGE_CHANNEL_ORDER] =
+    {
+        "ImageChannelOrder", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 20,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "R"},
+            {0x1, "A"},
+            {0x2, "RG"},
+            {0x3, "RA"},
+            {0x4, "RGB"},
+            {0x5, "RGBA"},
+            {0x6, "BGRA"},
+            {0x7, "ARGB"},
+            {0x8, "Intensity"},
+            {0x9, "Luminance"},
+            {0xa, "Rx"},
+            {0xb, "RGx"},
+            {0xc, "RGBx"},
+            {0xd, "Depth"},
+            {0xe, "DepthStencil"},
+            {0xf, "sRGB"},
+            {0x10, "sRGBx"},
+            {0x11, "sRGBA"},
+            {0x12, "sBGRA"},
+            {0x13, "ABGR"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_IMAGE_FORMAT] =
+    {
+        "ImageFormat", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 42,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Unknown"},
+            {0x1, "Rgba32f"},
+            {0x2, "Rgba16f"},
+            {0x3, "R32f"},
+            {0x4, "Rgba8"},
+            {0x5, "Rgba8Snorm"},
+            {0x6, "Rg32f"},
+            {0x7, "Rg16f"},
+            {0x8, "R11fG11fB10f"},
+            {0x9, "R16f"},
+            {0xa, "Rgba16"},
+            {0xb, "Rgb10A2"},
+            {0xc, "Rg16"},
+            {0xd, "Rg8"},
+            {0xe, "R16"},
+            {0xf, "R8"},
+            {0x10, "Rgba16Snorm"},
+            {0x11, "Rg16Snorm"},
+            {0x12, "Rg8Snorm"},
+            {0x13, "R16Snorm"},
+            {0x14, "R8Snorm"},
+            {0x15, "Rgba32i"},
+            {0x16, "Rgba16i"},
+            {0x17, "Rgba8i"},
+            {0x18, "R32i"},
+            {0x19, "Rg32i"},
+            {0x1a, "Rg16i"},
+            {0x1b, "Rg8i"},
+            {0x1c, "R16i"},
+            {0x1d, "R8i"},
+            {0x1e, "Rgba32ui"},
+            {0x1f, "Rgba16ui"},
+            {0x20, "Rgba8ui"},
+            {0x21, "R32ui"},
+            {0x22, "Rgb10a2ui"},
+            {0x23, "Rg32ui"},
+            {0x24, "Rg16ui"},
+            {0x25, "Rg8ui"},
+            {0x26, "R16ui"},
+            {0x27, "R8ui"},
+            {0x28, "R64ui"},
+            {0x29, "R64i"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS] =
+    {
+        "ImageOperands", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 17,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {
+                0x1, "Bias", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x2, "Lod", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x4, "Grad", 2,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x8, "ConstOffset", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x10, "Offset", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x20, "ConstOffsets", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x40, "Sample", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x80, "MinLod", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x100, "MakeTexelAvailable", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE,
+                }
+            },
+            {
+                0x200, "MakeTexelVisible", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE,
+                }
+            },
+            {0x400, "NonPrivateTexel"},
+            {0x800, "VolatileTexel"},
+            {0x1000, "SignExtend"},
+            {0x2000, "ZeroExtend"},
+            {0x4000, "Nontemporal"},
+            {
+                0x10000, "Offsets", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_INITIALIZATION_MODE_QUALIFIER] =
+    {
+        "InitializationModeQualifier", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 2,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "InitOnDeviceReprogramINTEL"},
+            {0x1, "InitOnDeviceResetINTEL"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_KERNEL_ENQUEUE_FLAGS] =
+    {
+        "KernelEnqueueFlags", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 3,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "NoWait"},
+            {0x1, "WaitKernel"},
+            {0x2, "WaitWorkGroup"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_KERNEL_PROFILING_INFO] =
+    {
+        "KernelProfilingInfo", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 2,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {0x1, "CmdExecTime"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_LINKAGE_TYPE] =
+    {
+        "LinkageType", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 3,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Export"},
+            {0x1, "Import"},
+            {0x2, "LinkOnceODR"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_LITERAL_CONTEXT_DEPENDENT_NUMBER] =
+    {
+        "LiteralContextDependentNumber", SPIRV_PARSER_OPERAND_CATEGORY_LITERAL
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_LITERAL_EXT_INST_INTEGER] =
+    {
+        "LiteralExtInstInteger", SPIRV_PARSER_OPERAND_CATEGORY_LITERAL
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_LITERAL_FLOAT] =
+    {
+        "LiteralFloat", SPIRV_PARSER_OPERAND_CATEGORY_LITERAL
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER] =
+    {
+        "LiteralInteger", SPIRV_PARSER_OPERAND_CATEGORY_LITERAL
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_LITERAL_SPEC_CONSTANT_OP_INTEGER] =
+    {
+        "LiteralSpecConstantOpInteger", SPIRV_PARSER_OPERAND_CATEGORY_LITERAL
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING] =
+    {
+        "LiteralString", SPIRV_PARSER_OPERAND_CATEGORY_LITERAL
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_LOAD_CACHE_CONTROL] =
+    {
+        "LoadCacheControl", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 5,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "UncachedINTEL"},
+            {0x1, "CachedINTEL"},
+            {0x2, "StreamingINTEL"},
+            {0x3, "InvalidateAfterReadINTEL"},
+            {0x4, "ConstCachedINTEL"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_LOOP_CONTROL] =
+    {
+        "LoopControl", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 20,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {0x1, "Unroll"},
+            {0x2, "DontUnroll"},
+            {0x4, "DependencyInfinite"},
+            {
+                0x8, "DependencyLength", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x10, "MinIterations", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x20, "MaxIterations", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x40, "IterationMultiple", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x80, "PeelCount", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x100, "PartialCount", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x10000, "InitiationIntervalINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x20000, "MaxConcurrencyINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x40000, "DependencyArrayINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x80000, "PipelineEnableINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x100000, "LoopCoalesceINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x200000, "MaxInterleavingINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x400000, "SpeculatedIterationsINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x800000, "NoFusionINTEL"},
+            {
+                0x1000000, "LoopCountINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {
+                0x2000000, "MaxReinvocationDelayINTEL", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS] =
+    {
+        "MemoryAccess", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 9,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {0x1, "Volatile"},
+            {
+                0x2, "Aligned", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER,
+                }
+            },
+            {0x4, "Nontemporal"},
+            {
+                0x8, "MakePointerAvailable", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE,
+                }
+            },
+            {
+                0x10, "MakePointerVisible", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE,
+                }
+            },
+            {0x20, "NonPrivatePointer"},
+            {
+                0x10000, "AliasScopeINTELMask", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x20000, "NoAliasINTELMask", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_MEMORY_MODEL] =
+    {
+        "MemoryModel", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 4,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Simple"},
+            {0x1, "GLSL450"},
+            {0x2, "OpenCL"},
+            {0x3, "Vulkan"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_MEMORY_SEMANTICS] =
+    {
+        "MemorySemantics", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 15,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Relaxed"},
+            {0x2, "Acquire"},
+            {0x4, "Release"},
+            {0x8, "AcquireRelease"},
+            {0x10, "SequentiallyConsistent"},
+            {0x40, "UniformMemory"},
+            {0x80, "SubgroupMemory"},
+            {0x100, "WorkgroupMemory"},
+            {0x200, "CrossWorkgroupMemory"},
+            {0x400, "AtomicCounterMemory"},
+            {0x800, "ImageMemory"},
+            {0x1000, "OutputMemory"},
+            {0x2000, "MakeAvailable"},
+            {0x4000, "MakeVisible"},
+            {0x8000, "Volatile"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_NAMED_MAXIMUM_NUMBER_OF_REGISTERS] =
+    {
+        "NamedMaximumNumberOfRegisters", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 1,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "AutoINTEL"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_OVERFLOW_MODES] =
+    {
+        "OverflowModes", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 4,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "WRAP"},
+            {0x1, "SAT"},
+            {0x2, "SAT_ZERO"},
+            {0x3, "SAT_SYM"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_PACKED_VECTOR_FORMAT] =
+    {
+        "PackedVectorFormat", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 1,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "PackedVectorFormat4x8Bit"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_PAIR_ID_REF_ID_REF] =
+    {
+        "PairIdRefIdRef", SPIRV_PARSER_OPERAND_CATEGORY_COMPOSITE
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_PAIR_ID_REF_LITERAL_INTEGER] =
+    {
+        "PairIdRefLiteralInteger", SPIRV_PARSER_OPERAND_CATEGORY_COMPOSITE
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_PAIR_LITERAL_INTEGER_ID_REF] =
+    {
+        "PairLiteralIntegerIdRef", SPIRV_PARSER_OPERAND_CATEGORY_COMPOSITE
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_QUANTIZATION_MODES] =
+    {
+        "QuantizationModes", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 8,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "TRN"},
+            {0x1, "TRN_ZERO"},
+            {0x2, "RND"},
+            {0x3, "RND_ZERO"},
+            {0x4, "RND_INF"},
+            {0x5, "RND_MIN_INF"},
+            {0x6, "RND_CONV"},
+            {0x7, "RND_CONV_ODD"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_RAW_ACCESS_CHAIN_OPERANDS] =
+    {
+        "RawAccessChainOperands", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 3,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {0x1, "RobustnessPerComponentNV"},
+            {0x2, "RobustnessPerElementNV"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_RAY_FLAGS] =
+    {
+        "RayFlags", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 12,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "NoneKHR"},
+            {0x1, "OpaqueKHR"},
+            {0x2, "NoOpaqueKHR"},
+            {0x4, "TerminateOnFirstHitKHR"},
+            {0x8, "SkipClosestHitShaderKHR"},
+            {0x10, "CullBackFacingTrianglesKHR"},
+            {0x20, "CullFrontFacingTrianglesKHR"},
+            {0x40, "CullOpaqueKHR"},
+            {0x80, "CullNoOpaqueKHR"},
+            {0x100, "SkipTrianglesKHR"},
+            {0x200, "SkipAABBsKHR"},
+            {0x400, "ForceOpacityMicromap2StateEXT"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_RAY_QUERY_CANDIDATE_INTERSECTION_TYPE] =
+    {
+        "RayQueryCandidateIntersectionType", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 2,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "RayQueryCandidateIntersectionTriangleKHR"},
+            {0x1, "RayQueryCandidateIntersectionAABBKHR"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_RAY_QUERY_COMMITTED_INTERSECTION_TYPE] =
+    {
+        "RayQueryCommittedIntersectionType", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 3,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "RayQueryCommittedIntersectionNoneKHR"},
+            {0x1, "RayQueryCommittedIntersectionTriangleKHR"},
+            {0x2, "RayQueryCommittedIntersectionGeneratedKHR"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_RAY_QUERY_INTERSECTION] =
+    {
+        "RayQueryIntersection", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 2,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "RayQueryCandidateIntersectionKHR"},
+            {0x1, "RayQueryCommittedIntersectionKHR"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_SAMPLER_ADDRESSING_MODE] =
+    {
+        "SamplerAddressingMode", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 5,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {0x1, "ClampToEdge"},
+            {0x2, "Clamp"},
+            {0x3, "Repeat"},
+            {0x4, "RepeatMirrored"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_SAMPLER_FILTER_MODE] =
+    {
+        "SamplerFilterMode", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 2,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Nearest"},
+            {0x1, "Linear"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_SCOPE] =
+    {
+        "Scope", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 7,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "CrossDevice"},
+            {0x1, "Device"},
+            {0x2, "Workgroup"},
+            {0x3, "Subgroup"},
+            {0x4, "Invocation"},
+            {0x5, "QueueFamily"},
+            {0x6, "ShaderCallKHR"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_SELECTION_CONTROL] =
+    {
+        "SelectionControl", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 3,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {0x1, "Flatten"},
+            {0x2, "DontFlatten"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_SOURCE_LANGUAGE] =
+    {
+        "SourceLanguage", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 13,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Unknown"},
+            {0x1, "ESSL"},
+            {0x2, "GLSL"},
+            {0x3, "OpenCL_C"},
+            {0x4, "OpenCL_CPP"},
+            {0x5, "HLSL"},
+            {0x6, "CPP_for_OpenCL"},
+            {0x7, "SYCL"},
+            {0x8, "HERO_C"},
+            {0x9, "NZSL"},
+            {0xa, "WGSL"},
+            {0xb, "Slang"},
+            {0xc, "Zig"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_STORAGE_CLASS] =
+    {
+        "StorageClass", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 27,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "UniformConstant"},
+            {0x1, "Input"},
+            {0x2, "Uniform"},
+            {0x3, "Output"},
+            {0x4, "Workgroup"},
+            {0x5, "CrossWorkgroup"},
+            {0x6, "Private"},
+            {0x7, "Function"},
+            {0x8, "Generic"},
+            {0x9, "PushConstant"},
+            {0xa, "AtomicCounter"},
+            {0xb, "Image"},
+            {0xc, "StorageBuffer"},
+            {0x104c, "TileImageEXT"},
+            {0x13cc, "NodePayloadAMDX"},
+            {0x14d0, "CallableDataKHR"},
+            {0x14d1, "IncomingCallableDataKHR"},
+            {0x14da, "RayPayloadKHR"},
+            {0x14db, "HitAttributeKHR"},
+            {0x14de, "IncomingRayPayloadKHR"},
+            {0x14df, "ShaderRecordBufferKHR"},
+            {0x14e5, "PhysicalStorageBuffer"},
+            {0x1509, "HitObjectAttributeNV"},
+            {0x151a, "TaskPayloadWorkgroupEXT"},
+            {0x15e5, "CodeSectionINTEL"},
+            {0x1730, "DeviceOnlyINTEL"},
+            {0x1731, "HostOnlyINTEL"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_STORE_CACHE_CONTROL] =
+    {
+        "StoreCacheControl", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 4,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "UncachedINTEL"},
+            {0x1, "WriteThroughINTEL"},
+            {0x2, "WriteBackINTEL"},
+            {0x3, "StreamingINTEL"},
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_TENSOR_ADDRESSING_OPERANDS] =
+    {
+        "TensorAddressingOperands", SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM, 3,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "None"},
+            {
+                0x1, "TensorView", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+            {
+                0x2, "DecodeFunc", 1,
+                (enum spirv_parser_operand_type[])
+                {
+                    SPIRV_PARSER_OPERAND_TYPE_ID_REF,
+                }
+            },
+        }
+    },
+    [SPIRV_PARSER_OPERAND_TYPE_TENSOR_CLAMP_MODE] =
+    {
+        "TensorClampMode", SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM, 5,
+        (struct spirv_parser_enumerant[])
+        {
+            {0, "Undefined"},
+            {0x1, "Constant"},
+            {0x2, "ClampToEdge"},
+            {0x3, "Repeat"},
+            {0x4, "RepeatMirrored"},
+        }
+    },
+};
+
+static const struct spirv_parser_opcode_info
+{
+    uint16_t op;
+    const char *name;
+    size_t operand_count;
+    const struct spirv_parser_instruction_operand
+    {
+        enum spirv_parser_operand_type type;
+        char quantifier;
+    } *operands;
+}
+spirv_parser_opcode_info[] =
+{
+    {0x0000, "OpNop"},
+    {
+        0x0001, "OpUndef", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0002, "OpSourceContinued", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x0003, "OpSource", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_SOURCE_LANGUAGE},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING, '?'},
+        }
+    },
+    {
+        0x0004, "OpSourceExtension", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x0005, "OpName", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x0006, "OpMemberName", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x0007, "OpString", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x0008, "OpLine", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x000a, "OpExtension", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x000b, "OpExtInstImport", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x000c, "OpExtInst", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_EXT_INST_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x000e, "OpMemoryModel", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ADDRESSING_MODEL},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_MODEL},
+        }
+    },
+    {
+        0x000f, "OpEntryPoint", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_EXECUTION_MODEL},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x0010, "OpExecutionMode", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_EXECUTION_MODE},
+        }
+    },
+    {
+        0x0011, "OpCapability", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_CAPABILITY},
+        }
+    },
+    {
+        0x0013, "OpTypeVoid", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0014, "OpTypeBool", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0015, "OpTypeInt", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x0016, "OpTypeFloat", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_FPENCODING, '?'},
+        }
+    },
+    {
+        0x0017, "OpTypeVector", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x0018, "OpTypeMatrix", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x0019, "OpTypeImage", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_DIM},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_FORMAT},
+            {SPIRV_PARSER_OPERAND_TYPE_ACCESS_QUALIFIER, '?'},
+        }
+    },
+    {
+        0x001a, "OpTypeSampler", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x001b, "OpTypeSampledImage", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x001c, "OpTypeArray", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x001d, "OpTypeRuntimeArray", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x001e, "OpTypeStruct", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x001f, "OpTypeOpaque", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x0020, "OpTypePointer", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_STORAGE_CLASS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0021, "OpTypeFunction", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x0022, "OpTypeEvent", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0023, "OpTypeDeviceEvent", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0024, "OpTypeReserveId", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0025, "OpTypeQueue", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0026, "OpTypePipe", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ACCESS_QUALIFIER},
+        }
+    },
+    {
+        0x0027, "OpTypeForwardPointer", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_STORAGE_CLASS},
+        }
+    },
+    {
+        0x0029, "OpConstantTrue", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x002a, "OpConstantFalse", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x002b, "OpConstant", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_CONTEXT_DEPENDENT_NUMBER},
+        }
+    },
+    {
+        0x002c, "OpConstantComposite", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x002d, "OpConstantSampler", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_SAMPLER_ADDRESSING_MODE},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_SAMPLER_FILTER_MODE},
+        }
+    },
+    {
+        0x002e, "OpConstantNull", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0030, "OpSpecConstantTrue", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0031, "OpSpecConstantFalse", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0032, "OpSpecConstant", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_CONTEXT_DEPENDENT_NUMBER},
+        }
+    },
+    {
+        0x0033, "OpSpecConstantComposite", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x0034, "OpSpecConstantOp", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_SPEC_CONSTANT_OP_INTEGER},
+        }
+    },
+    {
+        0x0036, "OpFunction", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_FUNCTION_CONTROL},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0037, "OpFunctionParameter", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {0x0038, "OpFunctionEnd"},
+    {
+        0x0039, "OpFunctionCall", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x003b, "OpVariable", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_STORAGE_CLASS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x003c, "OpImageTexelPointer", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x003d, "OpLoad", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+        }
+    },
+    {
+        0x003e, "OpStore", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+        }
+    },
+    {
+        0x003f, "OpCopyMemory", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+        }
+    },
+    {
+        0x0040, "OpCopyMemorySized", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+        }
+    },
+    {
+        0x0041, "OpAccessChain", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x0042, "OpInBoundsAccessChain", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x0043, "OpPtrAccessChain", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x0044, "OpArrayLength", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x0045, "OpGenericPtrMemSemantics", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0046, "OpInBoundsPtrAccessChain", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x0047, "OpDecorate", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_DECORATION},
+        }
+    },
+    {
+        0x0048, "OpMemberDecorate", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_DECORATION},
+        }
+    },
+    {
+        0x0049, "OpDecorationGroup", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x004a, "OpGroupDecorate", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x004b, "OpGroupMemberDecorate", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_PAIR_ID_REF_LITERAL_INTEGER, '*'},
+        }
+    },
+    {
+        0x004d, "OpVectorExtractDynamic", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x004e, "OpVectorInsertDynamic", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x004f, "OpVectorShuffle", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER, '*'},
+        }
+    },
+    {
+        0x0050, "OpCompositeConstruct", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x0051, "OpCompositeExtract", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER, '*'},
+        }
+    },
+    {
+        0x0052, "OpCompositeInsert", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER, '*'},
+        }
+    },
+    {
+        0x0053, "OpCopyObject", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0054, "OpTranspose", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0056, "OpSampledImage", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0057, "OpImageSampleImplicitLod", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0058, "OpImageSampleExplicitLod", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS},
+        }
+    },
+    {
+        0x0059, "OpImageSampleDrefImplicitLod", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x005a, "OpImageSampleDrefExplicitLod", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS},
+        }
+    },
+    {
+        0x005b, "OpImageSampleProjImplicitLod", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x005c, "OpImageSampleProjExplicitLod", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS},
+        }
+    },
+    {
+        0x005d, "OpImageSampleProjDrefImplicitLod", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x005e, "OpImageSampleProjDrefExplicitLod", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS},
+        }
+    },
+    {
+        0x005f, "OpImageFetch", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0060, "OpImageGather", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0061, "OpImageDrefGather", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0062, "OpImageRead", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0063, "OpImageWrite", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0064, "OpImage", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0065, "OpImageQueryFormat", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0066, "OpImageQueryOrder", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0067, "OpImageQuerySizeLod", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0068, "OpImageQuerySize", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0069, "OpImageQueryLod", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x006a, "OpImageQueryLevels", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x006b, "OpImageQuerySamples", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x006d, "OpConvertFToU", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x006e, "OpConvertFToS", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x006f, "OpConvertSToF", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0070, "OpConvertUToF", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0071, "OpUConvert", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0072, "OpSConvert", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0073, "OpFConvert", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0074, "OpQuantizeToF16", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0075, "OpConvertPtrToU", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0076, "OpSatConvertSToU", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0077, "OpSatConvertUToS", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0078, "OpConvertUToPtr", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0079, "OpPtrCastToGeneric", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x007a, "OpGenericCastToPtr", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x007b, "OpGenericCastToPtrExplicit", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_STORAGE_CLASS},
+        }
+    },
+    {
+        0x007c, "OpBitcast", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x007e, "OpSNegate", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x007f, "OpFNegate", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0080, "OpIAdd", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0081, "OpFAdd", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0082, "OpISub", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0083, "OpFSub", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0084, "OpIMul", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0085, "OpFMul", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0086, "OpUDiv", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0087, "OpSDiv", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0088, "OpFDiv", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0089, "OpUMod", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x008a, "OpSRem", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x008b, "OpSMod", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x008c, "OpFRem", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x008d, "OpFMod", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x008e, "OpVectorTimesScalar", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x008f, "OpMatrixTimesScalar", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0090, "OpVectorTimesMatrix", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0091, "OpMatrixTimesVector", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0092, "OpMatrixTimesMatrix", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0093, "OpOuterProduct", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0094, "OpDot", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0095, "OpIAddCarry", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0096, "OpISubBorrow", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0097, "OpUMulExtended", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0098, "OpSMulExtended", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x009a, "OpAny", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x009b, "OpAll", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x009c, "OpIsNan", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x009d, "OpIsInf", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x009e, "OpIsFinite", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x009f, "OpIsNormal", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a0, "OpSignBitSet", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a1, "OpLessOrGreater", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a2, "OpOrdered", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a3, "OpUnordered", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a4, "OpLogicalEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a5, "OpLogicalNotEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a6, "OpLogicalOr", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a7, "OpLogicalAnd", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a8, "OpLogicalNot", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00a9, "OpSelect", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00aa, "OpIEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ab, "OpINotEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ac, "OpUGreaterThan", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ad, "OpSGreaterThan", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ae, "OpUGreaterThanEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00af, "OpSGreaterThanEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b0, "OpULessThan", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b1, "OpSLessThan", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b2, "OpULessThanEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b3, "OpSLessThanEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b4, "OpFOrdEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b5, "OpFUnordEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b6, "OpFOrdNotEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b7, "OpFUnordNotEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b8, "OpFOrdLessThan", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00b9, "OpFUnordLessThan", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ba, "OpFOrdGreaterThan", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00bb, "OpFUnordGreaterThan", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00bc, "OpFOrdLessThanEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00bd, "OpFUnordLessThanEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00be, "OpFOrdGreaterThanEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00bf, "OpFUnordGreaterThanEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00c2, "OpShiftRightLogical", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00c3, "OpShiftRightArithmetic", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00c4, "OpShiftLeftLogical", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00c5, "OpBitwiseOr", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00c6, "OpBitwiseXor", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00c7, "OpBitwiseAnd", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00c8, "OpNot", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00c9, "OpBitFieldInsert", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ca, "OpBitFieldSExtract", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00cb, "OpBitFieldUExtract", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00cc, "OpBitReverse", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00cd, "OpBitCount", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00cf, "OpDPdx", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00d0, "OpDPdy", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00d1, "OpFwidth", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00d2, "OpDPdxFine", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00d3, "OpDPdyFine", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00d4, "OpFwidthFine", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00d5, "OpDPdxCoarse", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00d6, "OpDPdyCoarse", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00d7, "OpFwidthCoarse", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {0x00da, "OpEmitVertex"},
+    {0x00db, "OpEndPrimitive"},
+    {
+        0x00dc, "OpEmitStreamVertex", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00dd, "OpEndStreamPrimitive", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00e0, "OpControlBarrier", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x00e1, "OpMemoryBarrier", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x00e3, "OpAtomicLoad", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x00e4, "OpAtomicStore", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00e5, "OpAtomicExchange", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00e6, "OpAtomicCompareExchange", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00e7, "OpAtomicCompareExchangeWeak", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00e8, "OpAtomicIIncrement", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x00e9, "OpAtomicIDecrement", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x00ea, "OpAtomicIAdd", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00eb, "OpAtomicISub", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ec, "OpAtomicSMin", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ed, "OpAtomicUMin", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ee, "OpAtomicSMax", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00ef, "OpAtomicUMax", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00f0, "OpAtomicAnd", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00f1, "OpAtomicOr", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00f2, "OpAtomicXor", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00f5, "OpPhi", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_PAIR_ID_REF_ID_REF, '*'},
+        }
+    },
+    {
+        0x00f6, "OpLoopMerge", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LOOP_CONTROL},
+        }
+    },
+    {
+        0x00f7, "OpSelectionMerge", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_SELECTION_CONTROL},
+        }
+    },
+    {
+        0x00f8, "OpLabel", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x00f9, "OpBranch", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x00fa, "OpBranchConditional", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER, '*'},
+        }
+    },
+    {
+        0x00fb, "OpSwitch", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_PAIR_LITERAL_INTEGER_ID_REF, '*'},
+        }
+    },
+    {0x00fc, "OpKill"},
+    {0x00fd, "OpReturn"},
+    {
+        0x00fe, "OpReturnValue", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {0x00ff, "OpUnreachable"},
+    {
+        0x0100, "OpLifetimeStart", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x0101, "OpLifetimeStop", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x0103, "OpGroupAsyncCopy", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0104, "OpGroupWaitEvents", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0105, "OpGroupAll", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0106, "OpGroupAny", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0107, "OpGroupBroadcast", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0108, "OpGroupIAdd", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0109, "OpGroupFAdd", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x010a, "OpGroupFMin", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x010b, "OpGroupUMin", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x010c, "OpGroupSMin", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x010d, "OpGroupFMax", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x010e, "OpGroupUMax", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x010f, "OpGroupSMax", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0112, "OpReadPipe", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0113, "OpWritePipe", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0114, "OpReservedReadPipe", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0115, "OpReservedWritePipe", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0116, "OpReserveReadPipePackets", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0117, "OpReserveWritePipePackets", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0118, "OpCommitReadPipe", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0119, "OpCommitWritePipe", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x011a, "OpIsValidReserveId", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x011b, "OpGetNumPipePackets", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x011c, "OpGetMaxPipePackets", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x011d, "OpGroupReserveReadPipePackets", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x011e, "OpGroupReserveWritePipePackets", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x011f, "OpGroupCommitReadPipe", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0120, "OpGroupCommitWritePipe", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0123, "OpEnqueueMarker", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0124, "OpEnqueueKernel", 13,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x0125, "OpGetKernelNDrangeSubGroupCount", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0126, "OpGetKernelNDrangeMaxSubGroupSize", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0127, "OpGetKernelWorkGroupSize", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0128, "OpGetKernelPreferredWorkGroupSizeMultiple", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0129, "OpRetainEvent", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x012a, "OpReleaseEvent", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x012b, "OpCreateUserEvent", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x012c, "OpIsValidEvent", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x012d, "OpSetUserEventStatus", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x012e, "OpCaptureEventProfilingInfo", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x012f, "OpGetDefaultQueue", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0130, "OpBuildNDRange", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0131, "OpImageSparseSampleImplicitLod", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0132, "OpImageSparseSampleExplicitLod", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS},
+        }
+    },
+    {
+        0x0133, "OpImageSparseSampleDrefImplicitLod", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0134, "OpImageSparseSampleDrefExplicitLod", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS},
+        }
+    },
+    {
+        0x0135, "OpImageSparseSampleProjImplicitLod", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0136, "OpImageSparseSampleProjExplicitLod", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS},
+        }
+    },
+    {
+        0x0137, "OpImageSparseSampleProjDrefImplicitLod", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0138, "OpImageSparseSampleProjDrefExplicitLod", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS},
+        }
+    },
+    {
+        0x0139, "OpImageSparseFetch", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x013a, "OpImageSparseGather", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x013b, "OpImageSparseDrefGather", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x013c, "OpImageSparseTexelsResident", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {0x013d, "OpNoLine"},
+    {
+        0x013e, "OpAtomicFlagTestAndSet", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x013f, "OpAtomicFlagClear", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x0140, "OpImageSparseRead", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x0141, "OpSizeOf", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0142, "OpTypePipeStorage", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0143, "OpConstantPipeStorage", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x0144, "OpCreatePipeFromPipeStorage", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0145, "OpGetKernelLocalSizeForSubgroupCount", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0146, "OpGetKernelMaxNumSubgroups", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0147, "OpTypeNamedBarrier", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x0148, "OpNamedBarrierInitialize", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0149, "OpMemoryNamedBarrier", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x014a, "OpModuleProcessed", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x014b, "OpExecutionModeId", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_EXECUTION_MODE},
+        }
+    },
+    {
+        0x014c, "OpDecorateId", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_DECORATION},
+        }
+    },
+    {
+        0x014d, "OpGroupNonUniformElect", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+        }
+    },
+    {
+        0x014e, "OpGroupNonUniformAll", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x014f, "OpGroupNonUniformAny", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0150, "OpGroupNonUniformAllEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0151, "OpGroupNonUniformBroadcast", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0152, "OpGroupNonUniformBroadcastFirst", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0153, "OpGroupNonUniformBallot", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0154, "OpGroupNonUniformInverseBallot", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0155, "OpGroupNonUniformBallotBitExtract", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0156, "OpGroupNonUniformBallotBitCount", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0157, "OpGroupNonUniformBallotFindLSB", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0158, "OpGroupNonUniformBallotFindMSB", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0159, "OpGroupNonUniformShuffle", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x015a, "OpGroupNonUniformShuffleXor", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x015b, "OpGroupNonUniformShuffleUp", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x015c, "OpGroupNonUniformShuffleDown", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x015d, "OpGroupNonUniformIAdd", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x015e, "OpGroupNonUniformFAdd", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x015f, "OpGroupNonUniformIMul", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0160, "OpGroupNonUniformFMul", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0161, "OpGroupNonUniformSMin", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0162, "OpGroupNonUniformUMin", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0163, "OpGroupNonUniformFMin", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0164, "OpGroupNonUniformSMax", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0165, "OpGroupNonUniformUMax", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0166, "OpGroupNonUniformFMax", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0167, "OpGroupNonUniformBitwiseAnd", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0168, "OpGroupNonUniformBitwiseOr", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x0169, "OpGroupNonUniformBitwiseXor", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x016a, "OpGroupNonUniformLogicalAnd", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x016b, "OpGroupNonUniformLogicalOr", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x016c, "OpGroupNonUniformLogicalXor", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x016d, "OpGroupNonUniformQuadBroadcast", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x016e, "OpGroupNonUniformQuadSwap", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0190, "OpCopyLogical", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0191, "OpPtrEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0192, "OpPtrNotEqual", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x0193, "OpPtrDiff", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1040, "OpColorAttachmentReadEXT", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x1041, "OpDepthAttachmentReadEXT", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x1042, "OpStencilAttachmentReadEXT", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {0x1140, "OpTerminateInvocation"},
+    {
+        0x1141, "OpTypeUntypedPointerKHR", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_STORAGE_CLASS},
+        }
+    },
+    {
+        0x1142, "OpUntypedVariableKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_STORAGE_CLASS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x1143, "OpUntypedAccessChainKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x1144, "OpUntypedInBoundsAccessChainKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x1145, "OpSubgroupBallotKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1146, "OpSubgroupFirstInvocationKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1147, "OpUntypedPtrAccessChainKHR", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x1148, "OpUntypedInBoundsPtrAccessChainKHR", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x1149, "OpUntypedArrayLengthKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x114a, "OpUntypedPrefetchKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x114c, "OpSubgroupAllKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x114d, "OpSubgroupAnyKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x114e, "OpSubgroupAllEqualKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x114f, "OpGroupNonUniformRotateKHR", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x1150, "OpSubgroupReadInvocationKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1151, "OpExtInstWithForwardRefsKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_EXT_INST_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x115d, "OpTraceRayKHR", 11,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x115e, "OpExecuteCallableKHR", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x115f, "OpConvertUToAccelerationStructureKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {0x1160, "OpIgnoreIntersectionKHR"},
+    {0x1161, "OpTerminateRayKHR"},
+    {
+        0x1162, "OpSDot", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_PACKED_VECTOR_FORMAT, '?'},
+        }
+    },
+    {
+        0x1163, "OpUDot", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_PACKED_VECTOR_FORMAT, '?'},
+        }
+    },
+    {
+        0x1164, "OpSUDot", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_PACKED_VECTOR_FORMAT, '?'},
+        }
+    },
+    {
+        0x1165, "OpSDotAccSat", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_PACKED_VECTOR_FORMAT, '?'},
+        }
+    },
+    {
+        0x1166, "OpUDotAccSat", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_PACKED_VECTOR_FORMAT, '?'},
+        }
+    },
+    {
+        0x1167, "OpSUDotAccSat", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_PACKED_VECTOR_FORMAT, '?'},
+        }
+    },
+    {
+        0x1168, "OpTypeCooperativeMatrixKHR", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1169, "OpCooperativeMatrixLoadKHR", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+        }
+    },
+    {
+        0x116a, "OpCooperativeMatrixStoreKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+        }
+    },
+    {
+        0x116b, "OpCooperativeMatrixMulAddKHR", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_OPERANDS, '?'},
+        }
+    },
+    {
+        0x116c, "OpCooperativeMatrixLengthKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x116d, "OpConstantCompositeReplicateEXT", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x116e, "OpSpecConstantCompositeReplicateEXT", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x116f, "OpCompositeConstructReplicateEXT", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1178, "OpTypeRayQueryKHR", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1179, "OpRayQueryInitializeKHR", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x117a, "OpRayQueryTerminateKHR", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x117b, "OpRayQueryGenerateIntersectionKHR", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x117c, "OpRayQueryConfirmIntersectionKHR", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x117d, "OpRayQueryProceedKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x117f, "OpRayQueryGetIntersectionTypeKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1180, "OpImageSampleWeightedQCOM", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1181, "OpImageBoxFilterQCOM", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1182, "OpImageBlockMatchSSDQCOM", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1183, "OpImageBlockMatchSADQCOM", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1194, "OpImageBlockMatchWindowSSDQCOM", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1195, "OpImageBlockMatchWindowSADQCOM", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1196, "OpImageBlockMatchGatherSSDQCOM", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1197, "OpImageBlockMatchGatherSADQCOM", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1388, "OpGroupIAddNonUniformAMD", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1389, "OpGroupFAddNonUniformAMD", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x138a, "OpGroupFMinNonUniformAMD", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x138b, "OpGroupUMinNonUniformAMD", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x138c, "OpGroupSMinNonUniformAMD", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x138d, "OpGroupFMaxNonUniformAMD", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x138e, "OpGroupUMaxNonUniformAMD", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x138f, "OpGroupSMaxNonUniformAMD", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1393, "OpFragmentMaskFetchAMD", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1394, "OpFragmentFetchAMD", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x13c0, "OpReadClockKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+        }
+    },
+    {
+        0x13d2, "OpAllocateNodePayloadsAMDX", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x13d3, "OpEnqueueNodePayloadsAMDX", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x13d4, "OpTypeNodePayloadArrayAMDX", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x13d6, "OpFinishWritingNodePayloadAMDX", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x13e2, "OpNodePayloadArrayLengthAMDX", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x13ed, "OpIsNodePayloadValidAMDX", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x13ef, "OpConstantStringAMDX", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x13f0, "OpSpecConstantStringAMDX", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x13f6, "OpGroupNonUniformQuadAllKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x13f7, "OpGroupNonUniformQuadAnyKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1481, "OpHitObjectRecordHitMotionNV", 14,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1482, "OpHitObjectRecordHitWithIndexMotionNV", 13,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1483, "OpHitObjectRecordMissMotionNV", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1484, "OpHitObjectGetWorldToObjectNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1485, "OpHitObjectGetObjectToWorldNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1486, "OpHitObjectGetObjectRayDirectionNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1487, "OpHitObjectGetObjectRayOriginNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1488, "OpHitObjectTraceRayMotionNV", 13,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1489, "OpHitObjectGetShaderRecordBufferHandleNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x148a, "OpHitObjectGetShaderBindingTableRecordIndexNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x148b, "OpHitObjectRecordEmptyNV", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x148c, "OpHitObjectTraceRayNV", 12,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x148d, "OpHitObjectRecordHitNV", 13,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x148e, "OpHitObjectRecordHitWithIndexNV", 12,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x148f, "OpHitObjectRecordMissNV", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1490, "OpHitObjectExecuteShaderNV", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1491, "OpHitObjectGetCurrentTimeNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1492, "OpHitObjectGetAttributesNV", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1493, "OpHitObjectGetHitKindNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1494, "OpHitObjectGetPrimitiveIndexNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1495, "OpHitObjectGetGeometryIndexNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1496, "OpHitObjectGetInstanceIdNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1497, "OpHitObjectGetInstanceCustomIndexNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1498, "OpHitObjectGetWorldRayDirectionNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1499, "OpHitObjectGetWorldRayOriginNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x149a, "OpHitObjectGetRayTMaxNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x149b, "OpHitObjectGetRayTMinNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x149c, "OpHitObjectIsEmptyNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x149d, "OpHitObjectIsHitNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x149e, "OpHitObjectIsMissNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x149f, "OpReorderThreadWithHitObjectNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x14a0, "OpReorderThreadWithHintNV", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14a1, "OpTypeHitObjectNV", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x14a3, "OpImageSampleFootprintNV", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_IMAGE_OPERANDS, '?'},
+        }
+    },
+    {
+        0x14ad, "OpCooperativeMatrixConvertNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14ae, "OpEmitMeshTasksEXT", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x14af, "OpSetMeshOutputsEXT", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14b0, "OpGroupNonUniformPartitionNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14b3, "OpWritePackedPrimitiveIndices4x8NV", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14b4, "OpFetchMicroTriangleVertexPositionNV", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14b5, "OpFetchMicroTriangleVertexBarycentricNV", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14d6, "OpReportIntersectionKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {0x14d7, "OpIgnoreIntersectionNV"},
+    {0x14d8, "OpTerminateRayNV"},
+    {
+        0x14d9, "OpTraceNV", 11,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14da, "OpTraceMotionNV", 12,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14db, "OpTraceRayMotionNV", 12,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14dc, "OpRayQueryGetIntersectionTriangleVertexPositionsKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14dd, "OpTypeAccelerationStructureKHR", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x14e0, "OpExecuteCallableNV", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14ee, "OpTypeCooperativeMatrixNV", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14ef, "OpCooperativeMatrixLoadNV", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+        }
+    },
+    {
+        0x14f0, "OpCooperativeMatrixStoreNV", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+        }
+    },
+    {
+        0x14f1, "OpCooperativeMatrixMulAddNV", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14f2, "OpCooperativeMatrixLengthNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {0x14f4, "OpBeginInvocationInterlockEXT"},
+    {0x14f5, "OpEndInvocationInterlockEXT"},
+    {
+        0x14f6, "OpCooperativeMatrixReduceNV", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_COOPERATIVE_MATRIX_REDUCE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14f7, "OpCooperativeMatrixLoadTensorNV", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS},
+            {SPIRV_PARSER_OPERAND_TYPE_TENSOR_ADDRESSING_OPERANDS},
+        }
+    },
+    {
+        0x14f8, "OpCooperativeMatrixStoreTensorNV", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS},
+            {SPIRV_PARSER_OPERAND_TYPE_TENSOR_ADDRESSING_OPERANDS},
+        }
+    },
+    {
+        0x14f9, "OpCooperativeMatrixPerElementOpNV", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x14fa, "OpTypeTensorLayoutNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x14fb, "OpTypeTensorViewNV", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x14fc, "OpCreateTensorLayoutNV", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x14fd, "OpTensorLayoutSetDimensionNV", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x14fe, "OpTensorLayoutSetStrideNV", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x14ff, "OpTensorLayoutSliceNV", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x1500, "OpTensorLayoutSetClampValueNV", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1501, "OpCreateTensorViewNV", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1502, "OpTensorViewSetDimensionNV", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x1503, "OpTensorViewSetStrideNV", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {0x1504, "OpDemoteToHelperInvocation"},
+    {
+        0x1505, "OpIsHelperInvocationEXT", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1506, "OpTensorViewSetClipNV", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1508, "OpTensorLayoutSetBlockSizeNV", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x150e, "OpCooperativeMatrixTransposeNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x150f, "OpConvertUToImageNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1510, "OpConvertUToSamplerNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1511, "OpConvertImageToUNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1512, "OpConvertSamplerToUNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1513, "OpConvertUToSampledImageNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1514, "OpConvertSampledImageToUNV", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1515, "OpSamplerImageAddressingModeNV", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x1516, "OpRawAccessChainNV", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_RAW_ACCESS_CHAIN_OPERANDS, '?'},
+        }
+    },
+    {
+        0x15c3, "OpSubgroupShuffleINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15c4, "OpSubgroupShuffleDownINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15c5, "OpSubgroupShuffleUpINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15c6, "OpSubgroupShuffleXorINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15c7, "OpSubgroupBlockReadINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15c8, "OpSubgroupBlockWriteINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15c9, "OpSubgroupImageBlockReadINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15ca, "OpSubgroupImageBlockWriteINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15cc, "OpSubgroupImageMediaBlockReadINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15cd, "OpSubgroupImageMediaBlockWriteINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15d1, "OpUCountLeadingZerosINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15d2, "OpUCountTrailingZerosINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15d3, "OpAbsISubINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15d4, "OpAbsUSubINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15d5, "OpIAddSatINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15d6, "OpUAddSatINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15d7, "OpIAverageINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15d8, "OpUAverageINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15d9, "OpIAverageRoundedINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15da, "OpUAverageRoundedINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15db, "OpISubSatINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15dc, "OpUSubSatINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15dd, "OpIMul32x16INTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15de, "OpUMul32x16INTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15e0, "OpConstantFunctionPointerINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15e1, "OpFunctionPointerCallINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x15e9, "OpAsmTargetINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x15ea, "OpAsmINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING},
+        }
+    },
+    {
+        0x15eb, "OpAsmCallINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x15ee, "OpAtomicFMinEXT", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15ef, "OpAtomicFMaxEXT", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15fe, "OpAssumeTrueKHR", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x15ff, "OpExpectKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1600, "OpDecorateString", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_DECORATION},
+        }
+    },
+    {
+        0x1601, "OpMemberDecorateString", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_DECORATION},
+        }
+    },
+    {
+        0x1643, "OpVmeImageINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1644, "OpTypeVmeImageINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1645, "OpTypeAvcImePayloadINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1646, "OpTypeAvcRefPayloadINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1647, "OpTypeAvcSicPayloadINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1648, "OpTypeAvcMcePayloadINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1649, "OpTypeAvcMceResultINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x164a, "OpTypeAvcImeResultINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x164b, "OpTypeAvcImeResultSingleReferenceStreamoutINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x164c, "OpTypeAvcImeResultDualReferenceStreamoutINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x164d, "OpTypeAvcImeSingleReferenceStreaminINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x164e, "OpTypeAvcImeDualReferenceStreaminINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x164f, "OpTypeAvcRefResultINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1650, "OpTypeAvcSicResultINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1651, "OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1652, "OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1653, "OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1654, "OpSubgroupAvcMceSetInterShapePenaltyINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1655, "OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1656, "OpSubgroupAvcMceSetInterDirectionPenaltyINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1657, "OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1658, "OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1659, "OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x165a, "OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x165b, "OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x165c, "OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x165d, "OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x165e, "OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x165f, "OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x1660, "OpSubgroupAvcMceSetAcOnlyHaarINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1661, "OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1662, "OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1663, "OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1664, "OpSubgroupAvcMceConvertToImePayloadINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1665, "OpSubgroupAvcMceConvertToImeResultINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1666, "OpSubgroupAvcMceConvertToRefPayloadINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1667, "OpSubgroupAvcMceConvertToRefResultINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1668, "OpSubgroupAvcMceConvertToSicPayloadINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1669, "OpSubgroupAvcMceConvertToSicResultINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x166a, "OpSubgroupAvcMceGetMotionVectorsINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x166b, "OpSubgroupAvcMceGetInterDistortionsINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x166c, "OpSubgroupAvcMceGetBestInterDistortionsINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x166d, "OpSubgroupAvcMceGetInterMajorShapeINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x166e, "OpSubgroupAvcMceGetInterMinorShapeINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x166f, "OpSubgroupAvcMceGetInterDirectionsINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1670, "OpSubgroupAvcMceGetInterMotionVectorCountINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1671, "OpSubgroupAvcMceGetInterReferenceIdsINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1672, "OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1673, "OpSubgroupAvcImeInitializeINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1674, "OpSubgroupAvcImeSetSingleReferenceINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1675, "OpSubgroupAvcImeSetDualReferenceINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1676, "OpSubgroupAvcImeRefWindowSizeINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1677, "OpSubgroupAvcImeAdjustRefOffsetINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1678, "OpSubgroupAvcImeConvertToMcePayloadINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1679, "OpSubgroupAvcImeSetMaxMotionVectorCountINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x167a, "OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x167b, "OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x167c, "OpSubgroupAvcImeSetWeightedSadINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x167d, "OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x167e, "OpSubgroupAvcImeEvaluateWithDualReferenceINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x167f, "OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1680, "OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1681, "OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1682, "OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1683, "OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1684, "OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1685, "OpSubgroupAvcImeConvertToMceResultINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1686, "OpSubgroupAvcImeGetSingleReferenceStreaminINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1687, "OpSubgroupAvcImeGetDualReferenceStreaminINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1688, "OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1689, "OpSubgroupAvcImeStripDualReferenceStreamoutINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x168a, "OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x168b, "OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x168c, "OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x168d, "OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x168e, "OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x168f, "OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1690, "OpSubgroupAvcImeGetBorderReachedINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1691, "OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1692, "OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1693, "OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1694, "OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1695, "OpSubgroupAvcFmeInitializeINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1696, "OpSubgroupAvcBmeInitializeINTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1697, "OpSubgroupAvcRefConvertToMcePayloadINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1698, "OpSubgroupAvcRefSetBidirectionalMixDisableINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1699, "OpSubgroupAvcRefSetBilinearFilterEnableINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x169a, "OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x169b, "OpSubgroupAvcRefEvaluateWithDualReferenceINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x169c, "OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x169d, "OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x169e, "OpSubgroupAvcRefConvertToMceResultINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x169f, "OpSubgroupAvcSicInitializeINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a0, "OpSubgroupAvcSicConfigureSkcINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a1, "OpSubgroupAvcSicConfigureIpeLumaINTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a2, "OpSubgroupAvcSicConfigureIpeLumaChromaINTEL", 13,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a3, "OpSubgroupAvcSicGetMotionVectorMaskINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a4, "OpSubgroupAvcSicConvertToMcePayloadINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a5, "OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a6, "OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a7, "OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a8, "OpSubgroupAvcSicSetBilinearFilterEnableINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16a9, "OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16aa, "OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16ab, "OpSubgroupAvcSicEvaluateIpeINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16ac, "OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16ad, "OpSubgroupAvcSicEvaluateWithDualReferenceINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16ae, "OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16af, "OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16b0, "OpSubgroupAvcSicConvertToMceResultINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16b1, "OpSubgroupAvcSicGetIpeLumaShapeINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16b2, "OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16b3, "OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16b4, "OpSubgroupAvcSicGetPackedIpeLumaModesINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16b5, "OpSubgroupAvcSicGetIpeChromaModeINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16b6, "OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16b7, "OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16b8, "OpSubgroupAvcSicGetInterRawSadsINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16ba, "OpVariableLengthArrayINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16bb, "OpSaveMemoryINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+        }
+    },
+    {
+        0x16bc, "OpRestoreMemoryINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x16d0, "OpArbitraryFloatSinCosPiINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16d1, "OpArbitraryFloatCastINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16d2, "OpArbitraryFloatCastFromIntINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16d3, "OpArbitraryFloatCastToIntINTEL", 7,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16d6, "OpArbitraryFloatAddINTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16d7, "OpArbitraryFloatSubINTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16d8, "OpArbitraryFloatMulINTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16d9, "OpArbitraryFloatDivINTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16da, "OpArbitraryFloatGTINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16db, "OpArbitraryFloatGEINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16dc, "OpArbitraryFloatLTINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16dd, "OpArbitraryFloatLEINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16de, "OpArbitraryFloatEQINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16df, "OpArbitraryFloatRecipINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e0, "OpArbitraryFloatRSqrtINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e1, "OpArbitraryFloatCbrtINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e2, "OpArbitraryFloatHypotINTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e3, "OpArbitraryFloatSqrtINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e4, "OpArbitraryFloatLogINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e5, "OpArbitraryFloatLog2INTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e6, "OpArbitraryFloatLog10INTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e7, "OpArbitraryFloatLog1pINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e8, "OpArbitraryFloatExpINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16e9, "OpArbitraryFloatExp2INTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16ea, "OpArbitraryFloatExp10INTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16eb, "OpArbitraryFloatExpm1INTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16ec, "OpArbitraryFloatSinINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16ed, "OpArbitraryFloatCosINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16ee, "OpArbitraryFloatSinCosINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16ef, "OpArbitraryFloatSinPiINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f0, "OpArbitraryFloatCosPiINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f1, "OpArbitraryFloatASinINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f2, "OpArbitraryFloatASinPiINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f3, "OpArbitraryFloatACosINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f4, "OpArbitraryFloatACosPiINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f5, "OpArbitraryFloatATanINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f6, "OpArbitraryFloatATanPiINTEL", 8,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f7, "OpArbitraryFloatATan2INTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f8, "OpArbitraryFloatPowINTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16f9, "OpArbitraryFloatPowRINTEL", 10,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16fa, "OpArbitraryFloatPowNINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x16ff, "OpLoopControlINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER, '*'},
+        }
+    },
+    {
+        0x1717, "OpAliasDomainDeclINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x1718, "OpAliasScopeDeclINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '?'},
+        }
+    },
+    {
+        0x1719, "OpAliasScopeListDeclINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x1723, "OpFixedSqrtINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x1724, "OpFixedRecipINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x1725, "OpFixedRsqrtINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x1726, "OpFixedSinINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x1727, "OpFixedCosINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x1728, "OpFixedSinCosINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x1729, "OpFixedSinPiINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x172a, "OpFixedCosPiINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x172b, "OpFixedSinCosPiINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x172c, "OpFixedLogINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x172d, "OpFixedExpINTEL", 9,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+        }
+    },
+    {
+        0x172e, "OpPtrCastToCrossWorkgroupINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1732, "OpCrossWorkgroupCastToPtrINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x173a, "OpReadPipeBlockingINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x173b, "OpWritePipeBlockingINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x173d, "OpFPGARegINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1780, "OpRayQueryGetRayTMinKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1781, "OpRayQueryGetRayFlagsKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1782, "OpRayQueryGetIntersectionTKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1783, "OpRayQueryGetIntersectionInstanceCustomIndexKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1784, "OpRayQueryGetIntersectionInstanceIdKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1785, "OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1786, "OpRayQueryGetIntersectionGeometryIndexKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1787, "OpRayQueryGetIntersectionPrimitiveIndexKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1788, "OpRayQueryGetIntersectionBarycentricsKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1789, "OpRayQueryGetIntersectionFrontFaceKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x178a, "OpRayQueryGetIntersectionCandidateAABBOpaqueKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x178b, "OpRayQueryGetIntersectionObjectRayDirectionKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x178c, "OpRayQueryGetIntersectionObjectRayOriginKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x178d, "OpRayQueryGetWorldRayDirectionKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x178e, "OpRayQueryGetWorldRayOriginKHR", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x178f, "OpRayQueryGetIntersectionObjectToWorldKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1790, "OpRayQueryGetIntersectionWorldToObjectKHR", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1793, "OpAtomicFAddEXT", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x17c6, "OpTypeBufferSurfaceINTEL", 2,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ACCESS_QUALIFIER},
+        }
+    },
+    {
+        0x17ca, "OpTypeStructContinuedINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x17cb, "OpConstantCompositeContinuedINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x17cc, "OpSpecConstantCompositeContinuedINTEL", 1,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x17d0, "OpCompositeConstructContinuedINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF, '*'},
+        }
+    },
+    {
+        0x17e4, "OpConvertFToBF16INTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x17e5, "OpConvertBF16ToFINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x17fe, "OpControlBarrierArriveINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x17ff, "OpControlBarrierWaitINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_MEMORY_SEMANTICS},
+        }
+    },
+    {
+        0x1801, "OpArithmeticFenceEXT", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x184d, "OpSubgroupBlockPrefetchINTEL", 3,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_MEMORY_ACCESS, '?'},
+        }
+    },
+    {
+        0x1901, "OpGroupIMulKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1902, "OpGroupFMulKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1903, "OpGroupBitwiseAndKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1904, "OpGroupBitwiseOrKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1905, "OpGroupBitwiseXorKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1906, "OpGroupLogicalAndKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1907, "OpGroupLogicalOrKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x1908, "OpGroupLogicalXorKHR", 5,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_SCOPE},
+            {SPIRV_PARSER_OPERAND_TYPE_GROUP_OPERATION},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x191c, "OpMaskedGatherINTEL", 6,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_RESULT},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+    {
+        0x191d, "OpMaskedScatterINTEL", 4,
+        (struct spirv_parser_instruction_operand[])
+        {
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+            {SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER},
+            {SPIRV_PARSER_OPERAND_TYPE_ID_REF},
+        }
+    },
+};
diff --git a/libs/vkd3d/include/private/vkd3d_common.h b/libs/vkd3d/include/private/vkd3d_common.h
index ec1dd70c9b2..93c8a0bec7c 100644
--- a/libs/vkd3d/include/private/vkd3d_common.h
+++ b/libs/vkd3d/include/private/vkd3d_common.h
@@ -65,9 +65,12 @@
 #define vkd3d_clamp(value, lower, upper) max(min(value, upper), lower)
 
 #define TAG_AON9 VKD3D_MAKE_TAG('A', 'o', 'n', '9')
+#define TAG_CLI4 VKD3D_MAKE_TAG('C', 'L', 'I', '4')
+#define TAG_CTAB VKD3D_MAKE_TAG('C', 'T', 'A', 'B')
 #define TAG_DXBC VKD3D_MAKE_TAG('D', 'X', 'B', 'C')
 #define TAG_DXIL VKD3D_MAKE_TAG('D', 'X', 'I', 'L')
 #define TAG_FX10 VKD3D_MAKE_TAG('F', 'X', '1', '0')
+#define TAG_FXLC VKD3D_MAKE_TAG('F', 'X', 'L', 'C')
 #define TAG_ISG1 VKD3D_MAKE_TAG('I', 'S', 'G', '1')
 #define TAG_ISGN VKD3D_MAKE_TAG('I', 'S', 'G', 'N')
 #define TAG_OSG1 VKD3D_MAKE_TAG('O', 'S', 'G', '1')
@@ -275,7 +278,7 @@ static inline unsigned int vkd3d_popcount(unsigned int v)
 {
 #ifdef _MSC_VER
     return __popcnt(v);
-#elif defined(__MINGW32__)
+#elif defined(HAVE_BUILTIN_POPCOUNT)
     return __builtin_popcount(v);
 #else
     v -= (v >> 1) & 0x55555555;
diff --git a/libs/vkd3d/include/private/vkd3d_shader_utils.h b/libs/vkd3d/include/private/vkd3d_shader_utils.h
index c9f8001e590..00052a89988 100644
--- a/libs/vkd3d/include/private/vkd3d_shader_utils.h
+++ b/libs/vkd3d/include/private/vkd3d_shader_utils.h
@@ -43,16 +43,12 @@ static inline enum vkd3d_result vkd3d_shader_parse_dxbc_source_type(const struct
         if (tag == TAG_SHDR || tag == TAG_SHEX)
         {
             *type = VKD3D_SHADER_SOURCE_DXBC_TPF;
-#ifndef VKD3D_SHADER_UNSUPPORTED_DXIL
-            break;
-#else
         }
         else if (tag == TAG_DXIL)
         {
             *type = VKD3D_SHADER_SOURCE_DXBC_DXIL;
             /* Default to DXIL if both are present. */
             break;
-#endif
         }
     }
 
diff --git a/libs/vkd3d/include/private/vkd3d_version.h b/libs/vkd3d/include/private/vkd3d_version.h
index 0edc4428022..a73ae3fb03c 100644
--- a/libs/vkd3d/include/private/vkd3d_version.h
+++ b/libs/vkd3d/include/private/vkd3d_version.h
@@ -1 +1 @@
-#define VKD3D_VCS_ID " (Wine bundled)"
+#define VKD3D_VCS_ID " (git 81dc67b1)"
diff --git a/libs/vkd3d/include/vkd3d_shader.h b/libs/vkd3d/include/vkd3d_shader.h
index 058166aa2f9..2e1f37f12e6 100644
--- a/libs/vkd3d/include/vkd3d_shader.h
+++ b/libs/vkd3d/include/vkd3d_shader.h
@@ -249,6 +249,10 @@ enum vkd3d_shader_compile_option_feature_flags
      *       QUAD bits set.
      * - supportedStages include COMPUTE and FRAGMENT. \since 1.12 */
     VKD3D_SHADER_COMPILE_OPTION_FEATURE_WAVE_OPS      = 0x00000004,
+    /** The SPIR-V target environment supports zero-initializing workgroup
+     * memory. This corresponds to the "shaderZeroInitializeWorkgroupMemory"
+     * Vulkan feature. \since 1.16 */
+    VKD3D_SHADER_COMPILE_OPTION_FEATURE_ZERO_INITIALIZE_WORKGROUP_MEMORY = 0x00000008,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_FEATURE_FLAGS),
 };
@@ -2286,6 +2290,14 @@ enum vkd3d_shader_component_type
     VKD3D_SHADER_COMPONENT_DOUBLE   = 0x5,
     /** 64-bit unsigned integer. \since 1.11 */
     VKD3D_SHADER_COMPONENT_UINT64   = 0x6,
+    /** 64-bit signed integer. \since 1.16 */
+    VKD3D_SHADER_COMPONENT_INT64    = 0x7,
+    /** 16-bit IEEE floating-point. \since 1.16 */
+    VKD3D_SHADER_COMPONENT_FLOAT16  = 0x8,
+    /** 16-bit unsigned integer. \since 1.16 */
+    VKD3D_SHADER_COMPONENT_UINT16   = 0x9,
+    /** 16-bit signed integer. \since 1.16 */
+    VKD3D_SHADER_COMPONENT_INT16    = 0xa,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPONENT_TYPE),
 };
@@ -2991,7 +3003,8 @@ VKD3D_SHADER_API void vkd3d_shader_free_scan_descriptor_info(
  * signature. To retrieve signatures from other shader types, or other signature
  * types, use vkd3d_shader_scan() and struct vkd3d_shader_scan_signature_info.
  * This function returns the same input signature that is returned in
- * struct vkd3d_shader_scan_signature_info.
+ * struct vkd3d_shader_scan_signature_info for dxbc-tpf shaders, but may return
+ * different information for dxbc-dxil shaders.
  *
  * \param dxbc Compiled byte code, in DXBC format.
  *
diff --git a/libs/vkd3d/libs/vkd3d-common/blob.c b/libs/vkd3d/libs/vkd3d-common/blob.c
index f60ef7db769..c2c6ad67804 100644
--- a/libs/vkd3d/libs/vkd3d-common/blob.c
+++ b/libs/vkd3d/libs/vkd3d-common/blob.c
@@ -20,6 +20,7 @@
 #define WIDL_C_INLINE_WRAPPERS
 #endif
 #define COBJMACROS
+
 #define CONST_VTABLE
 #include "vkd3d.h"
 #include "vkd3d_blob.h"
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index 0639da83aa6..7b69535a445 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -2069,15 +2069,22 @@ static const char *get_component_type_name(enum vkd3d_shader_component_type type
 {
     switch (type)
     {
-        case VKD3D_SHADER_COMPONENT_VOID:   return "void";
-        case VKD3D_SHADER_COMPONENT_UINT:   return "uint";
-        case VKD3D_SHADER_COMPONENT_INT:    return "int";
-        case VKD3D_SHADER_COMPONENT_FLOAT:  return "float";
-        case VKD3D_SHADER_COMPONENT_BOOL:   return "bool";
-        case VKD3D_SHADER_COMPONENT_DOUBLE: return "double";
-        case VKD3D_SHADER_COMPONENT_UINT64: return "uint64";
-        default:                            return "??";
+        case VKD3D_SHADER_COMPONENT_VOID:       return "void";
+        case VKD3D_SHADER_COMPONENT_UINT:       return "uint";
+        case VKD3D_SHADER_COMPONENT_INT:        return "int";
+        case VKD3D_SHADER_COMPONENT_FLOAT:      return "float";
+        case VKD3D_SHADER_COMPONENT_BOOL:       return "bool";
+        case VKD3D_SHADER_COMPONENT_DOUBLE:     return "double";
+        case VKD3D_SHADER_COMPONENT_UINT64:     return "uint64";
+        case VKD3D_SHADER_COMPONENT_INT64:      return "int64";
+        case VKD3D_SHADER_COMPONENT_FLOAT16:    return "float16";
+        case VKD3D_SHADER_COMPONENT_UINT16:     return "uint16";
+        case VKD3D_SHADER_COMPONENT_INT16:      return "int16";
+        case VKD3D_SHADER_COMPONENT_TYPE_FORCE_32BIT:
+            break;
     }
+
+    return "??";
 }
 
 static const char *get_minimum_precision_name(enum vkd3d_shader_minimum_precision prec)
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxbc.c b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
index 81af62f7810..9e3a57132a1 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
@@ -381,7 +381,8 @@ static int shader_parse_signature(const struct vkd3d_shader_dxbc_section_desc *s
     uint32_t count, header_size;
     struct signature_element *e;
     const char *ptr = data;
-    unsigned int i, j;
+    bool fail = false;
+    unsigned int i;
 
     if (!require_space(0, 2, sizeof(uint32_t), section->data.size))
     {
@@ -436,17 +437,19 @@ static int shader_parse_signature(const struct vkd3d_shader_dxbc_section_desc *s
         if (!(name = shader_get_string(data, section->data.size, name_offset))
                 || !(e[i].semantic_name = vkd3d_strdup(name)))
         {
-            WARN("Invalid name offset %#zx (data size %#zx).\n", name_offset, section->data.size);
-            for (j = 0; j < i; ++j)
-            {
-                vkd3d_free((void *)e[j].semantic_name);
-            }
-            vkd3d_free(e);
-            return VKD3D_ERROR_INVALID_ARGUMENT;
+            vkd3d_shader_error(message_context, NULL, VKD3D_SHADER_ERROR_DXBC_INVALID_STRING_REFERENCE,
+                    "Element %u has invalid semantic name reference %#zx (data size %#zx).\n",
+                    i, name_offset, section->data.size);
+            fail = true;
         }
         e[i].semantic_index = read_u32(&ptr);
         e[i].sysval_semantic = read_u32(&ptr);
-        e[i].component_type = read_u32(&ptr);
+        if ((e[i].component_type = read_u32(&ptr)) > VKD3D_SHADER_COMPONENT_FLOAT)
+        {
+            vkd3d_shader_error(message_context, NULL, VKD3D_SHADER_ERROR_DXBC_INVALID_COMPONENT_TYPE,
+                    "Element %u has invalid component type %#x.\n", i, e[i].component_type);
+            fail = true;
+        }
         e[i].register_index = read_u32(&ptr);
         e[i].target_location = e[i].register_index;
         e[i].register_count = 1;
@@ -477,8 +480,15 @@ static int shader_parse_signature(const struct vkd3d_shader_dxbc_section_desc *s
     }
 
     s->elements = e;
+    s->elements_capacity = count;
     s->element_count = count;
 
+    if (fail)
+    {
+        shader_signature_cleanup(s);
+        return VKD3D_ERROR_INVALID_ARGUMENT;
+    }
+
     return VKD3D_OK;
 }
 
@@ -542,6 +552,8 @@ static int shdr_handler(const struct vkd3d_shader_dxbc_section_desc *section,
     {
         case TAG_ISGN:
         case TAG_ISG1:
+            if (desc->is_dxil)
+                break;
             if (desc->input_signature.elements)
             {
                 FIXME("Multiple input signatures.\n");
@@ -554,6 +566,8 @@ static int shdr_handler(const struct vkd3d_shader_dxbc_section_desc *section,
         case TAG_OSGN:
         case TAG_OSG5:
         case TAG_OSG1:
+            if (desc->is_dxil)
+                break;
             if (desc->output_signature.elements)
             {
                 FIXME("Multiple output signatures.\n");
@@ -565,6 +579,8 @@ static int shdr_handler(const struct vkd3d_shader_dxbc_section_desc *section,
 
         case TAG_PCSG:
         case TAG_PSG1:
+            if (desc->is_dxil)
+                break;
             if (desc->patch_constant_signature.elements)
             {
                 FIXME("Multiple patch constant signatures.\n");
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index a10de68008a..29e714ee2ac 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -3911,23 +3911,51 @@ static void sm6_parser_init_signature(struct sm6_parser *sm6, const struct shade
     }
 }
 
-static void sm6_parser_init_output_signature(struct sm6_parser *sm6, const struct shader_signature *output_signature)
+static int sm6_parser_init_output_signature(struct sm6_parser *sm6, const struct shader_signature *output_signature)
 {
+    if (!(sm6->output_params = vsir_program_get_dst_params(sm6->p.program, output_signature->element_count)))
+    {
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Failed to allocate output parameters.");
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+
     sm6_parser_init_signature(sm6, output_signature, false, VKD3DSPR_OUTPUT, sm6->output_params);
+
+    return VKD3D_OK;
 }
 
-static void sm6_parser_init_input_signature(struct sm6_parser *sm6, const struct shader_signature *input_signature)
+static int sm6_parser_init_input_signature(struct sm6_parser *sm6, const struct shader_signature *input_signature)
 {
+    if (!(sm6->input_params = vsir_program_get_dst_params(sm6->p.program, input_signature->element_count)))
+    {
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Failed to allocate input parameters.");
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+
     sm6_parser_init_signature(sm6, input_signature, true, VKD3DSPR_INPUT, sm6->input_params);
+
+    return VKD3D_OK;
 }
 
-static void sm6_parser_init_patch_constant_signature(struct sm6_parser *sm6,
+static int sm6_parser_init_patch_constant_signature(struct sm6_parser *sm6,
         const struct shader_signature *patch_constant_signature)
 {
     bool is_input = sm6->p.program->shader_version.type == VKD3D_SHADER_TYPE_DOMAIN;
 
+    if (!(sm6->patch_constant_params = vsir_program_get_dst_params(sm6->p.program,
+            patch_constant_signature->element_count)))
+    {
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Failed to allocate patch constant parameters.");
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    }
+
     sm6_parser_init_signature(sm6, patch_constant_signature, is_input, VKD3DSPR_PATCHCONST,
             sm6->patch_constant_params);
+
+    return VKD3D_OK;
 }
 
 static const struct sm6_value *sm6_parser_next_function_definition(struct sm6_parser *sm6)
@@ -8550,19 +8578,29 @@ static enum vkd3d_result sm6_parser_metadata_init(struct sm6_parser *sm6, const
     return VKD3D_OK;
 }
 
-static enum vkd3d_shader_component_type vkd3d_component_type_from_dxil_component_type(enum dxil_component_type type)
+static enum vkd3d_shader_component_type vkd3d_component_type_from_dxil_component_type(
+        enum dxil_component_type type, bool native_16bit)
 {
     switch (type)
     {
         case COMPONENT_TYPE_I1:
             return VKD3D_SHADER_COMPONENT_BOOL;
         case COMPONENT_TYPE_I16:
+            if (native_16bit)
+                return VKD3D_SHADER_COMPONENT_INT16;
+            return VKD3D_SHADER_COMPONENT_INT;
         case COMPONENT_TYPE_I32:
             return VKD3D_SHADER_COMPONENT_INT;
         case COMPONENT_TYPE_U16:
+            if (native_16bit)
+                return VKD3D_SHADER_COMPONENT_UINT16;
+            return VKD3D_SHADER_COMPONENT_UINT;
         case COMPONENT_TYPE_U32:
             return VKD3D_SHADER_COMPONENT_UINT;
         case COMPONENT_TYPE_F16:
+            if (native_16bit)
+                return VKD3D_SHADER_COMPONENT_FLOAT16;
+            return VKD3D_SHADER_COMPONENT_FLOAT;
         case COMPONENT_TYPE_F32:
         case COMPONENT_TYPE_SNORMF32:
         case COMPONENT_TYPE_UNORMF32:
@@ -8577,8 +8615,12 @@ static enum vkd3d_shader_component_type vkd3d_component_type_from_dxil_component
     }
 }
 
-static enum vkd3d_shader_minimum_precision minimum_precision_from_dxil_component_type(enum dxil_component_type type)
+static enum vkd3d_shader_minimum_precision minimum_precision_from_dxil_component_type(
+        enum dxil_component_type type, bool native_16bit)
 {
+    if (native_16bit)
+        return VKD3D_SHADER_MINIMUM_PRECISION_NONE;
+
     switch (type)
     {
         case COMPONENT_TYPE_F16:
@@ -9404,8 +9446,10 @@ static enum vkd3d_result sm6_parser_read_signature(struct sm6_parser *sm6, const
 {
     unsigned int i, j, column_count, operand_count, index;
     const struct sm6_metadata_node *node, *element_node;
+    struct vsir_program *program = sm6->p.program;
     struct signature_element *elements, *e;
     unsigned int values[10];
+    bool native_16bit;
     bool is_register;
 
     if (!m)
@@ -9430,6 +9474,7 @@ static enum vkd3d_result sm6_parser_read_signature(struct sm6_parser *sm6, const
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
 
+    native_16bit = program->global_flags & VKD3DSGF_FORCE_NATIVE_LOW_PRECISION;
     for (i = 0; i < operand_count; ++i)
     {
         m = node->operands[i];
@@ -9490,8 +9535,8 @@ static enum vkd3d_result sm6_parser_read_signature(struct sm6_parser *sm6, const
         }
         e->semantic_name = element_node->operands[1]->u.string_value;
 
-        e->component_type = vkd3d_component_type_from_dxil_component_type(values[2]);
-        e->min_precision = minimum_precision_from_dxil_component_type(values[2]);
+        e->component_type = vkd3d_component_type_from_dxil_component_type(values[2], native_16bit);
+        e->min_precision = minimum_precision_from_dxil_component_type(values[2], native_16bit);
 
         j = values[3];
         e->sysval_semantic = sysval_semantic_from_dxil_semantic_kind(j, tessellator_domain);
@@ -9631,23 +9676,24 @@ static enum vkd3d_result sm6_parser_signatures_init(struct sm6_parser *sm6, cons
 
     if (m->u.node->operand_count && (ret = sm6_parser_read_signature(sm6, m->u.node->operands[0],
             &program->input_signature, tessellator_domain, true)) < 0)
-    {
         return ret;
-    }
+
     if (m->u.node->operand_count > 1 && (ret = sm6_parser_read_signature(sm6, m->u.node->operands[1],
             &program->output_signature, tessellator_domain, false)) < 0)
-    {
         return ret;
-    }
+
     if (m->u.node->operand_count > 1 && (ret = sm6_parser_read_signature(sm6, m->u.node->operands[2],
             &program->patch_constant_signature, tessellator_domain, false)) < 0)
-    {
         return ret;
-    }
 
-    sm6_parser_init_input_signature(sm6, &program->input_signature);
-    sm6_parser_init_output_signature(sm6, &program->output_signature);
-    sm6_parser_init_patch_constant_signature(sm6, &program->patch_constant_signature);
+    if ((ret = sm6_parser_init_input_signature(sm6, &program->input_signature)) < 0)
+        return ret;
+
+    if ((ret = sm6_parser_init_output_signature(sm6, &program->output_signature) < 0))
+        return ret;
+
+    if ((ret = sm6_parser_init_patch_constant_signature(sm6, &program->patch_constant_signature)) < 0)
+        return ret;
 
     return VKD3D_OK;
 }
@@ -10432,9 +10478,6 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, struct vsir_pro
     input_signature = &program->input_signature;
     output_signature = &program->output_signature;
     patch_constant_signature = &program->patch_constant_signature;
-    *input_signature = dxbc_desc->input_signature;
-    *output_signature = dxbc_desc->output_signature;
-    *patch_constant_signature = dxbc_desc->patch_constant_signature;
     program->features = dxbc_desc->features;
     memset(dxbc_desc, 0, sizeof(*dxbc_desc));
 
@@ -10498,18 +10541,6 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, struct vsir_pro
         goto fail;
     }
 
-    if (!(sm6->output_params = vsir_program_get_dst_params(program, output_signature->element_count))
-            || !(sm6->input_params = vsir_program_get_dst_params(program, input_signature->element_count))
-            || !(sm6->patch_constant_params = vsir_program_get_dst_params(program,
-            patch_constant_signature->element_count)))
-    {
-        ERR("Failed to allocate input/output parameters.\n");
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
-                "Out of memory allocating input/output parameters.");
-        ret = VKD3D_ERROR_OUT_OF_MEMORY;
-        goto fail;
-    }
-
     function_count = dxil_block_compute_function_count(&sm6->root_block);
     if (!(sm6->functions = vkd3d_calloc(function_count, sizeof(*sm6->functions))))
     {
@@ -10669,8 +10700,6 @@ int dxil_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t co
     uint32_t *byte_code = NULL;
     int ret;
 
-    MESSAGE("Creating a DXIL parser. This is unsupported; you get to keep all the pieces if it breaks.\n");
-
     dxbc_desc.is_dxil = true;
     if ((ret = shader_extract_from_dxbc(&compile_info->source, message_context, compile_info->source_name,
             &dxbc_desc)) < 0)
diff --git a/libs/vkd3d/libs/vkd3d-shader/fx.c b/libs/vkd3d/libs/vkd3d-shader/fx.c
index bd7e7b420db..4fbce393707 100644
--- a/libs/vkd3d/libs/vkd3d-shader/fx.c
+++ b/libs/vkd3d/libs/vkd3d-shader/fx.c
@@ -25,6 +25,41 @@ static inline size_t put_u32_unaligned(struct vkd3d_bytecode_buffer *buffer, uin
     return bytecode_put_bytes_unaligned(buffer, &value, sizeof(value));
 }
 
+enum state_property_component_type
+{
+    FX_BOOL,
+    FX_FLOAT,
+    FX_UINT,
+    FX_UINT8,
+    FX_DEPTHSTENCIL,
+    FX_RASTERIZER,
+    FX_DOMAINSHADER,
+    FX_HULLSHADER,
+    FX_COMPUTESHADER,
+    FX_TEXTURE,
+    FX_DEPTHSTENCILVIEW,
+    FX_RENDERTARGETVIEW,
+    FX_BLEND,
+    FX_VERTEXSHADER,
+    FX_PIXELSHADER,
+    FX_GEOMETRYSHADER,
+    FX_COMPONENT_TYPE_COUNT,
+};
+
+struct rhs_named_value
+{
+    const char *name;
+    unsigned int value;
+};
+
+struct fx_assignment
+{
+    uint32_t id;
+    uint32_t lhs_index;
+    uint32_t type;
+    uint32_t value;
+};
+
 struct fx_4_binary_type
 {
     uint32_t name;
@@ -461,6 +496,407 @@ static void write_fx_2_annotations(struct hlsl_ir_var *var, uint32_t count_offse
     set_u32(buffer, count_offset, count);
 }
 
+static const struct rhs_named_value fx_2_zenable_values[] =
+{
+    { "USEW", 2 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_fillmode_values[] =
+{
+    { "POINT", 1 },
+    { "WIREFRAME", 2 },
+    { "SOLID", 3 },
+    { NULL },
+};
+
+static const struct rhs_named_value fx_2_shademode_values[] =
+{
+    { "FLAT", 1 },
+    { "GOURAUD", 2 },
+    { "PHONG", 3 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_blendmode_values[] =
+{
+    { "ZERO", 1 },
+    { "ONE", 2 },
+    { "SRCCOLOR", 3 },
+    { "INVSRCCOLOR", 4 },
+    { "SRCALPHA", 5 },
+    { "INVSRCALPHA", 6 },
+    { "DESTALPHA", 7 },
+    { "INVDESTALPHA", 8 },
+    { "DESTCOLOR", 9 },
+    { "INVDESTCOLOR", 10 },
+    { "SRCALPHASAT", 11 },
+    { "BOTHSRCALPHA", 12 },
+    { "BOTHINVSRCALPHA", 13 },
+    { "BLENDFACTOR", 14 },
+    { "INVBLENDFACTOR", 15 },
+    { "SRCCOLOR2", 16 },
+    { "INVSRCCOLOR2", 17 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_cullmode_values[] =
+{
+    { "NONE", 1 },
+    { "CW", 2 },
+    { "CCW", 3 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_cmpfunc_values[] =
+{
+    { "NEVER", 1 },
+    { "LESS", 2 },
+    { "EQUAL", 3 },
+    { "LESSEQUAL", 4 },
+    { "GREATER", 5 },
+    { "NOTEQUAL", 6 },
+    { "GREATEREQUAL", 7 },
+    { "ALWAYS", 8 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_fogmode_values[] =
+{
+    { "NONE", 0 },
+    { "EXP", 1 },
+    { "EXP2", 2 },
+    { "LINEAR", 3 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_stencilcaps_values[] =
+{
+    { "KEEP", 0x1 },
+    { "ZERO", 0x2 },
+    { "REPLACE", 0x4 },
+    { "INCRSAT", 0x8 },
+    { "DECRSAT", 0x10 },
+    { "INVERT", 0x20 },
+    { "INCR", 0x40 },
+    { "DECR", 0x80 },
+    { "TWOSIDED", 0x100 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_wrap_values[] =
+{
+    { "COORD_0", 0x1 },
+    { "COORD_1", 0x2 },
+    { "COORD_2", 0x4 },
+    { "COORD_3", 0x8 },
+    { "U", 0x1 },
+    { "V", 0x2 },
+    { "W", 0x4 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_materialcolorsource_values[] =
+{
+    { "MATERIAL", 0 },
+    { "COORD1", 1 },
+    { "COORD2", 2 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_vertexblend_values[] =
+{
+    { "DISABLE", 0 },
+    { "1WEIGHTS", 1 },
+    { "2WEIGHTS", 2 },
+    { "3WEIGHTS", 3 },
+    { "TWEENING", 255 },
+    { "0WEIGHTS", 256 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_clipplane_values[] =
+{
+    { "CLIPPLANE0", 0x1 },
+    { "CLIPPLANE1", 0x2 },
+    { "CLIPPLANE2", 0x4 },
+    { "CLIPPLANE3", 0x8 },
+    { "CLIPPLANE4", 0x10 },
+    { "CLIPPLANE5", 0x20 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_patchedgestyle_values[] =
+{
+    { "DISCRETE", 0 },
+    { "CONTINUOUS", 1 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_colorwriteenable_values[] =
+{
+    { "RED", 0x1 },
+    { "GREEN", 0x2 },
+    { "BLUE", 0x4 },
+    { "ALPHA", 0x8 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_blendop_values[] =
+{
+    { "ADD", 1 },
+    { "SUBTRACT", 2 },
+    { "REVSUBTRACT", 3 },
+    { "MIN", 4 },
+    { "MAX", 5 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_degree_values[] =
+{
+    { "LINEAR", 1 },
+    { "QUADRATIC", 2 },
+    { "CUBIC", 3 },
+    { "QUINTIC", 4 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_textureop_values[] =
+{
+    { "DISABLE", 1 },
+    { "SELECTARG1", 2 },
+    { "SELECTARG2", 3 },
+    { "MODULATE", 4 },
+    { "MODULATE2X", 5 },
+    { "MODULATE4X", 6 },
+    { "ADD", 7 },
+    { "ADDSIGNED", 8 },
+    { "ADDSIGNED2X", 9 },
+    { "SUBTRACT", 10 },
+    { "ADDSMOOTH", 11 },
+    { "BLENDDIFFUSEALPHA", 12 },
+    { "BLENDTEXTUREALPHA", 13 },
+    { "BLENDFACTORALPHA", 14 },
+    { "BLENDTEXTUREALPHAPM", 15 },
+    { "BLENDCURRENTALPHA", 16 },
+    { "PREMODULATE", 17 },
+    { "MODULATEALPHA_ADDCOLOR", 18 },
+    { "MODULATECOLOR_ADDALPHA", 19 },
+    { "MODULATEINVALPHA_ADDCOLOR", 20 },
+    { "MODULATEINVCOLOR_ADDALPHA", 21 },
+    { "BUMPENVMAP", 22 },
+    { "BUMPENVMAPLUMINANCE", 23 },
+    { "DOTPRODUCT3", 24 },
+    { "MULTIPLYADD", 25 },
+    { "LERP", 26 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_colorarg_values[] =
+{
+    { "DIFFUSE", 0x0 },
+    { "CURRENT", 0x1 },
+    { "TEXTURE", 0x2 },
+    { "TFACTOR", 0x3 },
+    { "SPECULAR", 0x4 },
+    { "TEMP", 0x5 },
+    { "CONSTANT", 0x6 },
+    { "COMPLEMENT", 0x10 },
+    { "ALPHAREPLICATE", 0x20 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_texturetransform_values[] =
+{
+    { "DISABLE", 0 },
+    { "COUNT1", 1 },
+    { "COUNT2", 2 },
+    { "COUNT3", 3 },
+    { "COUNT4", 4 },
+    { "PROJECTED", 256 },
+    { NULL }
+};
+
+static const struct rhs_named_value fx_2_lighttype_values[] =
+{
+    { "POINT", 1 },
+    { "SPOT", 2 },
+    { "DIRECTIONAL", 3 },
+    { NULL }
+};
+
+static const struct fx_2_state
+{
+    const char *name;
+    enum hlsl_type_class class;
+    enum state_property_component_type type;
+    unsigned int dimx;
+    uint32_t array_size;
+    uint32_t id;
+    const struct rhs_named_value *values;
+}
+fx_2_states[] =
+{
+    { "ZEnable",          HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 0, fx_2_zenable_values },
+    { "FillMode",         HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 1, fx_2_fillmode_values },
+    { "ShadeMode",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 2, fx_2_shademode_values },
+    { "ZWriteEnable",     HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 3 },
+    { "AlphaTestEnable",  HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 4 },
+    { "LastPixel",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 5 },
+    { "SrcBlend",         HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 6, fx_2_blendmode_values },
+    { "DestBlend",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 7, fx_2_blendmode_values },
+    { "CullMode",         HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 8, fx_2_cullmode_values },
+    { "ZFunc",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 9, fx_2_cmpfunc_values },
+    { "AlphaRef",         HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 10 },
+    { "AlphaFunc",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 11, fx_2_cmpfunc_values },
+    { "DitherEnable",     HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 12 },
+    { "AlphaBlendEnable", HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 13 },
+    { "FogEnable",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 14 },
+    { "SpecularEnable",   HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 15 },
+    { "FogColor",         HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 16 },
+    { "FogTableMode",     HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 17, fx_2_fogmode_values },
+    { "FogStart",         HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 18 },
+    { "FogEnd",           HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 19 },
+    { "FogDensity",       HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 20 },
+    { "RangeFogEnable",   HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 21 },
+    { "StencilEnable",    HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 22 },
+    { "StencilFail",      HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 23, fx_2_stencilcaps_values },
+    { "StencilZFail",     HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 24, fx_2_stencilcaps_values },
+    { "StencilPass",      HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 25, fx_2_stencilcaps_values },
+    { "StencilFunc",      HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 26, fx_2_cmpfunc_values },
+    { "StencilRef",       HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 27 },
+    { "StencilMask",      HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 28 },
+    { "StencilWriteMask", HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 29 },
+    { "TextureFactor",    HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 30 },
+    { "Wrap0",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 31, fx_2_wrap_values },
+    { "Wrap1",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 32, fx_2_wrap_values },
+    { "Wrap2",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 33, fx_2_wrap_values },
+    { "Wrap3",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 34, fx_2_wrap_values },
+    { "Wrap4",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 35, fx_2_wrap_values },
+    { "Wrap5",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 36, fx_2_wrap_values },
+    { "Wrap6",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 37, fx_2_wrap_values },
+    { "Wrap7",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 38, fx_2_wrap_values },
+    { "Wrap8",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 39, fx_2_wrap_values },
+    { "Wrap9",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 40, fx_2_wrap_values },
+    { "Wrap10",           HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 41, fx_2_wrap_values },
+    { "Wrap11",           HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 42, fx_2_wrap_values },
+    { "Wrap12",           HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 43, fx_2_wrap_values },
+    { "Wrap13",           HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 44, fx_2_wrap_values },
+    { "Wrap14",           HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 45, fx_2_wrap_values },
+    { "Wrap15",           HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 46, fx_2_wrap_values },
+    { "Clipping",         HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 47 },
+    { "Lighting",         HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 48 },
+    { "Ambient",          HLSL_CLASS_VECTOR, FX_FLOAT, 4, 1, 49 },
+    { "FogVertexMode",    HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 50, fx_2_fogmode_values },
+    { "ColorVertex",      HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 51 },
+    { "LocalViewer",      HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 52 },
+    { "NormalizeNormals", HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 53 },
+
+    { "DiffuseMaterialSource",  HLSL_CLASS_SCALAR, FX_UINT, 1, 1, 54, fx_2_materialcolorsource_values },
+    { "SpecularMaterialSource", HLSL_CLASS_SCALAR, FX_UINT, 1, 1, 55, fx_2_materialcolorsource_values },
+    { "AmbientMaterialSource",  HLSL_CLASS_SCALAR, FX_UINT, 1, 1, 56, fx_2_materialcolorsource_values },
+    { "EmissiveMaterialSource", HLSL_CLASS_SCALAR, FX_UINT, 1, 1, 57, fx_2_materialcolorsource_values },
+
+    { "VertexBlend",       HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 58, fx_2_vertexblend_values },
+    { "ClipPlaneEnable",   HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 59, fx_2_clipplane_values },
+    { "PointSize",         HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 60 },
+    { "PointSize_Min",     HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 61 },
+    { "PointSize_Max",     HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 62 },
+    { "PointSpriteEnable", HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 63 },
+    { "PointScaleEnable",  HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 64 },
+    { "PointScale_A",      HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 65 },
+    { "PointScale_B",      HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 66 },
+    { "PointScale_C",      HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 67 },
+
+    { "MultiSampleAntialias",     HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 68 },
+    { "MultiSampleMask",          HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 69 },
+    { "PatchEdgeStyle",           HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 70, fx_2_patchedgestyle_values },
+    { "DebugMonitorToken",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 71 },
+    { "IndexedVertexBlendEnable", HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 72 },
+    { "ColorWriteEnable",         HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 73, fx_2_colorwriteenable_values },
+    { "TweenFactor",              HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 74 },
+    { "BlendOp",                  HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 75, fx_2_blendop_values },
+    { "PositionDegree",           HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 76, fx_2_degree_values },
+    { "NormalDegree",             HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 77, fx_2_degree_values },
+    { "ScissorTestEnable",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 78 },
+    { "SlopeScaleDepthBias",      HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 79 },
+
+    { "AntialiasedLineEnable",     HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 80 },
+    { "MinTessellationLevel",      HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 81 },
+    { "MaxTessellationLevel",      HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 82 },
+    { "AdaptiveTess_X",            HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 83 },
+    { "AdaptiveTess_Y",            HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 84 },
+    { "AdaptiveTess_Z",            HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 85 },
+    { "AdaptiveTess_W",            HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 86 },
+    { "EnableAdaptiveTesselation", HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 87 },
+    { "TwoSidedStencilMode",       HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 88 },
+    { "StencilFail",               HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 89, fx_2_stencilcaps_values },
+    { "StencilZFail",              HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 90, fx_2_stencilcaps_values },
+    { "StencilPass",               HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 91, fx_2_stencilcaps_values },
+    { "StencilFunc",               HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 92, fx_2_cmpfunc_values },
+
+    { "ColorWriteEnable1",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 93, fx_2_colorwriteenable_values },
+    { "ColorWriteEnable2",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 94, fx_2_colorwriteenable_values },
+    { "ColorWriteEnable3",        HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 95, fx_2_colorwriteenable_values },
+    { "BlendFactor",              HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 96 },
+    { "SRGBWriteEnable",          HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 97 },
+    { "DepthBias",                HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 98 },
+    { "SeparateAlphaBlendEnable", HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 99 },
+    { "SrcBlendAlpha",            HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 100, fx_2_blendmode_values },
+    { "DestBlendAlpha",           HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 101, fx_2_blendmode_values },
+    { "BlendOpAlpha",             HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 102, fx_2_blendmode_values },
+
+    { "ColorOp",               HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 103, fx_2_textureop_values },
+    { "ColorArg0",             HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 104, fx_2_colorarg_values },
+    { "ColorArg1",             HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 105, fx_2_colorarg_values },
+    { "ColorArg2",             HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 106, fx_2_colorarg_values },
+    { "AlphaOp",               HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 107, fx_2_textureop_values },
+    { "AlphaArg0",             HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 108, fx_2_colorarg_values },
+    { "AlphaArg1",             HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 109, fx_2_colorarg_values },
+    { "AlphaArg2",             HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 110, fx_2_colorarg_values },
+    { "ResultArg",             HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 111, fx_2_colorarg_values },
+    { "BumpEnvMat00",          HLSL_CLASS_SCALAR, FX_FLOAT, 1, 8, 112 },
+    { "BumpEnvMat01",          HLSL_CLASS_SCALAR, FX_FLOAT, 1, 8, 113 },
+    { "BumpEnvMat10",          HLSL_CLASS_SCALAR, FX_FLOAT, 1, 8, 114 },
+    { "BumpEnvMat11",          HLSL_CLASS_SCALAR, FX_FLOAT, 1, 8, 115 },
+    { "TextCoordIndex",        HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 116 },
+    { "BumpEnvLScale",         HLSL_CLASS_SCALAR, FX_FLOAT, 1, 8, 117 },
+    { "BumpEnvLOffset",        HLSL_CLASS_SCALAR, FX_FLOAT, 1, 8, 118 },
+    { "TextureTransformFlags", HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 119, fx_2_texturetransform_values },
+    { "Constant",              HLSL_CLASS_SCALAR, FX_UINT, 1, 8, 120 },
+    { "NPatchMode",            HLSL_CLASS_SCALAR, FX_UINT, 1, 1, 121 },
+    { "FVF",                   HLSL_CLASS_SCALAR, FX_UINT, 1, 1, 122 },
+
+    { "ProjectionTransform", HLSL_CLASS_MATRIX, FX_FLOAT, 4, 1, 123 },
+    { "ViewTransform",       HLSL_CLASS_MATRIX, FX_FLOAT, 4, 1, 124 },
+    { "WorldTransform",      HLSL_CLASS_MATRIX, FX_FLOAT, 4, 1, 125 },
+    { "TextureTransform",    HLSL_CLASS_MATRIX, FX_FLOAT, 4, 8, 126 },
+
+    { "MaterialAmbient",   HLSL_CLASS_VECTOR, FX_FLOAT, 4, 1, 127 },
+    { "MaterialDiffuse",   HLSL_CLASS_VECTOR, FX_FLOAT, 4, 1, 128 },
+    { "MaterialSpecular",  HLSL_CLASS_VECTOR, FX_FLOAT, 4, 1, 129 },
+    { "MaterialEmissive",  HLSL_CLASS_VECTOR, FX_FLOAT, 4, 1, 130 },
+    { "MaterialPower",     HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 131 },
+
+    { "LightType",         HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 132, fx_2_lighttype_values },
+    { "LightDiffuse",      HLSL_CLASS_VECTOR, FX_FLOAT, 4, 1, 133 },
+    { "LightSpecular",     HLSL_CLASS_VECTOR, FX_FLOAT, 4, 1, 134 },
+    { "LightAmbient",      HLSL_CLASS_VECTOR, FX_FLOAT, 4, 1, 135 },
+    { "LightPosition",     HLSL_CLASS_VECTOR, FX_FLOAT, 3, 1, 136 },
+    { "LightDirection",    HLSL_CLASS_VECTOR, FX_FLOAT, 3, 1, 137 },
+    { "LightRange",        HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 138 },
+    { "LightFalloff",      HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 139 },
+    { "LightAttenuation0", HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 140 },
+    { "LightAttenuation1", HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 141 },
+    { "LightAttenuation2", HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 142 },
+    { "LightTheta",        HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 143 },
+    { "LightPhi",          HLSL_CLASS_SCALAR, FX_FLOAT, 1, 1, 144 },
+    { "LightEnable",       HLSL_CLASS_SCALAR, FX_FLOAT, 1, 8, 145 },
+
+    { "VertexShader",      HLSL_CLASS_SCALAR, FX_VERTEXSHADER, 1, 1, 146 },
+    { "PixelShader",       HLSL_CLASS_SCALAR, FX_PIXELSHADER,  1, 1, 147 },
+};
+
 static void write_fx_2_pass(struct hlsl_ir_var *var, struct fx_write_context *fx)
 {
     struct vkd3d_bytecode_buffer *buffer = &fx->structured;
@@ -560,8 +996,21 @@ enum fx_4_type_constants
     FX_4_ASSIGNMENT_VARIABLE = 0x2,
     FX_4_ASSIGNMENT_ARRAY_CONSTANT_INDEX = 0x3,
     FX_4_ASSIGNMENT_ARRAY_VARIABLE_INDEX = 0x4,
+    FX_4_ASSIGNMENT_INDEX_EXPRESSION = 0x5,
+    FX_4_ASSIGNMENT_VALUE_EXPRESSION = 0x6,
     FX_4_ASSIGNMENT_INLINE_SHADER = 0x7,
     FX_5_ASSIGNMENT_INLINE_SHADER = 0x8,
+
+    /* FXLVM constants */
+    FX_4_FXLC_COMP_COUNT_MASK = 0xffff,
+    FX_4_FXLC_OPCODE_MASK = 0x7ff,
+    FX_4_FXLC_OPCODE_SHIFT = 20,
+    FX_4_FXLC_IS_SCALAR_MASK = 0x80000000,
+
+    FX_4_FXLC_REG_LITERAL = 1,
+    FX_4_FXLC_REG_CB = 2,
+    FX_4_FXLC_REG_OUTPUT = 4,
+    FX_4_FXLC_REG_TEMP = 7,
 };
 
 static const uint32_t fx_4_numeric_base_types[] =
@@ -1594,12 +2043,6 @@ static void write_fx_4_annotation(struct hlsl_ir_var *var, struct fx_write_conte
     }
 }
 
-struct rhs_named_value
-{
-    const char *name;
-    unsigned int value;
-};
-
 static bool get_fx_4_state_enum_value(const struct rhs_named_value *pairs,
         const char *name, unsigned int *value)
 {
@@ -1831,27 +2274,6 @@ static bool replace_state_block_constant(struct hlsl_ctx *ctx, struct hlsl_ir_no
     return true;
 }
 
-enum state_property_component_type
-{
-    FX_BOOL,
-    FX_FLOAT,
-    FX_UINT,
-    FX_UINT8,
-    FX_DEPTHSTENCIL,
-    FX_RASTERIZER,
-    FX_DOMAINSHADER,
-    FX_HULLSHADER,
-    FX_COMPUTESHADER,
-    FX_TEXTURE,
-    FX_DEPTHSTENCILVIEW,
-    FX_RENDERTARGETVIEW,
-    FX_BLEND,
-    FX_VERTEXSHADER,
-    FX_PIXELSHADER,
-    FX_GEOMETRYSHADER,
-    FX_COMPONENT_TYPE_COUNT,
-};
-
 static inline bool is_object_fx_type(enum state_property_component_type type)
 {
     switch (type)
@@ -2395,7 +2817,15 @@ static unsigned int decompose_fx_4_state_function_call(struct hlsl_ir_var *var,
 static unsigned int decompose_fx_4_state_block_expand_array(struct hlsl_ir_var *var, struct hlsl_state_block *block,
         unsigned int entry_index, struct fx_write_context *fx)
 {
-    static const char *states[] = { "SrcBlend", "DestBlend", "BlendOp", "SrcBlendAlpha", "DestBlendAlpha", "BlendOpAlpha" };
+    static const char *const states[] =
+    {
+        "SrcBlend",
+        "DestBlend",
+        "BlendOp",
+        "SrcBlendAlpha",
+        "DestBlendAlpha",
+        "BlendOpAlpha",
+    };
     const struct hlsl_type *type = hlsl_get_multiarray_element_type(var->data_type);
     struct hlsl_state_block_entry *entry = block->entries[entry_index];
     static const unsigned int array_size = 8;
@@ -2914,6 +3344,11 @@ struct fx_parser
     uint32_t buffer_count;
     uint32_t object_count;
     uint32_t group_count;
+    struct
+    {
+        uint32_t count;
+        uint32_t *types;
+    } objects;
     bool failed;
 };
 
@@ -2965,13 +3400,6 @@ static void VKD3D_PRINTF_FUNC(3, 4) fx_parser_error(struct fx_parser *parser, en
     parser->failed = true;
 }
 
-static int fx_2_parse(struct fx_parser *parser)
-{
-    fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_NOT_IMPLEMENTED, "Parsing fx_2_0 binaries is not implemented.");
-
-    return -1;
-}
-
 static const void *fx_parser_get_unstructured_ptr(struct fx_parser *parser, uint32_t offset, size_t size)
 {
     const uint8_t *ptr = parser->unstructured.ptr;
@@ -2986,91 +3414,592 @@ static const void *fx_parser_get_unstructured_ptr(struct fx_parser *parser, uint
     return &ptr[offset];
 }
 
-static void fx_parser_read_unstructured(struct fx_parser *parser, void *dst, uint32_t offset, size_t size)
+static const void *fx_parser_get_ptr(struct fx_parser *parser, size_t size)
+{
+    if (parser->end - parser->ptr < size)
+    {
+        parser->failed = true;
+        return NULL;
+    }
+
+    return parser->ptr;
+}
+
+static uint32_t fx_parser_read_unstructured(struct fx_parser *parser, void *dst, uint32_t offset, size_t size)
 {
     const uint8_t *ptr;
 
     memset(dst, 0, size);
     if (!(ptr = fx_parser_get_unstructured_ptr(parser, offset, size)))
-        return;
+        return offset;
 
     memcpy(dst, ptr, size);
+    return offset + size;
 }
 
-static const char *fx_4_get_string(struct fx_parser *parser, uint32_t offset)
+static void parse_fx_start_indent(struct fx_parser *parser)
 {
-    const uint8_t *ptr = parser->unstructured.ptr;
-    const uint8_t *end = parser->unstructured.end;
+    ++parser->indent;
+}
 
-    if (offset >= parser->unstructured.size)
-    {
-        parser->failed = true;
-        return "<invalid>";
-    }
+static void parse_fx_end_indent(struct fx_parser *parser)
+{
+    --parser->indent;
+}
 
-    ptr += offset;
+static void parse_fx_print_indent(struct fx_parser *parser)
+{
+    vkd3d_string_buffer_printf(&parser->buffer, "%*s", 4 * parser->indent, "");
+}
 
-    while (ptr < end && *ptr)
-        ++ptr;
+static const char *fx_2_get_string(struct fx_parser *parser, uint32_t offset)
+{
+    const char *ptr;
+    uint32_t size;
 
-    if (*ptr)
+    fx_parser_read_unstructured(parser, &size, offset, sizeof(size));
+    ptr = fx_parser_get_unstructured_ptr(parser, offset + 4, size);
+
+    if (!ptr)
     {
         parser->failed = true;
         return "<invalid>";
     }
 
-    return (const char *)(parser->unstructured.ptr + offset);
+    return ptr;
 }
 
-static void parse_fx_start_indent(struct fx_parser *parser)
+static unsigned int fx_get_fx_2_type_size(struct fx_parser *parser, uint32_t *offset)
 {
-    ++parser->indent;
+    uint32_t element_count, member_count, class, columns, rows;
+    unsigned int size = 0;
+
+    fx_parser_read_unstructured(parser, &class, *offset + 4, sizeof(class));
+    fx_parser_read_unstructured(parser, &element_count, *offset + 16, sizeof(element_count));
+
+    if (class == D3DXPC_STRUCT)
+    {
+        *offset = fx_parser_read_unstructured(parser, &member_count, *offset + 20, sizeof(member_count));
+
+        for (uint32_t i = 0; i < member_count; ++i)
+            size += fx_get_fx_2_type_size(parser, offset);
+    }
+    else if (class == D3DXPC_VECTOR)
+    {
+        fx_parser_read_unstructured(parser, &columns, *offset + 20, sizeof(columns));
+        *offset = fx_parser_read_unstructured(parser, &rows, *offset + 24, sizeof(rows));
+        size = rows * columns * sizeof(float);
+    }
+    else if (class == D3DXPC_MATRIX_ROWS
+            || class == D3DXPC_MATRIX_COLUMNS
+            || class == D3DXPC_SCALAR)
+    {
+        fx_parser_read_unstructured(parser, &rows, *offset + 20, sizeof(rows));
+        *offset = fx_parser_read_unstructured(parser, &columns, *offset + 24, sizeof(columns));
+        size = rows * columns * sizeof(float);
+    }
+    else
+    {
+        *offset += 20;
+    }
+
+    if (element_count)
+        size *= element_count;
+    return size;
 }
 
-static void parse_fx_end_indent(struct fx_parser *parser)
+static const char *const fx_2_types[] =
+{
+    [D3DXPT_VOID]           = "void",
+    [D3DXPT_BOOL]           = "bool",
+    [D3DXPT_INT]            = "int",
+    [D3DXPT_FLOAT]          = "float",
+    [D3DXPT_STRING]         = "string",
+    [D3DXPT_TEXTURE]        = "texture",
+    [D3DXPT_TEXTURE1D]      = "texture1D",
+    [D3DXPT_TEXTURE2D]      = "texture2D",
+    [D3DXPT_TEXTURE3D]      = "texture3D",
+    [D3DXPT_TEXTURECUBE]    = "textureCUBE",
+    [D3DXPT_SAMPLER]        = "sampler",
+    [D3DXPT_SAMPLER1D]      = "sampler1D",
+    [D3DXPT_SAMPLER2D]      = "sampler2D",
+    [D3DXPT_SAMPLER3D]      = "sampler3D",
+    [D3DXPT_SAMPLERCUBE]    = "samplerCUBE",
+    [D3DXPT_PIXELSHADER]    = "PixelShader",
+    [D3DXPT_VERTEXSHADER]   = "VertexShader",
+    [D3DXPT_PIXELFRAGMENT]  = "<pixel-fragment>",
+    [D3DXPT_VERTEXFRAGMENT] = "<vertex-fragment>",
+    [D3DXPT_UNSUPPORTED]    = "<unsupported>",
+};
+
+static void fx_parse_fx_2_type(struct fx_parser *parser, uint32_t offset)
 {
-    --parser->indent;
+    uint32_t type, class, rows, columns;
+    const char *name;
+
+    fx_parser_read_unstructured(parser, &type, offset, sizeof(type));
+    fx_parser_read_unstructured(parser, &class, offset + 4, sizeof(class));
+
+    if (class == D3DXPC_STRUCT)
+        name = "struct";
+    else
+        name = type < ARRAY_SIZE(fx_2_types) ? fx_2_types[type] : "<unknown>";
+
+    vkd3d_string_buffer_printf(&parser->buffer, "%s", name);
+    if (class == D3DXPC_VECTOR)
+    {
+        fx_parser_read_unstructured(parser, &columns, offset + 20, sizeof(columns));
+        fx_parser_read_unstructured(parser, &rows, offset + 24, sizeof(rows));
+        vkd3d_string_buffer_printf(&parser->buffer, "%u", columns);
+    }
+    else if (class == D3DXPC_MATRIX_ROWS || class == D3DXPC_MATRIX_COLUMNS)
+    {
+        fx_parser_read_unstructured(parser, &rows, offset + 20, sizeof(rows));
+        fx_parser_read_unstructured(parser, &columns, offset + 24, sizeof(columns));
+        vkd3d_string_buffer_printf(&parser->buffer, "%ux%u", rows, columns);
+    }
 }
 
-static void parse_fx_print_indent(struct fx_parser *parser)
+static void parse_fx_2_object_value(struct fx_parser *parser, uint32_t element_count,
+        uint32_t type, uint32_t offset)
 {
-    vkd3d_string_buffer_printf(&parser->buffer, "%*s", 4 * parser->indent, "");
+    uint32_t id;
+
+    element_count = max(element_count, 1);
+
+    for (uint32_t i = 0; i < element_count; ++i, offset += 4)
+    {
+        fx_parser_read_unstructured(parser, &id, offset, sizeof(id));
+        vkd3d_string_buffer_printf(&parser->buffer, "<object id %u>", id);
+        if (element_count > 1)
+            vkd3d_string_buffer_printf(&parser->buffer, ", ");
+        if (id < parser->objects.count)
+            parser->objects.types[id] = type;
+        else
+            fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_INVALID_DATA,
+                    "Initializer object id exceeds the number of objects in the effect.");
+    }
+
+
 }
 
-static void parse_fx_4_numeric_value(struct fx_parser *parser, uint32_t offset,
-        const struct fx_4_binary_type *type)
+static void parse_fx_2_numeric_value(struct fx_parser *parser, uint32_t offset,
+        unsigned int size, uint32_t base_type)
 {
-    unsigned int base_type, comp_count;
-    size_t i;
-
-    base_type = (type->typeinfo >> FX_4_NUMERIC_BASE_TYPE_SHIFT) & 0xf;
+    unsigned int i, comp_count;
 
-    comp_count = type->packed_size / sizeof(uint32_t);
+    comp_count = size / sizeof(uint32_t);
+    if (comp_count > 1)
+        vkd3d_string_buffer_printf(&parser->buffer, "{");
     for (i = 0; i < comp_count; ++i)
     {
         union hlsl_constant_value_component value;
 
         fx_parser_read_unstructured(parser, &value, offset, sizeof(uint32_t));
 
-        if (base_type == FX_4_NUMERIC_TYPE_FLOAT)
-            vkd3d_string_buffer_printf(&parser->buffer, "%f", value.f);
-        else if (base_type == FX_4_NUMERIC_TYPE_INT)
+        if (base_type == D3DXPT_INT)
             vkd3d_string_buffer_printf(&parser->buffer, "%d", value.i);
-        else if (base_type == FX_4_NUMERIC_TYPE_UINT)
-            vkd3d_string_buffer_printf(&parser->buffer, "%u", value.u);
-        else if (base_type == FX_4_NUMERIC_TYPE_BOOL)
+        else if (base_type == D3DXPT_BOOL)
             vkd3d_string_buffer_printf(&parser->buffer, "%s", value.u ? "true" : "false" );
         else
-            vkd3d_string_buffer_printf(&parser->buffer, "%#x", value.u);
+            vkd3d_string_buffer_print_f32(&parser->buffer, value.f);
 
         if (i < comp_count - 1)
             vkd3d_string_buffer_printf(&parser->buffer, ", ");
 
         offset += sizeof(uint32_t);
     }
+    if (comp_count > 1)
+        vkd3d_string_buffer_printf(&parser->buffer, "}");
 }
 
-static void fx_4_parse_string_initializer(struct fx_parser *parser, uint32_t offset)
+static void fx_parse_fx_2_parameter(struct fx_parser *parser, uint32_t offset)
+{
+    struct fx_2_var
+    {
+        uint32_t type;
+        uint32_t class;
+        uint32_t name;
+        uint32_t semantic;
+        uint32_t element_count;
+    } var;
+    const char *name;
+
+    fx_parser_read_unstructured(parser, &var, offset, sizeof(var));
+
+    fx_parse_fx_2_type(parser, offset);
+
+    name = fx_2_get_string(parser, var.name);
+    vkd3d_string_buffer_printf(&parser->buffer, " %s", name);
+    if (var.element_count)
+        vkd3d_string_buffer_printf(&parser->buffer, "[%u]", var.element_count);
+}
+
+static bool is_fx_2_sampler(uint32_t type)
+{
+    return type == D3DXPT_SAMPLER
+            || type == D3DXPT_SAMPLER1D
+            || type == D3DXPT_SAMPLER2D
+            || type == D3DXPT_SAMPLER3D
+            || type == D3DXPT_SAMPLERCUBE;
+}
+
+static void fx_parse_fx_2_initial_value(struct fx_parser *parser, uint32_t param, uint32_t value)
+{
+    struct fx_2_var
+    {
+        uint32_t type;
+        uint32_t class;
+        uint32_t name;
+        uint32_t semantic;
+        uint32_t element_count;
+    } var;
+    unsigned int size;
+    uint32_t offset;
+
+    if (!value)
+        return;
+
+    fx_parser_read_unstructured(parser, &var, param, sizeof(var));
+
+    offset = param;
+    size = fx_get_fx_2_type_size(parser, &offset);
+
+    vkd3d_string_buffer_printf(&parser->buffer, " = ");
+    if (var.element_count)
+        vkd3d_string_buffer_printf(&parser->buffer, "{ ");
+
+    if (var.class == D3DXPC_OBJECT)
+    {
+        if (is_fx_2_sampler(var.type))
+            fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_NOT_IMPLEMENTED,
+                    "Parsing sampler initializers is not supported.");
+        else
+            parse_fx_2_object_value(parser, var.element_count, var.type, value);
+    }
+    else
+    {
+        parse_fx_2_numeric_value(parser, value, size, var.type);
+    }
+
+    if (var.element_count)
+        vkd3d_string_buffer_printf(&parser->buffer, " }");
+}
+
+static void fx_parse_fx_2_annotations(struct fx_parser *parser, uint32_t count)
+{
+    uint32_t param, value;
+
+    if (parser->failed || !count)
+        return;
+
+    vkd3d_string_buffer_printf(&parser->buffer, "\n");
+    parse_fx_print_indent(parser);
+    vkd3d_string_buffer_printf(&parser->buffer, "<\n");
+    parse_fx_start_indent(parser);
+
+    for (uint32_t i = 0; i < count; ++i)
+    {
+        param = fx_parser_read_u32(parser);
+        value = fx_parser_read_u32(parser);
+
+        parse_fx_print_indent(parser);
+        fx_parse_fx_2_parameter(parser, param);
+        fx_parse_fx_2_initial_value(parser, param, value);
+        vkd3d_string_buffer_printf(&parser->buffer, ";\n");
+    }
+
+    parse_fx_end_indent(parser);
+    parse_fx_print_indent(parser);
+    vkd3d_string_buffer_printf(&parser->buffer, ">");
+}
+
+static void fx_parse_fx_2_assignment(struct fx_parser *parser)
+{
+    const struct rhs_named_value *named_value = NULL;
+    const struct fx_2_state *state = NULL;
+    struct fx_assignment entry;
+
+    fx_parser_read_u32s(parser, &entry, sizeof(entry));
+    if (entry.id <= ARRAY_SIZE(fx_2_states))
+    {
+        state = &fx_2_states[entry.id];
+
+        vkd3d_string_buffer_printf(&parser->buffer, "%s", state->name);
+        if (state->array_size > 1)
+            vkd3d_string_buffer_printf(&parser->buffer, "[%u]", entry.lhs_index);
+    }
+    else
+    {
+        vkd3d_string_buffer_printf(&parser->buffer, "<unrecognized state %u>", entry.id);
+    }
+    vkd3d_string_buffer_printf(&parser->buffer, " = ");
+
+    if (state && state->type == FX_UINT)
+    {
+        const struct rhs_named_value *ptr = state->values;
+        uint32_t value;
+
+        fx_parser_read_unstructured(parser, &value, entry.value, sizeof(value));
+
+        while (ptr->name)
+        {
+            if (value == ptr->value)
+            {
+                named_value = ptr;
+                break;
+            }
+            ++ptr;
+        }
+    }
+
+    if (named_value)
+    {
+        vkd3d_string_buffer_printf(&parser->buffer, "%s /* %u */", named_value->name, named_value->value);
+    }
+    else if (state && (state->type == FX_UINT || state->type == FX_FLOAT))
+    {
+        uint32_t offset = entry.type;
+        unsigned int size;
+
+        size = fx_get_fx_2_type_size(parser, &offset);
+        parse_fx_2_numeric_value(parser, entry.value, size, entry.type);
+    }
+    else
+    {
+        vkd3d_string_buffer_printf(&parser->buffer, "<ignored>");
+    }
+    vkd3d_string_buffer_printf(&parser->buffer, ";\n");
+}
+
+static void fx_parse_fx_2_technique(struct fx_parser *parser)
+{
+    struct fx_technique
+    {
+        uint32_t name;
+        uint32_t annotation_count;
+        uint32_t pass_count;
+    } technique;
+    struct fx_pass
+    {
+        uint32_t name;
+        uint32_t annotation_count;
+        uint32_t assignment_count;
+    } pass;
+    const char *name;
+
+    if (parser->failed)
+        return;
+
+    fx_parser_read_u32s(parser, &technique, sizeof(technique));
+
+    name = fx_2_get_string(parser, technique.name);
+
+    parse_fx_print_indent(parser);
+    vkd3d_string_buffer_printf(&parser->buffer, "technique %s", name);
+    fx_parse_fx_2_annotations(parser, technique.annotation_count);
+
+    vkd3d_string_buffer_printf(&parser->buffer, "\n");
+    parse_fx_print_indent(parser);
+    vkd3d_string_buffer_printf(&parser->buffer, "{\n");
+
+    parse_fx_start_indent(parser);
+    for (uint32_t i = 0; i < technique.pass_count; ++i)
+    {
+        fx_parser_read_u32s(parser, &pass, sizeof(pass));
+        name = fx_2_get_string(parser, pass.name);
+
+        parse_fx_print_indent(parser);
+        vkd3d_string_buffer_printf(&parser->buffer, "pass %s", name);
+        fx_parse_fx_2_annotations(parser, pass.annotation_count);
+
+        vkd3d_string_buffer_printf(&parser->buffer, "\n");
+        parse_fx_print_indent(parser);
+        vkd3d_string_buffer_printf(&parser->buffer, "{\n");
+
+        parse_fx_start_indent(parser);
+        for (uint32_t j = 0; j < pass.assignment_count; ++j)
+        {
+            parse_fx_print_indent(parser);
+            fx_parse_fx_2_assignment(parser);
+        }
+        parse_fx_end_indent(parser);
+
+        parse_fx_print_indent(parser);
+        vkd3d_string_buffer_printf(&parser->buffer, "}\n\n");
+    }
+
+    parse_fx_end_indent(parser);
+
+    parse_fx_print_indent(parser);
+    vkd3d_string_buffer_printf(&parser->buffer, "}\n\n");
+}
+
+static void fx_2_parse_parameters(struct fx_parser *parser, uint32_t count)
+{
+    struct fx_2_parameter
+    {
+        uint32_t type;
+        uint32_t value;
+        uint32_t flags;
+        uint32_t annotation_count;
+    } param;
+
+    for (uint32_t i = 0; i < count; ++i)
+    {
+        fx_parser_read_u32s(parser, &param, sizeof(param));
+
+        fx_parse_fx_2_parameter(parser, param.type);
+        fx_parse_fx_2_annotations(parser, param.annotation_count);
+        fx_parse_fx_2_initial_value(parser, param.type, param.value);
+        vkd3d_string_buffer_printf(&parser->buffer, ";\n");
+    }
+    if (count)
+        vkd3d_string_buffer_printf(&parser->buffer, "\n");
+}
+
+static void fx_parse_fx_2_data_blob(struct fx_parser *parser)
+{
+    uint32_t id, size;
+    const char *str;
+
+    id = fx_parser_read_u32(parser);
+    size = fx_parser_read_u32(parser);
+
+    parse_fx_print_indent(parser);
+    if (id < parser->objects.count)
+    {
+        uint32_t type = parser->objects.types[id];
+        switch (type)
+        {
+            case D3DXPT_STRING:
+            case D3DXPT_TEXTURE:
+            case D3DXPT_TEXTURE1D:
+            case D3DXPT_TEXTURE2D:
+            case D3DXPT_TEXTURE3D:
+            case D3DXPT_TEXTURECUBE:
+            case D3DXPT_PIXELSHADER:
+            case D3DXPT_VERTEXSHADER:
+                vkd3d_string_buffer_printf(&parser->buffer, "%s object %u size %u bytes%s\n",
+                        fx_2_types[type], id, size, size ? ":" : ",");
+                if (size && type == D3DXPT_STRING)
+                {
+                    parse_fx_start_indent(parser);
+                    parse_fx_print_indent(parser);
+                    str = fx_parser_get_ptr(parser, size);
+                    vkd3d_string_buffer_printf(&parser->buffer, "\"%.*s\"\n", size, str);
+                    parse_fx_end_indent(parser);
+                }
+                break;
+            default:
+                vkd3d_string_buffer_printf(&parser->buffer, "<type%u> object %u size %u bytes\n", type, id, size);
+        }
+    }
+    else
+    {
+        vkd3d_string_buffer_printf(&parser->buffer, "object %u - out-of-range id\n", id);
+    }
+
+    fx_parser_skip(parser, align(size, 4));
+}
+
+static void fx_2_parse(struct fx_parser *parser)
+{
+    uint32_t i, size, parameter_count, technique_count, blob_count;
+
+    fx_parser_skip(parser, sizeof(uint32_t)); /* Version */
+    size = fx_parser_read_u32(parser);
+
+    parser->unstructured.ptr = parser->ptr;
+    parser->unstructured.end = parser->ptr + size;
+    parser->unstructured.size = size;
+    fx_parser_skip(parser, size);
+
+    parameter_count = fx_parser_read_u32(parser);
+    technique_count = fx_parser_read_u32(parser);
+    fx_parser_read_u32(parser); /* Shader count */
+    parser->objects.count = fx_parser_read_u32(parser);
+
+    if (!(parser->objects.types = calloc(parser->objects.count, sizeof(*parser->objects.types))))
+    {
+        fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_OUT_OF_MEMORY, "Out of memory.");
+        return;
+    }
+
+    fx_2_parse_parameters(parser, parameter_count);
+    for (i = 0; i < technique_count; ++i)
+        fx_parse_fx_2_technique(parser);
+
+    blob_count = fx_parser_read_u32(parser);
+    fx_parser_read_u32(parser); /* Resource count */
+
+    vkd3d_string_buffer_printf(&parser->buffer, "object data {\n");
+    parse_fx_start_indent(parser);
+    for (i = 0; i < blob_count; ++i)
+        fx_parse_fx_2_data_blob(parser);
+    parse_fx_end_indent(parser);
+    vkd3d_string_buffer_printf(&parser->buffer, "}\n");
+}
+
+static const char *fx_4_get_string(struct fx_parser *parser, uint32_t offset)
+{
+    const uint8_t *ptr = parser->unstructured.ptr;
+    const uint8_t *end = parser->unstructured.end;
+
+    if (offset >= parser->unstructured.size)
+    {
+        parser->failed = true;
+        return "<invalid>";
+    }
+
+    ptr += offset;
+
+    while (ptr < end && *ptr)
+        ++ptr;
+
+    if (*ptr)
+    {
+        parser->failed = true;
+        return "<invalid>";
+    }
+
+    return (const char *)(parser->unstructured.ptr + offset);
+}
+
+static void parse_fx_4_numeric_value(struct fx_parser *parser, uint32_t offset,
+        const struct fx_4_binary_type *type)
+{
+    unsigned int base_type, comp_count;
+    size_t i;
+
+    base_type = (type->typeinfo >> FX_4_NUMERIC_BASE_TYPE_SHIFT) & 0xf;
+
+    comp_count = type->packed_size / sizeof(uint32_t);
+    for (i = 0; i < comp_count; ++i)
+    {
+        union hlsl_constant_value_component value;
+
+        fx_parser_read_unstructured(parser, &value, offset, sizeof(uint32_t));
+
+        if (base_type == FX_4_NUMERIC_TYPE_FLOAT)
+            vkd3d_string_buffer_print_f32(&parser->buffer, value.f);
+        else if (base_type == FX_4_NUMERIC_TYPE_INT)
+            vkd3d_string_buffer_printf(&parser->buffer, "%d", value.i);
+        else if (base_type == FX_4_NUMERIC_TYPE_UINT)
+            vkd3d_string_buffer_printf(&parser->buffer, "%u", value.u);
+        else if (base_type == FX_4_NUMERIC_TYPE_BOOL)
+            vkd3d_string_buffer_printf(&parser->buffer, "%s", value.u ? "true" : "false" );
+        else
+            vkd3d_string_buffer_printf(&parser->buffer, "%#x", value.u);
+
+        if (i < comp_count - 1)
+            vkd3d_string_buffer_printf(&parser->buffer, ", ");
+
+        offset += sizeof(uint32_t);
+    }
+}
+
+static void fx_4_parse_string_initializer(struct fx_parser *parser, uint32_t offset)
 {
     const char *str = fx_4_get_string(parser, offset);
     vkd3d_string_buffer_printf(&parser->buffer, "\"%s\"", str);
@@ -3240,6 +4169,13 @@ static void fx_4_parse_shader_blob(struct fx_parser *parser, unsigned int object
         {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_15},
     };
 
+    if (!shader->offset)
+    {
+        parse_fx_print_indent(parser);
+        vkd3d_string_buffer_printf(&parser->buffer, "NULL");
+        return;
+    }
+
     fx_parser_read_unstructured(parser, &data_size, shader->offset, sizeof(data_size));
     if (data_size)
         data = fx_parser_get_unstructured_ptr(parser, shader->offset + 4, data_size);
@@ -3366,16 +4302,298 @@ static int fx_4_state_id_compare(const void *a, const void *b)
     return id - state->id;
 }
 
+static const struct
+{
+    uint32_t opcode;
+    const char *name;
+}
+fx_4_fxlc_opcodes[] =
+{
+    { 0x100, "mov"   },
+    { 0x101, "neg"   },
+    { 0x103, "rcp"   },
+    { 0x104, "frc"   },
+    { 0x105, "exp"   },
+    { 0x106, "log"   },
+    { 0x107, "rsq"   },
+    { 0x108, "sin"   },
+    { 0x109, "cos"   },
+    { 0x10a, "asin"  },
+    { 0x10b, "acos"  },
+    { 0x10c, "atan"  },
+    { 0x112, "sqrt"  },
+    { 0x120, "ineg"  },
+    { 0x121, "not"   },
+    { 0x130, "itof"  },
+    { 0x131, "utof"  },
+    { 0x133, "ftou"  },
+    { 0x137, "ftob"  },
+    { 0x139, "floor" },
+    { 0x13a, "ceil"  },
+    { 0x200, "min"   },
+    { 0x201, "max"   },
+    { 0x204, "add"   },
+    { 0x205, "mul"   },
+    { 0x206, "atan2" },
+    { 0x208, "div"   },
+    { 0x210, "bilt"  },
+    { 0x211, "bige"  },
+    { 0x212, "bieq"  },
+    { 0x213, "bine"  },
+    { 0x214, "buge"  },
+    { 0x215, "bult"  },
+    { 0x216, "iadd"  },
+    { 0x219, "imul"  },
+    { 0x21a, "udiv"  },
+    { 0x21d, "imin"  },
+    { 0x21e, "imax"  },
+    { 0x21f, "umin"  },
+    { 0x220, "umax"  },
+    { 0x230, "and"   },
+    { 0x231, "or"    },
+    { 0x233, "xor"   },
+    { 0x234, "ishl"  },
+    { 0x235, "ishr"  },
+    { 0x236, "ushr"  },
+    { 0x301, "movc"  },
+    { 0x500, "dot"   },
+    { 0x70e, "d3ds_dotswiz" },
+};
+
+static const char *fx_4_get_fxlc_opcode_name(uint32_t opcode)
+{
+    size_t i;
+
+    for (i = 0; i < ARRAY_SIZE(fx_4_fxlc_opcodes); ++i)
+    {
+        if (fx_4_fxlc_opcodes[i].opcode == opcode)
+            return fx_4_fxlc_opcodes[i].name;
+    }
+
+    return "<unrecognized>";
+}
+
+struct fx_4_fxlc_argument
+{
+    uint32_t flags;
+    uint32_t reg_type;
+    uint32_t address;
+};
+
+struct fx_4_ctab_entry
+{
+    uint32_t name;
+    uint16_t register_set;
+    uint16_t register_index;
+    uint16_t register_count;
+    uint16_t reserved;
+    uint32_t typeinfo;
+    uint32_t default_value;
+};
+
+struct fxlvm_code
+{
+    const float *cli4;
+    uint32_t cli4_count;
+
+    const struct fx_4_ctab_entry *constants;
+    uint32_t ctab_offset;
+    uint32_t ctab_count;
+    const char *ctab;
+
+    unsigned int comp_count;
+    bool scalar;
+};
+
+static void fx_4_parse_print_swizzle(struct fx_parser *parser, const struct fxlvm_code *code, unsigned int addr)
+{
+    unsigned int comp_count = code->scalar ? 1 : code->comp_count;
+    static const char comp[] = "xyzw";
+
+    if (comp_count < 4)
+        vkd3d_string_buffer_printf(&parser->buffer, ".%.*s", comp_count, &comp[addr % 4]);
+}
+
+static void fx_4_parse_fxlc_constant_argument(struct fx_parser *parser,
+        const struct fx_4_fxlc_argument *arg, const struct fxlvm_code *code)
+{
+    uint32_t i, offset, register_index = arg->address / 4; /* Address counts in components. */
+
+    for (i = 0; i < code->ctab_count; ++i)
+    {
+        const struct fx_4_ctab_entry *c = &code->constants[i];
+
+        if (register_index < c->register_index || register_index - c->register_index >= c->register_count)
+            continue;
+
+        vkd3d_string_buffer_printf(&parser->buffer, "%s", &code->ctab[c->name]);
+
+        /* Register offset within variable */
+        offset = arg->address - c->register_index * 4;
+
+        if (offset / 4)
+            vkd3d_string_buffer_printf(&parser->buffer, "[%u]", offset / 4);
+        fx_4_parse_print_swizzle(parser, code, offset);
+        return;
+    }
+
+    vkd3d_string_buffer_printf(&parser->buffer, "(var-not-found)");
+}
+
+static void fx_4_parse_fxlc_argument(struct fx_parser *parser, uint32_t offset, const struct fxlvm_code *code)
+{
+    struct fx_4_fxlc_argument arg;
+    uint32_t count;
+
+    fx_parser_read_unstructured(parser, &arg, offset, sizeof(arg));
+
+    switch (arg.reg_type)
+    {
+        case FX_4_FXLC_REG_LITERAL:
+            count = code->scalar ? 1 : code->comp_count;
+            if (arg.address >= code->cli4_count || count > code->cli4_count - arg.address)
+            {
+                vkd3d_string_buffer_printf(&parser->buffer, "(<out-of-bounds>)");
+                parser->failed = true;
+                break;
+            }
+
+            vkd3d_string_buffer_printf(&parser->buffer, "(");
+            vkd3d_string_buffer_print_f32(&parser->buffer, code->cli4[arg.address]);
+            for (unsigned int i = 1; i < code->comp_count; ++i)
+            {
+                vkd3d_string_buffer_printf(&parser->buffer, ", ");
+                vkd3d_string_buffer_print_f32(&parser->buffer, code->cli4[arg.address + (code->scalar ? 0 : i)]);
+            }
+            vkd3d_string_buffer_printf(&parser->buffer, ")");
+            break;
+
+        case FX_4_FXLC_REG_CB:
+            fx_4_parse_fxlc_constant_argument(parser, &arg, code);
+            break;
+
+        case FX_4_FXLC_REG_OUTPUT:
+        case FX_4_FXLC_REG_TEMP:
+            if (arg.reg_type == FX_4_FXLC_REG_OUTPUT)
+                vkd3d_string_buffer_printf(&parser->buffer, "expr");
+            else
+                vkd3d_string_buffer_printf(&parser->buffer, "r%u", arg.address / 4);
+            fx_4_parse_print_swizzle(parser, code, arg.address);
+            break;
+
+        default:
+            vkd3d_string_buffer_printf(&parser->buffer, "<unknown register %u>", arg.reg_type);
+            break;
+    }
+}
+
+static void fx_4_parse_fxlvm_expression(struct fx_parser *parser, uint32_t offset)
+{
+    struct vkd3d_shader_dxbc_section_desc *section, fxlc, cli4, ctab;
+    struct vkd3d_shader_dxbc_desc dxbc_desc;
+    struct vkd3d_shader_code dxbc;
+    uint32_t size, ins_count;
+    struct fxlvm_code code;
+    size_t i, j;
+
+    offset = fx_parser_read_unstructured(parser, &size, offset, sizeof(size));
+
+    dxbc.size = size;
+    dxbc.code = fx_parser_get_unstructured_ptr(parser, offset, size);
+    if (!dxbc.code)
+        return;
+
+    if (vkd3d_shader_parse_dxbc(&dxbc, 0, &dxbc_desc, NULL) < 0)
+    {
+        parser->failed = true;
+        return;
+    }
+
+    memset(&fxlc, 0, sizeof(fxlc));
+    memset(&cli4, 0, sizeof(cli4));
+    memset(&ctab, 0, sizeof(ctab));
+    for (i = 0; i < dxbc_desc.section_count; ++i)
+    {
+        section = &dxbc_desc.sections[i];
+
+        if (section->tag == TAG_FXLC)
+            fxlc = *section;
+        else if (section->tag == TAG_CLI4)
+            cli4 = *section;
+        else if (section->tag == TAG_CTAB)
+            ctab = *section;
+    }
+
+    vkd3d_shader_free_dxbc(&dxbc_desc);
+
+    if (cli4.data.code)
+    {
+        uint32_t cli4_offset = offset + (size_t)cli4.data.code - (size_t)dxbc.code;
+
+        fx_parser_read_unstructured(parser, &code.cli4_count, cli4_offset, sizeof(code.cli4_count));
+        code.cli4 = fx_parser_get_unstructured_ptr(parser, cli4_offset + 4, code.cli4_count * sizeof(float));
+    }
+
+    if (ctab.data.code)
+    {
+        uint32_t ctab_offset = offset + (size_t)ctab.data.code - (size_t)dxbc.code;
+        uint32_t consts_offset;
+
+        fx_parser_read_unstructured(parser, &code.ctab_count, ctab_offset + 12, sizeof(code.ctab_count));
+        fx_parser_read_unstructured(parser, &consts_offset, ctab_offset + 16, sizeof(consts_offset));
+
+        code.ctab = ctab.data.code;
+        code.constants = fx_parser_get_unstructured_ptr(parser,
+                ctab_offset + consts_offset, code.ctab_count * sizeof(*code.constants));
+    }
+
+    offset += (size_t)fxlc.data.code - (size_t)dxbc.code;
+    offset = fx_parser_read_unstructured(parser, &ins_count, offset, sizeof(ins_count));
+
+    parse_fx_start_indent(parser);
+
+    for (i = 0; i < ins_count; ++i)
+    {
+        uint32_t instr, opcode, src_count;
+        struct fx_4_fxlc_argument arg;
+
+        offset = fx_parser_read_unstructured(parser, &instr, offset, sizeof(instr));
+        offset = fx_parser_read_unstructured(parser, &src_count, offset, sizeof(src_count));
+
+        opcode = (instr >> FX_4_FXLC_OPCODE_SHIFT) & FX_4_FXLC_OPCODE_MASK;
+        code.comp_count = instr & FX_4_FXLC_COMP_COUNT_MASK;
+        code.scalar = false;
+
+        parse_fx_print_indent(parser);
+        vkd3d_string_buffer_printf(&parser->buffer, "%s ", fx_4_get_fxlc_opcode_name(opcode));
+
+        /* Destination first. */
+        fx_4_parse_fxlc_argument(parser, offset + sizeof(arg) * src_count, &code);
+
+        for (j = 0; j < src_count; ++j)
+        {
+            vkd3d_string_buffer_printf(&parser->buffer, ", ");
+
+            /* Scalar modifier applies only to first source. */
+            code.scalar = j == 0 && !!(instr & FX_4_FXLC_IS_SCALAR_MASK);
+            fx_4_parse_fxlc_argument(parser, offset, &code);
+
+            offset += sizeof(arg);
+        }
+
+        /* Destination */
+        offset += sizeof(arg);
+
+        vkd3d_string_buffer_printf(&parser->buffer, "\n");
+    }
+
+    parse_fx_end_indent(parser);
+}
+
 static void fx_4_parse_state_object_initializer(struct fx_parser *parser, uint32_t count,
         enum hlsl_type_class type_class)
 {
-    struct fx_4_assignment
-    {
-        uint32_t id;
-        uint32_t lhs_index;
-        uint32_t type;
-        uint32_t value;
-    } entry;
+    struct fx_assignment entry;
     struct
     {
         uint32_t name;
@@ -3390,7 +4608,7 @@ static void fx_4_parse_state_object_initializer(struct fx_parser *parser, uint32
             float f;
         };
     } value;
-    static const char *value_types[FX_COMPONENT_TYPE_COUNT] =
+    static const char *const value_types[FX_COMPONENT_TYPE_COUNT] =
     {
         [FX_BOOL]  = "bool",
         [FX_FLOAT] = "float",
@@ -3496,6 +4714,19 @@ static void fx_4_parse_state_object_initializer(struct fx_parser *parser, uint32
                 vkd3d_string_buffer_printf(&parser->buffer, "%s[%s]", fx_4_get_string(parser, index.name),
                         fx_4_get_string(parser, index.index));
                 break;
+            case FX_4_ASSIGNMENT_INDEX_EXPRESSION:
+                fx_parser_read_unstructured(parser, &index, entry.value, sizeof(index));
+                vkd3d_string_buffer_printf(&parser->buffer, "%s[eval(\n", fx_4_get_string(parser, index.name));
+                fx_4_parse_fxlvm_expression(parser, index.index);
+                parse_fx_print_indent(parser);
+                vkd3d_string_buffer_printf(&parser->buffer, ")]");
+                break;
+            case FX_4_ASSIGNMENT_VALUE_EXPRESSION:
+                vkd3d_string_buffer_printf(&parser->buffer, "eval(\n");
+                fx_4_parse_fxlvm_expression(parser, entry.value);
+                parse_fx_print_indent(parser);
+                vkd3d_string_buffer_printf(&parser->buffer, ")");
+                break;
             case FX_4_ASSIGNMENT_INLINE_SHADER:
             case FX_5_ASSIGNMENT_INLINE_SHADER:
             {
@@ -3544,12 +4775,14 @@ static void fx_4_parse_object_initializer(struct fx_parser *parser, const struct
     };
     unsigned int i, element_count, count;
     uint32_t value;
+    bool is_array;
 
     if (!fx_4_object_has_initializer(type))
         return;
 
     vkd3d_string_buffer_printf(&parser->buffer, " = {\n");
     element_count = max(type->element_count, 1);
+    is_array = element_count > 1;
     for (i = 0; i < element_count; ++i)
     {
         switch (type->typeinfo)
@@ -3565,9 +4798,21 @@ static void fx_4_parse_object_initializer(struct fx_parser *parser, const struct
             case FX_4_OBJECT_TYPE_SAMPLER_STATE:
                 count = fx_parser_read_u32(parser);
 
+                if (is_array)
+                {
+                    parse_fx_start_indent(parser);
+                    parse_fx_print_indent(parser);
+                    vkd3d_string_buffer_printf(&parser->buffer, "{\n");
+                }
                 parse_fx_start_indent(parser);
                 fx_4_parse_state_object_initializer(parser, count, type_classes[type->typeinfo]);
                 parse_fx_end_indent(parser);
+                if (is_array)
+                {
+                    parse_fx_print_indent(parser);
+                    vkd3d_string_buffer_printf(&parser->buffer, "}");
+                    parse_fx_end_indent(parser);
+                }
                 break;
             case FX_4_OBJECT_TYPE_PIXEL_SHADER:
             case FX_4_OBJECT_TYPE_VERTEX_SHADER:
@@ -3586,7 +4831,7 @@ static void fx_4_parse_object_initializer(struct fx_parser *parser, const struct
                         "Parsing object type %u is not implemented.", type->typeinfo);
                 return;
         }
-        vkd3d_string_buffer_printf(&parser->buffer, ",\n");
+        vkd3d_string_buffer_printf(&parser->buffer, is_array ? ",\n" : "\n");
     }
     vkd3d_string_buffer_printf(&parser->buffer, "}");
 }
@@ -3719,7 +4964,7 @@ static void fx_parse_groups(struct fx_parser *parser)
     }
 }
 
-static int fx_4_parse(struct fx_parser *parser)
+static void fx_4_parse(struct fx_parser *parser)
 {
     struct fx_4_header
     {
@@ -3752,8 +4997,9 @@ static int fx_4_parse(struct fx_parser *parser)
 
     if (parser->end - parser->ptr < header.unstructured_size)
     {
-        parser->failed = true;
-        return -1;
+        fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_INVALID_SIZE,
+                "Invalid unstructured data size %u.", header.unstructured_size);
+        return;
     }
 
     parser->unstructured.ptr = parser->ptr;
@@ -3766,11 +5012,9 @@ static int fx_4_parse(struct fx_parser *parser)
 
     for (i = 0; i < header.technique_count; ++i)
         fx_parse_fx_4_technique(parser);
-
-    return parser->failed ? - 1 : 0;
 }
 
-static int fx_5_parse(struct fx_parser *parser)
+static void fx_5_parse(struct fx_parser *parser)
 {
     struct fx_5_header
     {
@@ -3808,8 +5052,9 @@ static int fx_5_parse(struct fx_parser *parser)
 
     if (parser->end - parser->ptr < header.unstructured_size)
     {
-        parser->failed = true;
-        return -1;
+        fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_INVALID_SIZE,
+                "Invalid unstructured data size %u.", header.unstructured_size);
+        return;
     }
 
     parser->unstructured.ptr = parser->ptr;
@@ -3821,48 +5066,62 @@ static int fx_5_parse(struct fx_parser *parser)
     fx_4_parse_objects(parser);
 
     fx_parse_groups(parser);
+}
+
+static void fx_parser_init(struct fx_parser *parser, const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_message_context *message_context)
+{
+    memset(parser, 0, sizeof(*parser));
+    parser->start = compile_info->source.code;
+    parser->ptr = compile_info->source.code;
+    parser->end = (uint8_t *)compile_info->source.code + compile_info->source.size;
+    parser->message_context = message_context;
+    vkd3d_string_buffer_init(&parser->buffer);
+}
 
-    return parser->failed ? - 1 : 0;
+static void fx_parser_cleanup(struct fx_parser *parser)
+{
+    free(parser->objects.types);
 }
 
 int fx_parse(const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context)
 {
-    struct fx_parser parser =
-    {
-        .start = compile_info->source.code,
-        .ptr = compile_info->source.code,
-        .end = (uint8_t *)compile_info->source.code + compile_info->source.size,
-        .message_context = message_context,
-    };
+    struct fx_parser parser;
     uint32_t version;
-    int ret;
 
-    vkd3d_string_buffer_init(&parser.buffer);
+    fx_parser_init(&parser, compile_info, message_context);
 
     if (parser.end - parser.start < sizeof(version))
-        return -1;
+    {
+        fx_parser_error(&parser, VKD3D_SHADER_ERROR_FX_INVALID_SIZE,
+                "Source size %zu is smaller than the FX header size.", compile_info->source.size);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
     version = *(uint32_t *)parser.ptr;
 
     switch (version)
     {
         case 0xfeff0901:
-            ret = fx_2_parse(&parser);
+            fx_2_parse(&parser);
             break;
         case 0xfeff1001:
         case 0xfeff1011:
-            ret = fx_4_parse(&parser);
+            fx_4_parse(&parser);
             break;
         case 0xfeff2001:
-            ret = fx_5_parse(&parser);
+            fx_5_parse(&parser);
             break;
         default:
             fx_parser_error(&parser, VKD3D_SHADER_ERROR_FX_INVALID_VERSION,
                     "Invalid effect binary version value 0x%08x.", version);
-            ret = -1;
+            break;
     }
 
     vkd3d_shader_code_from_string_buffer(out, &parser.buffer);
+    fx_parser_cleanup(&parser);
 
-    return ret;
+    if (parser.failed)
+        return VKD3D_ERROR_INVALID_SHADER;
+    return VKD3D_OK;
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 41586550203..a7641a203f3 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -298,6 +298,39 @@ bool hlsl_type_is_patch_array(const struct hlsl_type *type)
             || type->e.array.array_type == HLSL_ARRAY_PATCH_OUTPUT);
 }
 
+bool hlsl_base_type_is_integer(enum hlsl_base_type type)
+{
+    switch (type)
+    {
+        case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_INT:
+        case HLSL_TYPE_MIN16UINT:
+        case HLSL_TYPE_UINT:
+            return true;
+
+        case HLSL_TYPE_DOUBLE:
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_HALF:
+            return false;
+    }
+
+    vkd3d_unreachable();
+}
+
+bool hlsl_type_is_integer(const struct hlsl_type *type)
+{
+    VKD3D_ASSERT(hlsl_is_numeric_type(type));
+    return hlsl_base_type_is_integer(type->e.numeric.type);
+}
+
+bool hlsl_type_is_floating_point(const struct hlsl_type *type)
+{
+    if (!hlsl_is_numeric_type(type))
+        return false;
+
+    return !hlsl_type_is_integer(type);
+}
+
 /* Only intended to be used for derefs (after copies have been lowered to components or vectors) or
  * resources, since for both their data types span across a single regset. */
 static enum hlsl_regset type_get_regset(const struct hlsl_type *type)
@@ -484,6 +517,8 @@ static struct hlsl_type *hlsl_new_type(struct hlsl_ctx *ctx, const char *name, e
 {
     struct hlsl_type *type;
 
+    TRACE("New type %s.\n", name);
+
     if (!(type = hlsl_alloc(ctx, sizeof(*type))))
         return NULL;
     if (!(type->name = hlsl_strdup(ctx, name)))
@@ -845,13 +880,7 @@ static bool init_deref_from_component_index(struct hlsl_ctx *ctx, struct hlsl_bl
     {
         unsigned int next_index = traverse_path_from_component_index(ctx, &path_type, &path_index);
 
-        if (!(c = hlsl_new_uint_constant(ctx, next_index, loc)))
-        {
-            hlsl_block_cleanup(block);
-            return false;
-        }
-        hlsl_block_add_instr(block, c);
-
+        c = hlsl_block_add_uint_constant(ctx, block, next_index, loc);
         hlsl_src_from_node(&deref->path[deref_path_len++], c);
     }
 
@@ -1324,15 +1353,16 @@ bool hlsl_scope_add_type(struct hlsl_scope *scope, struct hlsl_type *type)
     return true;
 }
 
-struct hlsl_ir_node *hlsl_new_cast(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct hlsl_type *type,
-        const struct vkd3d_shader_location *loc)
+static struct hlsl_ir_node *append_new_instr(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_node *instr)
 {
-    struct hlsl_ir_node *cast;
+    if (!instr)
+    {
+        block->value = ctx->error_instr;
+        return ctx->error_instr;
+    }
 
-    cast = hlsl_new_unary_expr(ctx, HLSL_OP1_CAST, node, loc);
-    if (cast)
-        cast->data_type = type;
-    return cast;
+    hlsl_block_add_instr(block, instr);
+    return instr;
 }
 
 struct hlsl_ir_node *hlsl_new_copy(struct hlsl_ctx *ctx, struct hlsl_ir_node *node)
@@ -1510,22 +1540,36 @@ struct hlsl_ir_node *hlsl_new_store_index(struct hlsl_ctx *ctx, const struct hls
     return &store->node;
 }
 
-bool hlsl_new_store_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
+void hlsl_block_add_store_index(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        const struct hlsl_deref *lhs, struct hlsl_ir_node *idx, struct hlsl_ir_node *rhs,
+        unsigned int writemask, const struct vkd3d_shader_location *loc)
+{
+    append_new_instr(ctx, block, hlsl_new_store_index(ctx, lhs, idx, rhs, writemask, loc));
+}
+
+void hlsl_block_add_simple_store(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_var *lhs, struct hlsl_ir_node *rhs)
+{
+    struct hlsl_deref lhs_deref;
+
+    hlsl_init_simple_deref_from_var(&lhs_deref, lhs);
+    hlsl_block_add_store_index(ctx, block, &lhs_deref, NULL, rhs, 0, &rhs->loc);
+}
+
+void hlsl_block_add_store_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
         const struct hlsl_deref *lhs, unsigned int comp, struct hlsl_ir_node *rhs)
 {
     struct hlsl_block comp_path_block;
     struct hlsl_ir_store *store;
 
-    hlsl_block_init(block);
-
     if (!(store = hlsl_alloc(ctx, sizeof(*store))))
-        return false;
+        return;
     init_node(&store->node, HLSL_IR_STORE, NULL, &rhs->loc);
 
     if (!init_deref_from_component_index(ctx, &comp_path_block, &store->lhs, lhs, comp, &rhs->loc))
     {
         vkd3d_free(store);
-        return false;
+        return;
     }
     hlsl_block_add_block(block, &comp_path_block);
     hlsl_src_from_node(&store->rhs, rhs);
@@ -1534,8 +1578,6 @@ bool hlsl_new_store_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
         store->writemask = (1 << rhs->data_type->e.numeric.dimx) - 1;
 
     hlsl_block_add_instr(block, &store->node);
-
-    return true;
 }
 
 struct hlsl_ir_node *hlsl_new_call(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *decl,
@@ -1575,7 +1617,7 @@ struct hlsl_ir_node *hlsl_new_bool_constant(struct hlsl_ctx *ctx, bool b, const
     return hlsl_new_constant(ctx, hlsl_get_scalar_type(ctx, HLSL_TYPE_BOOL), &value, loc);
 }
 
-struct hlsl_ir_node *hlsl_new_float_constant(struct hlsl_ctx *ctx, float f,
+static struct hlsl_ir_node *hlsl_new_float_constant(struct hlsl_ctx *ctx, float f,
         const struct vkd3d_shader_location *loc)
 {
     struct hlsl_constant_value value;
@@ -1584,7 +1626,14 @@ struct hlsl_ir_node *hlsl_new_float_constant(struct hlsl_ctx *ctx, float f,
     return hlsl_new_constant(ctx, hlsl_get_scalar_type(ctx, HLSL_TYPE_FLOAT), &value, loc);
 }
 
-struct hlsl_ir_node *hlsl_new_int_constant(struct hlsl_ctx *ctx, int32_t n, const struct vkd3d_shader_location *loc)
+struct hlsl_ir_node *hlsl_block_add_float_constant(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        float f, const struct vkd3d_shader_location *loc)
+{
+    return append_new_instr(ctx, block, hlsl_new_float_constant(ctx, f, loc));
+}
+
+static struct hlsl_ir_node *hlsl_new_int_constant(struct hlsl_ctx *ctx, int32_t n,
+        const struct vkd3d_shader_location *loc)
 {
     struct hlsl_constant_value value;
 
@@ -1592,6 +1641,12 @@ struct hlsl_ir_node *hlsl_new_int_constant(struct hlsl_ctx *ctx, int32_t n, cons
     return hlsl_new_constant(ctx, hlsl_get_scalar_type(ctx, HLSL_TYPE_INT), &value, loc);
 }
 
+struct hlsl_ir_node *hlsl_block_add_int_constant(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        int32_t n, const struct vkd3d_shader_location *loc)
+{
+    return append_new_instr(ctx, block, hlsl_new_int_constant(ctx, n, loc));
+}
+
 struct hlsl_ir_node *hlsl_new_uint_constant(struct hlsl_ctx *ctx, unsigned int n,
         const struct vkd3d_shader_location *loc)
 {
@@ -1601,6 +1656,12 @@ struct hlsl_ir_node *hlsl_new_uint_constant(struct hlsl_ctx *ctx, unsigned int n
     return hlsl_new_constant(ctx, hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), &value, loc);
 }
 
+struct hlsl_ir_node *hlsl_block_add_uint_constant(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        unsigned int n, const struct vkd3d_shader_location *loc)
+{
+    return append_new_instr(ctx, block, hlsl_new_uint_constant(ctx, n, loc));
+}
+
 struct hlsl_ir_node *hlsl_new_string_constant(struct hlsl_ctx *ctx, const char *str,
         const struct vkd3d_shader_location *loc)
 {
@@ -1625,7 +1686,7 @@ struct hlsl_ir_node *hlsl_new_null_constant(struct hlsl_ctx *ctx, const struct v
     return hlsl_new_constant(ctx, ctx->builtin_types.null, &value, loc);
 }
 
-struct hlsl_ir_node *hlsl_new_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
+static struct hlsl_ir_node *hlsl_new_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
         struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS],
         struct hlsl_type *data_type, const struct vkd3d_shader_location *loc)
 {
@@ -1641,7 +1702,14 @@ struct hlsl_ir_node *hlsl_new_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op
     return &expr->node;
 }
 
-struct hlsl_ir_node *hlsl_new_unary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
+struct hlsl_ir_node *hlsl_block_add_expr(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        enum hlsl_ir_expr_op op, struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS],
+        struct hlsl_type *data_type, const struct vkd3d_shader_location *loc)
+{
+    return append_new_instr(ctx, block, hlsl_new_expr(ctx, op, operands, data_type, loc));
+}
+
+static struct hlsl_ir_node *hlsl_new_unary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
         struct hlsl_ir_node *arg, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {arg};
@@ -1649,6 +1717,12 @@ struct hlsl_ir_node *hlsl_new_unary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr
     return hlsl_new_expr(ctx, op, operands, arg->data_type, loc);
 }
 
+struct hlsl_ir_node *hlsl_block_add_unary_expr(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        enum hlsl_ir_expr_op op, struct hlsl_ir_node *arg, const struct vkd3d_shader_location *loc)
+{
+    return append_new_instr(ctx, block, hlsl_new_unary_expr(ctx, op, arg, loc));
+}
+
 struct hlsl_ir_node *hlsl_new_binary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
         struct hlsl_ir_node *arg1, struct hlsl_ir_node *arg2)
 {
@@ -1657,16 +1731,37 @@ struct hlsl_ir_node *hlsl_new_binary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_exp
     return hlsl_new_expr(ctx, op, operands, arg1->data_type, &arg1->loc);
 }
 
+struct hlsl_ir_node *hlsl_block_add_binary_expr(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        enum hlsl_ir_expr_op op, struct hlsl_ir_node *arg1, struct hlsl_ir_node *arg2)
+{
+    return append_new_instr(ctx, block, hlsl_new_binary_expr(ctx, op, arg1, arg2));
+}
+
 struct hlsl_ir_node *hlsl_new_ternary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
         struct hlsl_ir_node *arg1, struct hlsl_ir_node *arg2, struct hlsl_ir_node *arg3)
 {
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {arg1, arg2, arg3};
 
-    VKD3D_ASSERT(hlsl_types_are_equal(arg1->data_type, arg2->data_type));
-    VKD3D_ASSERT(hlsl_types_are_equal(arg1->data_type, arg3->data_type));
     return hlsl_new_expr(ctx, op, operands, arg1->data_type, &arg1->loc);
 }
 
+struct hlsl_ir_node *hlsl_new_cast(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct hlsl_type *type,
+        const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_node *cast;
+
+    cast = hlsl_new_unary_expr(ctx, HLSL_OP1_CAST, node, loc);
+    if (cast)
+        cast->data_type = type;
+    return cast;
+}
+
+struct hlsl_ir_node *hlsl_block_add_cast(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_node *arg, struct hlsl_type *type, const struct vkd3d_shader_location *loc)
+{
+    return append_new_instr(ctx, block, hlsl_new_cast(ctx, arg, type, loc));
+}
+
 static struct hlsl_ir_node *hlsl_new_error_expr(struct hlsl_ctx *ctx)
 {
     static const struct vkd3d_shader_location loc = {.source_name = "<error>"};
@@ -1694,6 +1789,23 @@ struct hlsl_ir_node *hlsl_new_if(struct hlsl_ctx *ctx, struct hlsl_ir_node *cond
     return &iff->node;
 }
 
+void hlsl_block_add_if(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_node *condition,
+        struct hlsl_block *then_block, struct hlsl_block *else_block, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_node *instr = hlsl_new_if(ctx, condition, then_block, else_block, loc);
+
+    if (instr)
+    {
+        hlsl_block_add_instr(block, instr);
+    }
+    else
+    {
+        hlsl_block_cleanup(then_block);
+        if (else_block)
+            hlsl_block_cleanup(else_block);
+    }
+}
+
 struct hlsl_ir_switch_case *hlsl_new_switch_case(struct hlsl_ctx *ctx, unsigned int value,
         bool is_default, struct hlsl_block *body, const struct vkd3d_shader_location *loc)
 {
@@ -1758,6 +1870,14 @@ struct hlsl_ir_load *hlsl_new_load_index(struct hlsl_ctx *ctx, const struct hlsl
     return load;
 }
 
+struct hlsl_ir_node *hlsl_block_add_load_index(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        const struct hlsl_deref *deref, struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_load *load = hlsl_new_load_index(ctx, deref, idx, loc);
+
+    return append_new_instr(ctx, block, load ? &load->node : NULL);
+}
+
 struct hlsl_ir_load *hlsl_new_load_parent(struct hlsl_ctx *ctx, const struct hlsl_deref *deref,
         const struct vkd3d_shader_location *loc)
 {
@@ -1780,17 +1900,27 @@ struct hlsl_ir_load *hlsl_new_var_load(struct hlsl_ctx *ctx, struct hlsl_ir_var
     return hlsl_new_load_index(ctx, &var_deref, NULL, loc);
 }
 
-struct hlsl_ir_node *hlsl_new_load_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
+struct hlsl_ir_node *hlsl_block_add_simple_load(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_var *var, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_deref var_deref;
+
+    hlsl_init_simple_deref_from_var(&var_deref, var);
+    return hlsl_block_add_load_index(ctx, block, &var_deref, NULL, loc);
+}
+
+struct hlsl_ir_node *hlsl_block_add_load_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
         const struct hlsl_deref *deref, unsigned int comp, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_type *type, *comp_type;
     struct hlsl_block comp_path_block;
     struct hlsl_ir_load *load;
 
-    hlsl_block_init(block);
-
     if (!(load = hlsl_alloc(ctx, sizeof(*load))))
-        return NULL;
+    {
+        block->value = ctx->error_instr;
+        return ctx->error_instr;
+    }
 
     type = hlsl_deref_get_type(ctx, deref);
     comp_type = hlsl_type_get_component_type(ctx, type, comp);
@@ -1799,7 +1929,8 @@ struct hlsl_ir_node *hlsl_new_load_component(struct hlsl_ctx *ctx, struct hlsl_b
     if (!init_deref_from_component_index(ctx, &comp_path_block, &load->src, deref, comp, loc))
     {
         vkd3d_free(load);
-        return NULL;
+        block->value = ctx->error_instr;
+        return ctx->error_instr;
     }
     hlsl_block_add_block(block, &comp_path_block);
 
@@ -1847,7 +1978,7 @@ struct hlsl_ir_node *hlsl_new_resource_load(struct hlsl_ctx *ctx,
     return &load->node;
 }
 
-struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx, const struct hlsl_deref *resource,
+static struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx, const struct hlsl_deref *resource,
         struct hlsl_ir_node *coords, struct hlsl_ir_node *value, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_resource_store *store;
@@ -1861,12 +1992,21 @@ struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx, const struct
     return &store->node;
 }
 
+void hlsl_block_add_resource_store(struct hlsl_ctx *ctx, struct hlsl_block *block, const struct hlsl_deref *resource,
+        struct hlsl_ir_node *coords, struct hlsl_ir_node *value, const struct vkd3d_shader_location *loc)
+{
+    append_new_instr(ctx, block, hlsl_new_resource_store(ctx, resource, coords, value, loc));
+}
+
 struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, uint32_t s, unsigned int component_count,
         struct hlsl_ir_node *val, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_swizzle *swizzle;
     struct hlsl_type *type;
 
+    if (val->data_type->class == HLSL_CLASS_ERROR)
+        return val;
+
     VKD3D_ASSERT(val->data_type->class <= HLSL_CLASS_VECTOR);
 
     if (!(swizzle = hlsl_alloc(ctx, sizeof(*swizzle))))
@@ -2078,7 +2218,7 @@ bool hlsl_index_chain_has_resource_access(struct hlsl_ir_index *index)
     return false;
 }
 
-struct hlsl_ir_node *hlsl_new_index(struct hlsl_ctx *ctx, struct hlsl_ir_node *val,
+static struct hlsl_ir_node *hlsl_new_index(struct hlsl_ctx *ctx, struct hlsl_ir_node *val,
         struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_type *type = val->data_type;
@@ -2100,7 +2240,13 @@ struct hlsl_ir_node *hlsl_new_index(struct hlsl_ctx *ctx, struct hlsl_ir_node *v
     return &index->node;
 }
 
-struct hlsl_ir_node *hlsl_new_jump(struct hlsl_ctx *ctx, enum hlsl_ir_jump_type type,
+struct hlsl_ir_node *hlsl_block_add_index(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_node *val, struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc)
+{
+    return append_new_instr(ctx, block, hlsl_new_index(ctx, val, idx, loc));
+}
+
+static struct hlsl_ir_node *hlsl_new_jump(struct hlsl_ctx *ctx, enum hlsl_ir_jump_type type,
         struct hlsl_ir_node *condition, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_jump *jump;
@@ -2113,7 +2259,13 @@ struct hlsl_ir_node *hlsl_new_jump(struct hlsl_ctx *ctx, enum hlsl_ir_jump_type
     return &jump->node;
 }
 
-struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx, struct hlsl_block *iter,
+void hlsl_block_add_jump(struct hlsl_ctx *ctx, struct hlsl_block *block, enum hlsl_ir_jump_type type,
+        struct hlsl_ir_node *condition, const struct vkd3d_shader_location *loc)
+{
+    append_new_instr(ctx, block, hlsl_new_jump(ctx, type, condition, loc));
+}
+
+static struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx, struct hlsl_block *iter,
         struct hlsl_block *block, enum hlsl_loop_unroll_type unroll_type,
         unsigned int unroll_limit, const struct vkd3d_shader_location *loc)
 {
@@ -2134,6 +2286,18 @@ struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx, struct hlsl_block *iter
     return &loop->node;
 }
 
+void hlsl_block_add_loop(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_block *iter, struct hlsl_block *body, enum hlsl_loop_unroll_type unroll_type,
+        unsigned int unroll_limit, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_node *instr = hlsl_new_loop(ctx, iter, body, unroll_type, unroll_limit, loc);
+
+    if (instr)
+        hlsl_block_add_instr(block, instr);
+    else
+        hlsl_block_cleanup(body);
+}
+
 struct clone_instr_map
 {
     struct
@@ -2650,8 +2814,8 @@ struct hlsl_ir_function_decl *hlsl_new_func_decl(struct hlsl_ctx *ctx,
         struct hlsl_type *return_type, const struct hlsl_func_parameters *parameters,
         const struct hlsl_semantic *semantic, const struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_node *constant, *store;
     struct hlsl_ir_function_decl *decl;
+    struct hlsl_ir_node *constant;
 
     if (!(decl = hlsl_alloc(ctx, sizeof(*decl))))
         return NULL;
@@ -2679,9 +2843,7 @@ struct hlsl_ir_function_decl *hlsl_new_func_decl(struct hlsl_ctx *ctx,
         return decl;
     hlsl_block_add_instr(&decl->body, constant);
 
-    if (!(store = hlsl_new_simple_store(ctx, decl->early_return_var, constant)))
-        return decl;
-    hlsl_block_add_instr(&decl->body, store);
+    hlsl_block_add_simple_store(ctx, &decl->body, decl->early_return_var, constant);
 
     return decl;
 }
@@ -2796,6 +2958,7 @@ static void hlsl_dump_type(struct vkd3d_string_buffer *buffer, const struct hlsl
         [HLSL_TYPE_HALF] = "half",
         [HLSL_TYPE_DOUBLE] = "double",
         [HLSL_TYPE_INT] = "int",
+        [HLSL_TYPE_MIN16UINT] = "min16uint",
         [HLSL_TYPE_UINT] = "uint",
         [HLSL_TYPE_BOOL] = "bool",
     };
@@ -3263,6 +3426,7 @@ static void dump_ir_constant(struct vkd3d_string_buffer *buffer, const struct hl
                 vkd3d_string_buffer_printf(buffer, "%d ", value->i);
                 break;
 
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 vkd3d_string_buffer_printf(buffer, "%u ", value->u);
                 break;
@@ -4289,17 +4453,17 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
 
     static const char * const names[] =
     {
-        [HLSL_TYPE_FLOAT]  = "float",
-        [HLSL_TYPE_HALF]   = "half",
-        [HLSL_TYPE_DOUBLE] = "double",
-        [HLSL_TYPE_INT]    = "int",
-        [HLSL_TYPE_UINT]   = "uint",
-        [HLSL_TYPE_BOOL]   = "bool",
+        [HLSL_TYPE_FLOAT]       = "float",
+        [HLSL_TYPE_HALF]        = "half",
+        [HLSL_TYPE_DOUBLE]      = "double",
+        [HLSL_TYPE_INT]         = "int",
+        [HLSL_TYPE_UINT]        = "uint",
+        [HLSL_TYPE_BOOL]        = "bool",
+        [HLSL_TYPE_MIN16UINT]   = "min16uint",
     };
 
     static const char *const variants_float[] = {"min10float", "min16float"};
     static const char *const variants_int[] = {"min12int", "min16int"};
-    static const char *const variants_uint[] = {"min16uint"};
 
     static const char *const sampler_names[] =
     {
@@ -4390,11 +4554,6 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
                 n_variants = ARRAY_SIZE(variants_int);
                 break;
 
-            case HLSL_TYPE_UINT:
-                variants = variants_uint;
-                n_variants = ARRAY_SIZE(variants_uint);
-                break;
-
             default:
                 n_variants = 0;
                 variants = NULL;
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index f614e12036e..2ef84d35ff2 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -103,6 +103,7 @@ enum hlsl_base_type
     HLSL_TYPE_DOUBLE,
     HLSL_TYPE_INT,
     HLSL_TYPE_UINT,
+    HLSL_TYPE_MIN16UINT,
     HLSL_TYPE_BOOL,
     HLSL_TYPE_LAST_SCALAR = HLSL_TYPE_BOOL,
 };
@@ -482,6 +483,9 @@ struct hlsl_ir_var
         union hlsl_constant_value_component number;
     } *default_values;
 
+    /* Pointer to the temp copy of the variable, in case it is uniform. */
+    struct hlsl_ir_var *temp_copy;
+
     /* A dynamic array containing the state block on the variable's declaration, if any.
      * An array variable may contain multiple state blocks.
      * A technique pass will always contain one.
@@ -1502,6 +1506,45 @@ struct hlsl_ir_node *hlsl_add_conditional(struct hlsl_ctx *ctx, struct hlsl_bloc
 void hlsl_add_function(struct hlsl_ctx *ctx, char *name, struct hlsl_ir_function_decl *decl);
 void hlsl_add_var(struct hlsl_ctx *ctx, struct hlsl_ir_var *decl);
 
+struct hlsl_ir_node *hlsl_block_add_binary_expr(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        enum hlsl_ir_expr_op op, struct hlsl_ir_node *arg1, struct hlsl_ir_node *arg2);
+struct hlsl_ir_node *hlsl_block_add_cast(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_node *arg, struct hlsl_type *type, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_block_add_expr(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        enum hlsl_ir_expr_op op, struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS],
+        struct hlsl_type *data_type, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_block_add_float_constant(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        float f, const struct vkd3d_shader_location *loc);
+void hlsl_block_add_if(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_node *condition,
+        struct hlsl_block *then_block, struct hlsl_block *else_block, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_block_add_index(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_node *val, struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_block_add_int_constant(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        int32_t n, const struct vkd3d_shader_location *loc);
+void hlsl_block_add_jump(struct hlsl_ctx *ctx, struct hlsl_block *block, enum hlsl_ir_jump_type type,
+        struct hlsl_ir_node *condition, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_block_add_load_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        const struct hlsl_deref *deref, unsigned int comp, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_block_add_load_index(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        const struct hlsl_deref *deref, struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc);
+void hlsl_block_add_loop(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_block *iter, struct hlsl_block *body, enum hlsl_loop_unroll_type unroll_type,
+        unsigned int unroll_limit, const struct vkd3d_shader_location *loc);
+void hlsl_block_add_resource_store(struct hlsl_ctx *ctx, struct hlsl_block *block, const struct hlsl_deref *resource,
+        struct hlsl_ir_node *coords, struct hlsl_ir_node *value, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_block_add_simple_load(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_var *var, const struct vkd3d_shader_location *loc);
+void hlsl_block_add_simple_store(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_var *lhs, struct hlsl_ir_node *rhs);
+void hlsl_block_add_store_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        const struct hlsl_deref *lhs, unsigned int comp, struct hlsl_ir_node *rhs);
+void hlsl_block_add_store_index(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        const struct hlsl_deref *lhs, struct hlsl_ir_node *idx, struct hlsl_ir_node *rhs,
+        unsigned int writemask, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_block_add_uint_constant(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        unsigned int n, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_block_add_unary_expr(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        enum hlsl_ir_expr_op op, struct hlsl_ir_node *arg, const struct vkd3d_shader_location *loc);
 void hlsl_block_cleanup(struct hlsl_block *block);
 bool hlsl_clone_block(struct hlsl_ctx *ctx, struct hlsl_block *dst_block, const struct hlsl_block *src_block);
 
@@ -1573,19 +1616,11 @@ struct hlsl_ir_node *hlsl_new_cast(struct hlsl_ctx *ctx, struct hlsl_ir_node *no
 struct hlsl_ir_node *hlsl_new_constant(struct hlsl_ctx *ctx, struct hlsl_type *type,
         const struct hlsl_constant_value *value, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_copy(struct hlsl_ctx *ctx, struct hlsl_ir_node *node);
-struct hlsl_ir_node *hlsl_new_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
-        struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS],
-        struct hlsl_type *data_type, const struct vkd3d_shader_location *loc);
-struct hlsl_ir_node *hlsl_new_float_constant(struct hlsl_ctx *ctx,
-        float f, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_function_decl *hlsl_new_func_decl(struct hlsl_ctx *ctx,
         struct hlsl_type *return_type, const struct hlsl_func_parameters *parameters,
         const struct hlsl_semantic *semantic, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_if(struct hlsl_ctx *ctx, struct hlsl_ir_node *condition,
         struct hlsl_block *then_block, struct hlsl_block *else_block, const struct vkd3d_shader_location *loc);
-struct hlsl_ir_node *hlsl_new_int_constant(struct hlsl_ctx *ctx, int32_t n, const struct vkd3d_shader_location *loc);
-struct hlsl_ir_node *hlsl_new_jump(struct hlsl_ctx *ctx,
-        enum hlsl_ir_jump_type type, struct hlsl_ir_node *condition, const struct vkd3d_shader_location *loc);
 struct hlsl_type *hlsl_new_stream_output_type(struct hlsl_ctx *ctx,
         enum hlsl_so_object_type so_type, struct hlsl_type *type);
 struct hlsl_ir_node *hlsl_new_ternary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
@@ -1599,16 +1634,12 @@ struct hlsl_ir_load *hlsl_new_load_index(struct hlsl_ctx *ctx, const struct hlsl
         struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_load *hlsl_new_load_parent(struct hlsl_ctx *ctx, const struct hlsl_deref *deref,
         const struct vkd3d_shader_location *loc);
-struct hlsl_ir_node *hlsl_new_load_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
-        const struct hlsl_deref *deref, unsigned int comp, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_add_load_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
         struct hlsl_ir_node *var_instr, unsigned int comp, const struct vkd3d_shader_location *loc);
 
 struct hlsl_ir_node *hlsl_new_simple_store(struct hlsl_ctx *ctx, struct hlsl_ir_var *lhs, struct hlsl_ir_node *rhs);
 struct hlsl_ir_node *hlsl_new_store_index(struct hlsl_ctx *ctx, const struct hlsl_deref *lhs,
         struct hlsl_ir_node *idx, struct hlsl_ir_node *rhs, unsigned int writemask, const struct vkd3d_shader_location *loc);
-bool hlsl_new_store_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
-        const struct hlsl_deref *lhs, unsigned int comp, struct hlsl_ir_node *rhs);
 
 bool hlsl_index_is_noncontiguous(struct hlsl_ir_index *index);
 bool hlsl_index_is_resource_access(struct hlsl_ir_index *index);
@@ -1617,20 +1648,13 @@ bool hlsl_index_chain_has_resource_access(struct hlsl_ir_index *index);
 struct hlsl_ir_node *hlsl_new_compile(struct hlsl_ctx *ctx, enum hlsl_compile_type compile_type,
         const char *profile_name, struct hlsl_ir_node **args, unsigned int args_count,
         struct hlsl_block *args_instrs, const struct vkd3d_shader_location *loc);
-struct hlsl_ir_node *hlsl_new_index(struct hlsl_ctx *ctx, struct hlsl_ir_node *val,
-        struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_interlocked(struct hlsl_ctx *ctx, enum hlsl_interlocked_op op, struct hlsl_type *type,
         const struct hlsl_deref *dst, struct hlsl_ir_node *coords, struct hlsl_ir_node *cmp_value,
         struct hlsl_ir_node *value, const struct vkd3d_shader_location *loc);
-struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx, struct hlsl_block *iter,
-        struct hlsl_block *block, enum hlsl_loop_unroll_type unroll_type,
-        unsigned int unroll_limit, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_matrix_swizzle(struct hlsl_ctx *ctx, struct hlsl_matrix_swizzle s,
         unsigned int width, struct hlsl_ir_node *val, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_resource_load(struct hlsl_ctx *ctx,
         const struct hlsl_resource_load_params *params, const struct vkd3d_shader_location *loc);
-struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx, const struct hlsl_deref *resource,
-        struct hlsl_ir_node *coords, struct hlsl_ir_node *value, const struct vkd3d_shader_location *loc);
 struct hlsl_type *hlsl_new_struct_type(struct hlsl_ctx *ctx, const char *name,
         struct hlsl_struct_field *fields, size_t field_count);
 struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, uint32_t s, unsigned int components,
@@ -1653,8 +1677,6 @@ struct hlsl_type *hlsl_new_cb_type(struct hlsl_ctx *ctx, struct hlsl_type *forma
 struct hlsl_ir_node *hlsl_new_uint_constant(struct hlsl_ctx *ctx, unsigned int n,
         const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_null_constant(struct hlsl_ctx *ctx, const struct vkd3d_shader_location *loc);
-struct hlsl_ir_node *hlsl_new_unary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op, struct hlsl_ir_node *arg,
-        const struct vkd3d_shader_location *loc);
 struct hlsl_ir_var *hlsl_new_var(struct hlsl_ctx *ctx, const char *name, struct hlsl_type *type,
         const struct vkd3d_shader_location *loc, const struct hlsl_semantic *semantic, uint32_t modifiers,
         const struct hlsl_reg_reservation *reg_reservation);
@@ -1677,6 +1699,8 @@ void hlsl_pop_scope(struct hlsl_ctx *ctx);
 
 bool hlsl_scope_add_type(struct hlsl_scope *scope, struct hlsl_type *type);
 
+bool hlsl_base_type_is_integer(enum hlsl_base_type type);
+
 struct hlsl_type *hlsl_type_clone(struct hlsl_ctx *ctx, struct hlsl_type *old,
         unsigned int default_majority, uint32_t modifiers);
 unsigned int hlsl_type_component_count(const struct hlsl_type *type);
@@ -1685,10 +1709,13 @@ struct hlsl_type *hlsl_type_get_component_type(struct hlsl_ctx *ctx, struct hlsl
         unsigned int index);
 unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_type *type,
         unsigned int index, enum hlsl_regset *regset);
+bool hlsl_type_is_integer(const struct hlsl_type *type);
+bool hlsl_type_is_floating_point(const struct hlsl_type *type);
 bool hlsl_type_is_row_major(const struct hlsl_type *type);
 unsigned int hlsl_type_minor_size(const struct hlsl_type *type);
 unsigned int hlsl_type_major_size(const struct hlsl_type *type);
 unsigned int hlsl_type_element_count(const struct hlsl_type *type);
+bool hlsl_type_is_integer(const struct hlsl_type *type);
 bool hlsl_type_is_resource(const struct hlsl_type *type);
 bool hlsl_type_is_shader(const struct hlsl_type *type);
 bool hlsl_type_is_patch_array(const struct hlsl_type *type);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index 7afc9274c2e..71802fce388 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -351,7 +351,6 @@ static struct hlsl_ir_node *add_cast(struct hlsl_ctx *ctx, struct hlsl_block *bl
         struct hlsl_ir_node *node, struct hlsl_type *dst_type, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_type *src_type = node->data_type;
-    struct hlsl_ir_node *cast;
 
     if (hlsl_types_are_equal(src_type, dst_type))
         return node;
@@ -359,11 +358,7 @@ static struct hlsl_ir_node *add_cast(struct hlsl_ctx *ctx, struct hlsl_block *bl
     if (src_type->class == HLSL_CLASS_NULL)
         return node;
 
-    if (!(cast = hlsl_new_cast(ctx, node, dst_type, loc)))
-        return NULL;
-    hlsl_block_add_instr(block, cast);
-
-    return cast;
+    return hlsl_block_add_cast(ctx, block, node, dst_type, loc);
 }
 
 static struct hlsl_ir_node *add_implicit_conversion(struct hlsl_ctx *ctx, struct hlsl_block *block,
@@ -456,7 +451,7 @@ static uint32_t add_modifiers(struct hlsl_ctx *ctx, uint32_t modifiers, uint32_t
 
 static bool append_conditional_break(struct hlsl_ctx *ctx, struct hlsl_block *cond_block)
 {
-    struct hlsl_ir_node *condition, *cast, *not, *iff, *jump;
+    struct hlsl_ir_node *condition, *cast, *not;
     struct hlsl_block then_block;
     struct hlsl_type *bool_type;
 
@@ -474,19 +469,11 @@ static bool append_conditional_break(struct hlsl_ctx *ctx, struct hlsl_block *co
     if (!(cast = add_cast(ctx, cond_block, condition, bool_type, &condition->loc)))
         return false;
 
-    if (!(not = hlsl_new_unary_expr(ctx, HLSL_OP1_LOGIC_NOT, cast, &condition->loc)))
-        return false;
-    hlsl_block_add_instr(cond_block, not);
+    not = hlsl_block_add_unary_expr(ctx, cond_block, HLSL_OP1_LOGIC_NOT, cast, &condition->loc);
 
     hlsl_block_init(&then_block);
-
-    if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_BREAK, NULL, &condition->loc)))
-        return false;
-    hlsl_block_add_instr(&then_block, jump);
-
-    if (!(iff = hlsl_new_if(ctx, not, &then_block, NULL, &condition->loc)))
-        return false;
-    hlsl_block_add_instr(cond_block, iff);
+    hlsl_block_add_jump(ctx, &then_block, HLSL_IR_JUMP_BREAK, NULL, &condition->loc);
+    hlsl_block_add_if(ctx, cond_block, not, &then_block, NULL, &condition->loc);
     return true;
 }
 
@@ -668,7 +655,6 @@ static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum hlsl_loop_type
 {
     enum hlsl_loop_unroll_type unroll_type = HLSL_LOOP_UNROLL;
     unsigned int i, unroll_limit = 0;
-    struct hlsl_ir_node *loop;
 
     check_attribute_list_for_duplicates(ctx, attributes);
     check_loop_attributes(ctx, attributes, loc);
@@ -727,9 +713,7 @@ static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum hlsl_loop_type
     else
         list_move_head(&body->instrs, &cond->instrs);
 
-    if (!(loop = hlsl_new_loop(ctx, iter, body, unroll_type, unroll_limit, loc)))
-        goto oom;
-    hlsl_block_add_instr(init, loop);
+    hlsl_block_add_loop(ctx, init, iter, body, unroll_type, unroll_limit, loc);
 
     destroy_block(cond);
     destroy_block(body);
@@ -858,23 +842,18 @@ static bool add_return(struct hlsl_ctx *ctx, struct hlsl_block *block,
         struct hlsl_ir_node *return_value, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_type *return_type = ctx->cur_function->return_type;
-    struct hlsl_ir_node *jump;
 
     if (ctx->cur_function->return_var)
     {
         if (return_value)
         {
-            struct hlsl_ir_node *store;
-
             if (return_value->data_type->class == HLSL_CLASS_ERROR)
                 return true;
 
             if (!(return_value = add_implicit_conversion(ctx, block, return_value, return_type, loc)))
                 return false;
 
-            if (!(store = hlsl_new_simple_store(ctx, ctx->cur_function->return_var, return_value)))
-                return false;
-            list_add_after(&return_value->entry, &store->entry);
+            hlsl_block_add_simple_store(ctx, block, ctx->cur_function->return_var, return_value);
         }
         else
         {
@@ -888,52 +867,37 @@ static bool add_return(struct hlsl_ctx *ctx, struct hlsl_block *block,
             hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_RETURN, "Void functions cannot return a value.");
     }
 
-    if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_RETURN, NULL, loc)))
-        return false;
-    hlsl_block_add_instr(block, jump);
-
+    hlsl_block_add_jump(ctx, block, HLSL_IR_JUMP_RETURN, NULL, loc);
     return true;
 }
 
 struct hlsl_ir_node *hlsl_add_load_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
         struct hlsl_ir_node *var_instr, unsigned int comp, const struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_node *load, *store;
-    struct hlsl_block load_block;
     struct hlsl_ir_var *var;
     struct hlsl_deref src;
 
     if (!(var = hlsl_new_synthetic_var(ctx, "deref", var_instr->data_type, &var_instr->loc)))
-        return NULL;
+    {
+        block->value = ctx->error_instr;
+        return ctx->error_instr;
+    }
 
-    if (!(store = hlsl_new_simple_store(ctx, var, var_instr)))
-        return NULL;
-    hlsl_block_add_instr(block, store);
+    hlsl_block_add_simple_store(ctx, block, var, var_instr);
 
     hlsl_init_simple_deref_from_var(&src, var);
-    if (!(load = hlsl_new_load_component(ctx, &load_block, &src, comp, loc)))
-        return NULL;
-    hlsl_block_add_block(block, &load_block);
-
-    return load;
+    return hlsl_block_add_load_component(ctx, block, &src, comp, loc);
 }
 
-static bool add_record_access(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_node *record,
+static void add_record_access(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_node *record,
         unsigned int idx, const struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_node *index, *c;
+    struct hlsl_ir_node *c;
 
     VKD3D_ASSERT(idx < record->data_type->e.record.field_count);
 
-    if (!(c = hlsl_new_uint_constant(ctx, idx, loc)))
-        return false;
-    hlsl_block_add_instr(block, c);
-
-    if (!(index = hlsl_new_index(ctx, record, c, loc)))
-        return false;
-    hlsl_block_add_instr(block, index);
-
-    return true;
+    c = hlsl_block_add_uint_constant(ctx, block, idx, loc);
+    hlsl_block_add_index(ctx, block, record, c, loc);
 }
 
 static struct hlsl_ir_node *add_binary_arithmetic_expr(struct hlsl_ctx *ctx, struct hlsl_block *block,
@@ -944,7 +908,6 @@ static bool add_array_access(struct hlsl_ctx *ctx, struct hlsl_block *block, str
         struct hlsl_ir_node *index, const struct vkd3d_shader_location *loc)
 {
     const struct hlsl_type *expr_type = array->data_type, *index_type = index->data_type;
-    struct hlsl_ir_node *return_index, *cast;
 
     if (array->data_type->class == HLSL_CLASS_ERROR || index->data_type->class == HLSL_CLASS_ERROR)
     {
@@ -972,10 +935,7 @@ static bool add_array_access(struct hlsl_ctx *ctx, struct hlsl_block *block, str
                 hlsl_get_vector_type(ctx, HLSL_TYPE_UINT, dim_count), &index->loc)))
             return false;
 
-        if (!(return_index = hlsl_new_index(ctx, array, index, loc)))
-            return false;
-        hlsl_block_add_instr(block, return_index);
-
+        hlsl_block_add_index(ctx, block, array, index, loc);
         return true;
     }
 
@@ -985,10 +945,7 @@ static bool add_array_access(struct hlsl_ctx *ctx, struct hlsl_block *block, str
         return false;
     }
 
-    if (!(cast = hlsl_new_cast(ctx, index, hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), &index->loc)))
-        return false;
-    hlsl_block_add_instr(block, cast);
-    index = cast;
+    index = hlsl_block_add_cast(ctx, block, index, hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), &index->loc);
 
     if (expr_type->class != HLSL_CLASS_ARRAY && expr_type->class != HLSL_CLASS_VECTOR && expr_type->class != HLSL_CLASS_MATRIX)
     {
@@ -999,10 +956,7 @@ static bool add_array_access(struct hlsl_ctx *ctx, struct hlsl_block *block, str
         return false;
     }
 
-    if (!(return_index = hlsl_new_index(ctx, array, index, loc)))
-        return false;
-    hlsl_block_add_instr(block, return_index);
-
+    hlsl_block_add_index(ctx, block, array, index, loc);
     return true;
 }
 
@@ -1144,31 +1098,34 @@ static bool gen_struct_fields(struct hlsl_ctx *ctx, struct parse_fields *fields,
     return true;
 }
 
-static bool add_record_access_recurse(struct hlsl_ctx *ctx, struct hlsl_block *block,
+static void add_record_access_recurse(struct hlsl_ctx *ctx, struct hlsl_block *block,
         const char *name, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_node *record = node_from_block(block);
     const struct hlsl_type *type = record->data_type;
     const struct hlsl_struct_field *field, *base;
 
+    if (type->class == HLSL_CLASS_ERROR)
+        return;
+
     if ((field = get_struct_field(type->e.record.fields, type->e.record.field_count, name)))
     {
         unsigned int field_idx = field - type->e.record.fields;
 
-        return add_record_access(ctx, block, record, field_idx, loc);
+        add_record_access(ctx, block, record, field_idx, loc);
     }
     else if ((base = get_struct_field(type->e.record.fields, type->e.record.field_count, "$super")))
     {
         unsigned int base_idx = base - type->e.record.fields;
 
-        if (!add_record_access(ctx, block, record, base_idx, loc))
-            return false;
-        return add_record_access_recurse(ctx, block, name, loc);
+        add_record_access(ctx, block, record, base_idx, loc);
+        add_record_access_recurse(ctx, block, name, loc);
+    }
+    else
+    {
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_NOT_DEFINED, "Field \"%s\" is not defined.", name);
+        block->value = ctx->error_instr;
     }
-
-    hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_NOT_DEFINED, "Field \"%s\" is not defined.", name);
-    block->value = ctx->error_instr;
-    return true;
 }
 
 static bool add_typedef(struct hlsl_ctx *ctx, struct hlsl_type *const orig_type, struct list *list)
@@ -1517,7 +1474,11 @@ static enum hlsl_base_type expr_common_base_type(enum hlsl_base_type t1, enum hl
         return HLSL_TYPE_FLOAT;
     if (t1 == HLSL_TYPE_UINT || t2 == HLSL_TYPE_UINT)
         return HLSL_TYPE_UINT;
-    return HLSL_TYPE_INT;
+    if (t1 == HLSL_TYPE_INT || t2 == HLSL_TYPE_INT)
+        return HLSL_TYPE_INT;
+    if (t1 == HLSL_TYPE_MIN16UINT || t2 == HLSL_TYPE_MIN16UINT)
+        return HLSL_TYPE_MIN16UINT;
+    vkd3d_unreachable();
 }
 
 static bool expr_common_shape(struct hlsl_ctx *ctx, struct hlsl_type *t1, struct hlsl_type *t2,
@@ -1600,15 +1561,12 @@ static struct hlsl_ir_node *add_expr(struct hlsl_ctx *ctx, struct hlsl_block *bl
         enum hlsl_ir_expr_op op, struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS],
         struct hlsl_type *type, const struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_node *expr;
     unsigned int i;
 
     if (type->class == HLSL_CLASS_MATRIX)
     {
         struct hlsl_type *scalar_type;
-        struct hlsl_ir_load *var_load;
         struct hlsl_deref var_deref;
-        struct hlsl_ir_node *load;
         struct hlsl_ir_var *var;
 
         scalar_type = hlsl_get_scalar_type(ctx, type->e.numeric.type);
@@ -1620,58 +1578,24 @@ static struct hlsl_ir_node *add_expr(struct hlsl_ctx *ctx, struct hlsl_block *bl
         for (i = 0; i < type->e.numeric.dimy * type->e.numeric.dimx; ++i)
         {
             struct hlsl_ir_node *value, *cell_operands[HLSL_MAX_OPERANDS] = { NULL };
-            struct hlsl_block store_block;
             unsigned int j;
 
             for (j = 0; j < HLSL_MAX_OPERANDS; j++)
             {
                 if (operands[j])
-                {
-                    if (!(load = hlsl_add_load_component(ctx, block, operands[j], i, loc)))
-                        return NULL;
-
-                    cell_operands[j] = load;
-                }
+                    cell_operands[j] = hlsl_add_load_component(ctx, block, operands[j], i, loc);
             }
 
             if (!(value = add_expr(ctx, block, op, cell_operands, scalar_type, loc)))
                 return NULL;
 
-            if (!hlsl_new_store_component(ctx, &store_block, &var_deref, i, value))
-                return NULL;
-            hlsl_block_add_block(block, &store_block);
+            hlsl_block_add_store_component(ctx, block, &var_deref, i, value);
         }
 
-        if (!(var_load = hlsl_new_var_load(ctx, var, loc)))
-            return NULL;
-        hlsl_block_add_instr(block, &var_load->node);
-
-        return &var_load->node;
+        return hlsl_block_add_simple_load(ctx, block, var, loc);
     }
 
-    if (!(expr = hlsl_new_expr(ctx, op, operands, type, loc)))
-        return NULL;
-    hlsl_block_add_instr(block, expr);
-
-    return expr;
-}
-
-static bool type_is_integer(enum hlsl_base_type type)
-{
-    switch (type)
-    {
-        case HLSL_TYPE_BOOL:
-        case HLSL_TYPE_INT:
-        case HLSL_TYPE_UINT:
-            return true;
-
-        case HLSL_TYPE_DOUBLE:
-        case HLSL_TYPE_FLOAT:
-        case HLSL_TYPE_HALF:
-            return false;
-    }
-
-    vkd3d_unreachable();
+    return hlsl_block_add_expr(ctx, block, op, operands, type, loc);
 }
 
 static void check_integer_type(struct hlsl_ctx *ctx, const struct hlsl_ir_node *instr)
@@ -1679,7 +1603,7 @@ static void check_integer_type(struct hlsl_ctx *ctx, const struct hlsl_ir_node *
     const struct hlsl_type *type = instr->data_type;
     struct vkd3d_string_buffer *string;
 
-    if (type_is_integer(type->e.numeric.type))
+    if (hlsl_type_is_integer(type))
         return;
 
     if ((string = hlsl_type_to_string(ctx, type)))
@@ -2186,7 +2110,6 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
         struct hlsl_ir_node *coords = hlsl_ir_index(lhs)->idx.node;
         struct hlsl_deref resource_deref;
         struct hlsl_type *resource_type;
-        struct hlsl_ir_node *store;
         unsigned int dim_count;
 
         if (!hlsl_index_is_resource_access(hlsl_ir_index(lhs)))
@@ -2215,12 +2138,7 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
         VKD3D_ASSERT(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
         VKD3D_ASSERT(coords->data_type->e.numeric.dimx == dim_count);
 
-        if (!(store = hlsl_new_resource_store(ctx, &resource_deref, coords, rhs, &lhs->loc)))
-        {
-            hlsl_cleanup_deref(&resource_deref);
-            return false;
-        }
-        hlsl_block_add_instr(block, store);
+        hlsl_block_add_resource_store(ctx, block, &resource_deref, coords, rhs, &lhs->loc);
         hlsl_cleanup_deref(&resource_deref);
     }
     else if (matrix_writemask)
@@ -2235,25 +2153,14 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
             for (j = 0; j < lhs->data_type->e.numeric.dimx; ++j)
             {
                 struct hlsl_ir_node *load;
-                struct hlsl_block store_block;
                 const unsigned int idx = i * 4 + j;
                 const unsigned int component = i * lhs->data_type->e.numeric.dimx + j;
 
                 if (!(writemask & (1 << idx)))
                     continue;
 
-                if (!(load = hlsl_add_load_component(ctx, block, rhs, k++, &rhs->loc)))
-                {
-                    hlsl_cleanup_deref(&deref);
-                    return false;
-                }
-
-                if (!hlsl_new_store_component(ctx, &store_block, &deref, component, load))
-                {
-                    hlsl_cleanup_deref(&deref);
-                    return false;
-                }
-                hlsl_block_add_block(block, &store_block);
+                load = hlsl_add_load_component(ctx, block, rhs, k++, &rhs->loc);
+                hlsl_block_add_store_component(ctx, block, &deref, component, load);
             }
         }
 
@@ -2269,49 +2176,32 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
 
         for (i = 0; i < mat->data_type->e.numeric.dimx; ++i)
         {
-            struct hlsl_ir_node *cell, *load, *store, *c;
+            struct hlsl_ir_node *cell, *load, *c;
             struct hlsl_deref deref;
 
             if (!(writemask & (1 << i)))
                 continue;
 
-            if (!(c = hlsl_new_uint_constant(ctx, i, &lhs->loc)))
-                return false;
-            hlsl_block_add_instr(block, c);
-
-            if (!(cell = hlsl_new_index(ctx, &row->node, c, &lhs->loc)))
-                return false;
-            hlsl_block_add_instr(block, cell);
+            c = hlsl_block_add_uint_constant(ctx, block, i, &lhs->loc);
 
-            if (!(load = hlsl_add_load_component(ctx, block, rhs, k++, &rhs->loc)))
-                return false;
+            cell = hlsl_block_add_index(ctx, block, &row->node, c, &lhs->loc);
+            load = hlsl_add_load_component(ctx, block, rhs, k++, &rhs->loc);
 
             if (!hlsl_init_deref_from_index_chain(ctx, &deref, cell))
                 return false;
 
-            if (!(store = hlsl_new_store_index(ctx, &deref, NULL, load, 0, &rhs->loc)))
-            {
-                hlsl_cleanup_deref(&deref);
-                return false;
-            }
-            hlsl_block_add_instr(block, store);
+            hlsl_block_add_store_index(ctx, block, &deref, NULL, load, 0, &rhs->loc);
             hlsl_cleanup_deref(&deref);
         }
     }
     else
     {
-        struct hlsl_ir_node *store;
         struct hlsl_deref deref;
 
         if (!hlsl_init_deref_from_index_chain(ctx, &deref, lhs))
             return false;
 
-        if (!(store = hlsl_new_store_index(ctx, &deref, NULL, rhs, writemask, &rhs->loc)))
-        {
-            hlsl_cleanup_deref(&deref);
-            return false;
-        }
-        hlsl_block_add_instr(block, store);
+        hlsl_block_add_store_index(ctx, block, &deref, NULL, rhs, writemask, &rhs->loc);
         hlsl_cleanup_deref(&deref);
     }
 
@@ -2332,9 +2222,7 @@ static bool add_increment(struct hlsl_ctx *ctx, struct hlsl_block *block, bool d
         hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_MODIFIES_CONST,
                 "Argument to %s%screment operator is const.", post ? "post" : "pre", decrement ? "de" : "in");
 
-    if (!(one = hlsl_new_int_constant(ctx, 1, loc)))
-        return false;
-    hlsl_block_add_instr(block, one);
+    one = hlsl_block_add_int_constant(ctx, block, 1, loc);
 
     if (!add_assignment(ctx, block, lhs, decrement ? ASSIGN_OP_SUB : ASSIGN_OP_ADD, one, false))
         return false;
@@ -2371,8 +2259,7 @@ static void initialize_var_components(struct hlsl_ctx *ctx, struct hlsl_block *i
         struct hlsl_type *dst_comp_type;
         struct hlsl_block block;
 
-        if (!(load = hlsl_add_load_component(ctx, instrs, src, k, &src->loc)))
-            return;
+        load = hlsl_add_load_component(ctx, instrs, src, k, &src->loc);
 
         dst_comp_type = hlsl_type_get_component_type(ctx, dst->data_type, *store_index);
 
@@ -2441,9 +2328,7 @@ static void initialize_var_components(struct hlsl_ctx *ctx, struct hlsl_block *i
                 if (!(conv = add_implicit_conversion(ctx, instrs, load, dst_comp_type, &src->loc)))
                     return;
 
-                if (!hlsl_new_store_component(ctx, &block, &dst_deref, *store_index, conv))
-                    return;
-                hlsl_block_add_block(instrs, &block);
+                hlsl_block_add_store_component(ctx, instrs, &dst_deref, *store_index, conv);
             }
         }
 
@@ -2859,7 +2744,7 @@ static struct hlsl_block *initialize_vars(struct hlsl_ctx *ctx, struct list *var
         }
         else if (var->storage_modifiers & HLSL_STORAGE_STATIC)
         {
-            struct hlsl_ir_node *cast, *store, *zero;
+            struct hlsl_ir_node *cast, *zero;
 
             /* Initialize statics to zero by default. */
 
@@ -2869,12 +2754,7 @@ static struct hlsl_block *initialize_vars(struct hlsl_ctx *ctx, struct list *var
                 continue;
             }
 
-            if (!(zero = hlsl_new_uint_constant(ctx, 0, &var->loc)))
-            {
-                free_parse_variable_def(v);
-                continue;
-            }
-            hlsl_block_add_instr(&ctx->static_initializers, zero);
+            zero = hlsl_block_add_uint_constant(ctx, &ctx->static_initializers, 0, &var->loc);
 
             if (!(cast = add_cast(ctx, &ctx->static_initializers, zero, var->data_type, &var->loc)))
             {
@@ -2882,12 +2762,7 @@ static struct hlsl_block *initialize_vars(struct hlsl_ctx *ctx, struct list *var
                 continue;
             }
 
-            if (!(store = hlsl_new_simple_store(ctx, var, cast)))
-            {
-                free_parse_variable_def(v);
-                continue;
-            }
-            hlsl_block_add_instr(&ctx->static_initializers, store);
+            hlsl_block_add_simple_store(ctx, &ctx->static_initializers, var, cast);
         }
         free_parse_variable_def(v);
     }
@@ -2934,6 +2809,7 @@ static enum hlsl_base_type hlsl_base_type_class(enum hlsl_base_type t)
             return HLSL_TYPE_FLOAT;
 
         case HLSL_TYPE_INT:
+        case HLSL_TYPE_MIN16UINT:
         case HLSL_TYPE_UINT:
             return HLSL_TYPE_INT;
 
@@ -2949,6 +2825,7 @@ static unsigned int hlsl_base_type_width(enum hlsl_base_type t)
     switch (t)
     {
         case HLSL_TYPE_HALF:
+        case HLSL_TYPE_MIN16UINT:
             return 16;
 
         case HLSL_TYPE_FLOAT:
@@ -3123,11 +3000,12 @@ static struct hlsl_ir_function_decl *find_function_call(struct hlsl_ctx *ctx,
     return decl;
 }
 
-static struct hlsl_ir_node *hlsl_new_void_expr(struct hlsl_ctx *ctx, const struct vkd3d_shader_location *loc)
+static void add_void_expr(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {0};
 
-    return hlsl_new_expr(ctx, HLSL_OP0_VOID, operands, ctx->builtin_types.Void, loc);
+    hlsl_block_add_expr(ctx, block, HLSL_OP0_VOID, operands, ctx->builtin_types.Void, loc);
 }
 
 static struct hlsl_ir_node *add_user_call(struct hlsl_ctx *ctx,
@@ -3154,8 +3032,6 @@ static struct hlsl_ir_node *add_user_call(struct hlsl_ctx *ctx,
 
         if (param->storage_modifiers & HLSL_STORAGE_IN)
         {
-            struct hlsl_ir_node *store;
-
             if (!hlsl_types_are_equal(arg->data_type, param->data_type))
             {
                 struct hlsl_ir_node *cast;
@@ -3165,9 +3041,7 @@ static struct hlsl_ir_node *add_user_call(struct hlsl_ctx *ctx,
                 arg = cast;
             }
 
-            if (!(store = hlsl_new_simple_store(ctx, param, arg)))
-                return NULL;
-            hlsl_block_add_instr(args->instrs, store);
+            hlsl_block_add_simple_store(ctx, args->instrs, param, arg);
         }
 
         ++k;
@@ -3192,7 +3066,6 @@ static struct hlsl_ir_node *add_user_call(struct hlsl_ctx *ctx,
             struct hlsl_type *type = hlsl_type_get_component_type(ctx, param->data_type, j);
             struct hlsl_constant_value value;
             struct hlsl_ir_node *comp;
-            struct hlsl_block store_block;
 
             if (!param->default_values[j].string)
             {
@@ -3201,9 +3074,7 @@ static struct hlsl_ir_node *add_user_call(struct hlsl_ctx *ctx,
                     return NULL;
                 hlsl_block_add_instr(args->instrs, comp);
 
-                if (!hlsl_new_store_component(ctx, &store_block, &param_deref, j, comp))
-                    return NULL;
-                hlsl_block_add_block(args->instrs, &store_block);
+                hlsl_block_add_store_component(ctx, args->instrs, &param_deref, j, comp);
             }
         }
     }
@@ -3222,37 +3093,22 @@ static struct hlsl_ir_node *add_user_call(struct hlsl_ctx *ctx,
 
         if (param->storage_modifiers & HLSL_STORAGE_OUT)
         {
-            struct hlsl_ir_load *load;
+            struct hlsl_ir_node *load;
 
             if (arg->data_type->modifiers & HLSL_MODIFIER_CONST)
                 hlsl_error(ctx, &arg->loc, VKD3D_SHADER_ERROR_HLSL_MODIFIES_CONST,
                         "Output argument to \"%s\" is const.", func->func->name);
 
-            if (!(load = hlsl_new_var_load(ctx, param, &arg->loc)))
-                return NULL;
-            hlsl_block_add_instr(args->instrs, &load->node);
-
-            if (!add_assignment(ctx, args->instrs, arg, ASSIGN_OP_ASSIGN, &load->node, true))
+            load = hlsl_block_add_simple_load(ctx, args->instrs, param, &arg->loc);
+            if (!add_assignment(ctx, args->instrs, arg, ASSIGN_OP_ASSIGN, load, true))
                 return NULL;
         }
     }
 
     if (func->return_var)
-    {
-        struct hlsl_ir_load *load;
-
-        if (!(load = hlsl_new_var_load(ctx, func->return_var, loc)))
-            return false;
-        hlsl_block_add_instr(args->instrs, &load->node);
-    }
+        hlsl_block_add_simple_load(ctx, args->instrs, func->return_var, loc);
     else
-    {
-        struct hlsl_ir_node *expr;
-
-        if (!(expr = hlsl_new_void_expr(ctx, loc)))
-            return false;
-        hlsl_block_add_instr(args->instrs, expr);
-    }
+        add_void_expr(ctx, args->instrs, loc);
 
     return call;
 }
@@ -3262,7 +3118,7 @@ static struct hlsl_ir_node *intrinsic_float_convert_arg(struct hlsl_ctx *ctx,
 {
     struct hlsl_type *type = arg->data_type;
 
-    if (!type_is_integer(type->e.numeric.type))
+    if (!hlsl_type_is_integer(type))
         return arg;
 
     type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_FLOAT, type->e.numeric.dimx, type->e.numeric.dimy);
@@ -3354,7 +3210,7 @@ static bool elementwise_intrinsic_float_convert_args(struct hlsl_ctx *ctx,
 
     if (!(type = elementwise_intrinsic_get_common_type(ctx, params, loc)))
         return false;
-    if (type_is_integer(type->e.numeric.type))
+    if (hlsl_type_is_integer(type))
         type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_FLOAT, type->e.numeric.dimx, type->e.numeric.dimy);
 
     return convert_args(ctx, params, type, loc);
@@ -3438,7 +3294,7 @@ static struct hlsl_type *convert_numeric_type(const struct hlsl_ctx *ctx,
     return hlsl_get_numeric_type(ctx, type->class, base_type, type->e.numeric.dimx, type->e.numeric.dimy);
 }
 
-static bool add_combine_components(struct hlsl_ctx *ctx, const struct parse_initializer *params,
+static void add_combine_components(struct hlsl_ctx *ctx, const struct parse_initializer *params,
         struct hlsl_ir_node *arg, enum hlsl_ir_expr_op op, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_node *res, *load;
@@ -3446,20 +3302,13 @@ static bool add_combine_components(struct hlsl_ctx *ctx, const struct parse_init
 
     count = hlsl_type_component_count(arg->data_type);
 
-    if (!(res = hlsl_add_load_component(ctx, params->instrs, arg, 0, loc)))
-        return false;
+    res = hlsl_add_load_component(ctx, params->instrs, arg, 0, loc);
 
     for (i = 1; i < count; ++i)
     {
-        if (!(load = hlsl_add_load_component(ctx, params->instrs, arg, i, loc)))
-            return false;
-
-        if (!(res = hlsl_new_binary_expr(ctx, op, res, load)))
-                return NULL;
-        hlsl_block_add_instr(params->instrs, res);
+        load = hlsl_add_load_component(ctx, params->instrs, arg, i, loc);
+        res = hlsl_block_add_binary_expr(ctx, params->instrs, op, res, load);
     }
-
-    return true;
 }
 
 static bool intrinsic_all(struct hlsl_ctx *ctx,
@@ -3472,7 +3321,8 @@ static bool intrinsic_all(struct hlsl_ctx *ctx,
     if (!(cast = add_cast(ctx, params->instrs, arg, bool_type, loc)))
         return false;
 
-    return add_combine_components(ctx, params, cast, HLSL_OP2_LOGIC_AND, loc);
+    add_combine_components(ctx, params, cast, HLSL_OP2_LOGIC_AND, loc);
+    return true;
 }
 
 static bool intrinsic_any(struct hlsl_ctx *ctx, const struct parse_initializer *params,
@@ -3485,7 +3335,8 @@ static bool intrinsic_any(struct hlsl_ctx *ctx, const struct parse_initializer *
     if (!(cast = add_cast(ctx, params->instrs, arg, bool_type, loc)))
         return false;
 
-    return add_combine_components(ctx, params, cast, HLSL_OP2_LOGIC_OR, loc);
+    add_combine_components(ctx, params, cast, HLSL_OP2_LOGIC_OR, loc);
+    return true;
 }
 
 static bool intrinsic_asin(struct hlsl_ctx *ctx,
@@ -3696,7 +3547,7 @@ static bool intrinsic_clamp(struct hlsl_ctx *ctx,
 static bool intrinsic_clip(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_node *condition, *jump;
+    struct hlsl_ir_node *condition;
 
     if (!elementwise_intrinsic_float_convert_args(ctx, params, loc))
         return false;
@@ -3714,10 +3565,7 @@ static bool intrinsic_clip(struct hlsl_ctx *ctx,
         return false;
     }
 
-    if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_DISCARD_NEG, condition, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, jump);
-
+    hlsl_block_add_jump(ctx, params->instrs, HLSL_IR_JUMP_DISCARD_NEG, condition, loc);
     return true;
 }
 
@@ -3782,7 +3630,7 @@ static bool intrinsic_cross(struct hlsl_ctx *ctx,
     enum hlsl_base_type base;
 
     base = expr_common_base_type(arg1->data_type->e.numeric.type, arg2->data_type->e.numeric.type);
-    if (type_is_integer(base))
+    if (hlsl_base_type_is_integer(base))
         base = HLSL_TYPE_FLOAT;
 
     cast_type = hlsl_get_vector_type(ctx, base, 3);
@@ -3804,9 +3652,7 @@ static bool intrinsic_cross(struct hlsl_ctx *ctx,
     if (!(mul1 = add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, arg1_swzl1, arg2_swzl1, loc)))
         return false;
 
-    if (!(mul1_neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, mul1, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, mul1_neg);
+    mul1_neg = hlsl_block_add_unary_expr(ctx, params->instrs, HLSL_OP1_NEG, mul1, loc);
 
     if (!(arg1_swzl2 = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(Y, Z, X, Y), 3, arg1_cast, loc)))
         return false;
@@ -3886,10 +3732,7 @@ static bool intrinsic_degrees(struct hlsl_ctx *ctx,
         return false;
 
     /* 1 rad = 180/pi degree = 57.2957795 degree */
-    if (!(deg = hlsl_new_float_constant(ctx, 57.2957795f, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, deg);
-
+    deg = hlsl_block_add_float_constant(ctx, params->instrs, 57.2957795f, loc);
     return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, arg, deg, loc);
 }
 
@@ -4073,9 +3916,7 @@ static bool intrinsic_exp(struct hlsl_ctx *ctx,
         return false;
 
     /* 1/ln(2) */
-    if (!(coeff = hlsl_new_float_constant(ctx, 1.442695f, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, coeff);
+    coeff = hlsl_block_add_float_constant(ctx, params->instrs, 1.442695f, loc);
 
     if (!(mul = add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, coeff, arg, loc)))
         return false;
@@ -4314,21 +4155,6 @@ static bool intrinsic_lerp(struct hlsl_ctx *ctx,
     return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_ADD, params->args[0], mul, loc);
 }
 
-static struct hlsl_ir_node * add_pow_expr(struct hlsl_ctx *ctx,
-        struct hlsl_block *instrs, struct hlsl_ir_node *arg1, struct hlsl_ir_node *arg2,
-        const struct vkd3d_shader_location *loc)
-{
-    struct hlsl_ir_node *log, *mul;
-
-    if (!(log = add_unary_arithmetic_expr(ctx, instrs, HLSL_OP1_LOG2, arg1, loc)))
-        return NULL;
-
-    if (!(mul = add_binary_arithmetic_expr(ctx, instrs, HLSL_OP2_MUL, arg2, log, loc)))
-        return NULL;
-
-    return add_unary_arithmetic_expr(ctx, instrs, HLSL_OP1_EXP2, mul, loc);
-}
-
 static bool intrinsic_lit(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
@@ -4370,10 +4196,7 @@ static bool intrinsic_log(struct hlsl_ctx *ctx,
         return false;
 
     /* ln(2) */
-    if (!(coeff = hlsl_new_float_constant(ctx, 0.69314718055f, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, coeff);
-
+    coeff = hlsl_block_add_float_constant(ctx, params->instrs, 0.69314718055f, loc);
     return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, log, coeff, loc);
 }
 
@@ -4389,10 +4212,7 @@ static bool intrinsic_log10(struct hlsl_ctx *ctx,
         return false;
 
     /* 1 / log2(10) */
-    if (!(coeff = hlsl_new_float_constant(ctx, 0.301029996f, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, coeff);
-
+    coeff = hlsl_block_add_float_constant(ctx, params->instrs, 0.301029996f, loc);
     return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, log, coeff, loc);
 }
 
@@ -4476,7 +4296,7 @@ static bool intrinsic_mul(struct hlsl_ctx *ctx,
     struct hlsl_type *cast_type1 = arg1->data_type, *cast_type2 = arg2->data_type, *matrix_type, *ret_type;
     unsigned int i, j, k, vect_count = 0;
     struct hlsl_deref var_deref;
-    struct hlsl_ir_load *load;
+    struct hlsl_ir_node *load;
     struct hlsl_ir_var *var;
 
     if (arg1->data_type->class == HLSL_CLASS_SCALAR || arg2->data_type->class == HLSL_CLASS_SCALAR)
@@ -4525,19 +4345,15 @@ static bool intrinsic_mul(struct hlsl_ctx *ctx,
         for (j = 0; j < matrix_type->e.numeric.dimy; ++j)
         {
             struct hlsl_ir_node *instr = NULL;
-            struct hlsl_block block;
 
             for (k = 0; k < cast_type1->e.numeric.dimx && k < cast_type2->e.numeric.dimy; ++k)
             {
                 struct hlsl_ir_node *value1, *value2, *mul;
 
-                if (!(value1 = hlsl_add_load_component(ctx, params->instrs,
-                        cast1, j * cast1->data_type->e.numeric.dimx + k, loc)))
-                    return false;
-
-                if (!(value2 = hlsl_add_load_component(ctx, params->instrs,
-                        cast2, k * cast2->data_type->e.numeric.dimx + i, loc)))
-                    return false;
+                value1 = hlsl_add_load_component(ctx, params->instrs,
+                        cast1, j * cast1->data_type->e.numeric.dimx + k, loc);
+                value2 = hlsl_add_load_component(ctx, params->instrs,
+                        cast2, k * cast2->data_type->e.numeric.dimx + i, loc);
 
                 if (!(mul = add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, value1, value2, loc)))
                     return false;
@@ -4553,17 +4369,13 @@ static bool intrinsic_mul(struct hlsl_ctx *ctx,
                 }
             }
 
-            if (!hlsl_new_store_component(ctx, &block, &var_deref, j * matrix_type->e.numeric.dimx + i, instr))
-                return false;
-            hlsl_block_add_block(params->instrs, &block);
+            hlsl_block_add_store_component(ctx, params->instrs, &var_deref,
+                    j * matrix_type->e.numeric.dimx + i, instr);
         }
     }
 
-    if (!(load = hlsl_new_var_load(ctx, var, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, &load->node);
-
-    return !!add_implicit_conversion(ctx, params->instrs, &load->node, ret_type, loc);
+    load = hlsl_block_add_simple_load(ctx, params->instrs, var, loc);
+    return !!add_implicit_conversion(ctx, params->instrs, load, ret_type, loc);
 }
 
 static bool intrinsic_normalize(struct hlsl_ctx *ctx,
@@ -4597,10 +4409,18 @@ static bool intrinsic_normalize(struct hlsl_ctx *ctx,
 static bool intrinsic_pow(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
+    struct hlsl_ir_node *log, *mul;
+
     if (!elementwise_intrinsic_float_convert_args(ctx, params, loc))
         return false;
 
-    return !!add_pow_expr(ctx, params->instrs, params->args[0], params->args[1], loc);
+    if (!(log = add_unary_arithmetic_expr(ctx, params->instrs, HLSL_OP1_LOG2, params->args[0], loc)))
+        return NULL;
+
+    if (!(mul = add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, params->args[1], log, loc)))
+        return NULL;
+
+    return add_unary_arithmetic_expr(ctx, params->instrs, HLSL_OP1_EXP2, mul, loc);
 }
 
 static bool intrinsic_radians(struct hlsl_ctx *ctx,
@@ -4612,10 +4432,7 @@ static bool intrinsic_radians(struct hlsl_ctx *ctx,
         return false;
 
     /* 1 degree = pi/180 rad = 0.0174532925f rad */
-    if (!(rad = hlsl_new_float_constant(ctx, 0.0174532925f, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, rad);
-
+    rad = hlsl_block_add_float_constant(ctx, params->instrs, 0.0174532925f, loc);
     return !!add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, arg, rad, loc);
 }
 
@@ -5052,8 +4869,6 @@ static bool intrinsic_tex(struct hlsl_ctx *ctx, const struct parse_initializer *
        is used for the second coordinate, while older ones appear to replicate first coordinate.*/
     if (dim == HLSL_SAMPLER_DIM_1D)
     {
-        struct hlsl_ir_load *load;
-        struct hlsl_ir_node *half;
         struct hlsl_ir_var *var;
         unsigned int idx = 0;
 
@@ -5062,22 +4877,10 @@ static bool intrinsic_tex(struct hlsl_ctx *ctx, const struct parse_initializer *
 
         initialize_var_components(ctx, params->instrs, var, &idx, coords, false);
         if (hlsl_version_ge(ctx, 4, 0))
-        {
-            if (!(half = hlsl_new_float_constant(ctx, 0.5f, loc)))
-                return false;
-            hlsl_block_add_instr(params->instrs, half);
-
-            initialize_var_components(ctx, params->instrs, var, &idx, half, false);
-        }
-        else
-            initialize_var_components(ctx, params->instrs, var, &idx, coords, false);
-
-        if (!(load = hlsl_new_var_load(ctx, var, loc)))
-            return false;
-        hlsl_block_add_instr(params->instrs, &load->node);
-
-        coords = &load->node;
+            coords = hlsl_block_add_float_constant(ctx, params->instrs, 0.5f, loc);
+        initialize_var_components(ctx, params->instrs, var, &idx, coords, false);
 
+        coords = hlsl_block_add_simple_load(ctx, params->instrs, var, loc);
         dim = HLSL_SAMPLER_DIM_2D;
     }
 
@@ -5175,7 +4978,6 @@ static bool intrinsic_transpose(struct hlsl_ctx *ctx,
 {
     struct hlsl_ir_node *arg = params->args[0];
     struct hlsl_type *arg_type = arg->data_type;
-    struct hlsl_ir_load *var_load;
     struct hlsl_deref var_deref;
     struct hlsl_type *mat_type;
     struct hlsl_ir_node *load;
@@ -5210,22 +5012,14 @@ static bool intrinsic_transpose(struct hlsl_ctx *ctx,
     {
         for (j = 0; j < arg_type->e.numeric.dimy; ++j)
         {
-            struct hlsl_block block;
-
-            if (!(load = hlsl_add_load_component(ctx, params->instrs, arg,
-                    j * arg->data_type->e.numeric.dimx + i, loc)))
-                return false;
-
-            if (!hlsl_new_store_component(ctx, &block, &var_deref, i * var->data_type->e.numeric.dimx + j, load))
-                return false;
-            hlsl_block_add_block(params->instrs, &block);
+            load = hlsl_add_load_component(ctx, params->instrs, arg,
+                    j * arg->data_type->e.numeric.dimx + i, loc);
+            hlsl_block_add_store_component(ctx, params->instrs, &var_deref,
+                    i * var->data_type->e.numeric.dimx + j, load);
         }
     }
 
-    if (!(var_load = hlsl_new_var_load(ctx, var, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, &var_load->node);
-
+    hlsl_block_add_simple_load(ctx, params->instrs, var, loc);
     return true;
 }
 
@@ -5263,9 +5057,7 @@ static bool intrinsic_d3dcolor_to_ubyte4(struct hlsl_ctx *ctx,
     if (!(arg = intrinsic_float_convert_arg(ctx, params, arg, loc)))
         return false;
 
-    if (!(c = hlsl_new_float_constant(ctx, 255.0f + (0.5f / 256.0f), loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, c);
+    c = hlsl_block_add_float_constant(ctx, params->instrs, 255.0f + (0.5f / 256.0f), loc);
 
     if (arg_type->class == HLSL_CLASS_VECTOR)
     {
@@ -5289,25 +5081,20 @@ static bool intrinsic_GetRenderTargetSampleCount(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {0};
-    struct hlsl_ir_node *expr;
 
     if (ctx->profile->type != VKD3D_SHADER_TYPE_PIXEL || hlsl_version_lt(ctx, 4, 1))
         hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INCOMPATIBLE_PROFILE,
                 "GetRenderTargetSampleCount() can only be used from a pixel shader using version 4.1 or higher.");
 
-    if (!(expr = hlsl_new_expr(ctx, HLSL_OP0_RASTERIZER_SAMPLE_COUNT,
-            operands, hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, expr);
-
+    hlsl_block_add_expr(ctx, params->instrs, HLSL_OP0_RASTERIZER_SAMPLE_COUNT,
+            operands, hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), loc);
     return true;
 }
 
 static bool intrinsic_interlocked(struct hlsl_ctx *ctx, enum hlsl_interlocked_op op,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc, const char *name)
 {
-    struct hlsl_ir_node *lhs, *coords, *val, *cmp_val = NULL, *orig_val = NULL;
-    struct hlsl_ir_node *interlocked, *void_ret;
+    struct hlsl_ir_node *interlocked, *lhs, *coords, *val, *cmp_val = NULL, *orig_val = NULL;
     struct hlsl_type *lhs_type, *val_type;
     struct vkd3d_string_buffer *string;
     struct hlsl_deref dst_deref;
@@ -5421,10 +5208,7 @@ static bool intrinsic_interlocked(struct hlsl_ctx *ctx, enum hlsl_interlocked_op
             return false;
     }
 
-    if (!(void_ret = hlsl_new_void_expr(ctx, loc)))
-        return false;
-    hlsl_block_add_instr(params->instrs, void_ret);
-
+    add_void_expr(ctx, params->instrs, loc);
     return true;
 }
 
@@ -5759,7 +5543,6 @@ static struct hlsl_block *add_compile_variant(struct hlsl_ctx *ctx, enum hlsl_co
 static struct hlsl_block *add_constructor(struct hlsl_ctx *ctx, struct hlsl_type *type,
         struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_load *load;
     struct hlsl_ir_var *var;
 
     if (!hlsl_is_numeric_type(type))
@@ -5778,9 +5561,7 @@ static struct hlsl_block *add_constructor(struct hlsl_ctx *ctx, struct hlsl_type
 
     initialize_var(ctx, var, params, false);
 
-    if (!(load = hlsl_new_var_load(ctx, var, loc)))
-        return NULL;
-    hlsl_block_add_instr(params->instrs, &load->node);
+    hlsl_block_add_simple_load(ctx, params->instrs, var, loc);
 
     vkd3d_free(params->args);
     return params->instrs;
@@ -6361,9 +6142,7 @@ static bool add_assignment_from_component(struct hlsl_ctx *ctx, struct hlsl_bloc
     if (!dest)
         return true;
 
-    if (!(load = hlsl_add_load_component(ctx, instrs, src, component, loc)))
-        return false;
-
+    load = hlsl_add_load_component(ctx, instrs, src, component, loc);
     if (!add_assignment(ctx, instrs, dest, ASSIGN_OP_ASSIGN, load, false))
         return false;
 
@@ -6377,7 +6156,6 @@ static bool add_getdimensions_method_call(struct hlsl_ctx *ctx, struct hlsl_bloc
     bool uint_resinfo, has_uint_arg, has_float_arg;
     struct hlsl_resource_load_params load_params;
     struct hlsl_ir_node *sample_info, *res_info;
-    struct hlsl_ir_node *zero = NULL, *void_ret;
     struct hlsl_type *uint_type, *float_type;
     unsigned int i, j;
     enum func_argument
@@ -6478,12 +6256,7 @@ static bool add_getdimensions_method_call(struct hlsl_ctx *ctx, struct hlsl_bloc
     }
 
     if (!args[ARG_MIP_LEVEL])
-    {
-        if (!(zero = hlsl_new_uint_constant(ctx, 0, loc)))
-            return false;
-        hlsl_block_add_instr(block, zero);
-        args[ARG_MIP_LEVEL] = zero;
-    }
+        args[ARG_MIP_LEVEL] = hlsl_block_add_uint_constant(ctx, block, 0, loc);
 
     memset(&load_params, 0, sizeof(load_params));
     load_params.type = HLSL_RESOURCE_RESINFO;
@@ -6524,10 +6297,7 @@ static bool add_getdimensions_method_call(struct hlsl_ctx *ctx, struct hlsl_bloc
             return false;
     }
 
-    if (!(void_ret = hlsl_new_void_expr(ctx, loc)))
-        return false;
-    hlsl_block_add_instr(block, void_ret);
-
+    add_void_expr(ctx, block, loc);
     return true;
 }
 
@@ -6665,7 +6435,7 @@ static bool add_sample_grad_method_call(struct hlsl_ctx *ctx, struct hlsl_block
 static bool add_store_method_call(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_node *object,
         const char *name, const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_node *offset, *rhs, *store;
+    struct hlsl_ir_node *offset, *rhs;
     struct hlsl_deref resource_deref;
     unsigned int value_dim;
 
@@ -6696,13 +6466,7 @@ static bool add_store_method_call(struct hlsl_ctx *ctx, struct hlsl_block *block
     if (!hlsl_init_deref_from_index_chain(ctx, &resource_deref, object))
         return false;
 
-    if (!(store = hlsl_new_resource_store(ctx, &resource_deref, offset, rhs, loc)))
-    {
-        hlsl_cleanup_deref(&resource_deref);
-        return false;
-    }
-
-    hlsl_block_add_instr(block, store);
+    hlsl_block_add_resource_store(ctx, block, &resource_deref, offset, rhs, loc);
     hlsl_cleanup_deref(&resource_deref);
 
     return true;
@@ -8752,6 +8516,26 @@ state_block:
                 hlsl_src_from_node(&entry->args[i], $5.args[i]);
             vkd3d_free($5.args);
 
+            $$ = $1;
+            hlsl_state_block_add_entry($$, entry);
+        }
+    | state_block stateblock_lhs_identifier state_block_index_opt '=' '<' primary_expr '>' ';'
+        {
+            struct hlsl_state_block_entry *entry;
+
+            if (!(entry = hlsl_alloc(ctx, sizeof(*entry))))
+                YYABORT;
+
+            entry->name = $2;
+            entry->lhs_has_index = $3.has_index;
+            entry->lhs_index = $3.index;
+
+            entry->instrs = $6;
+            entry->args_count = 1;
+            if (!(entry->args = hlsl_alloc(ctx, sizeof(*entry->args) * entry->args_count)))
+                YYABORT;
+            hlsl_src_from_node(&entry->args[0], node_from_block($6));
+
             $$ = $1;
             hlsl_state_block_add_entry($$, entry);
         }
@@ -9130,8 +8914,6 @@ statement:
 jump_statement:
       KW_BREAK ';'
         {
-            struct hlsl_ir_node *jump;
-
             if (!is_break_allowed(ctx->cur_scope))
             {
                 hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
@@ -9140,22 +8922,15 @@ jump_statement:
 
             if (!($$ = make_empty_block(ctx)))
                 YYABORT;
-            if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_BREAK, NULL, &@1)))
-                YYABORT;
-            hlsl_block_add_instr($$, jump);
+            hlsl_block_add_jump(ctx, $$, HLSL_IR_JUMP_BREAK, NULL, &@1);
         }
     | KW_CONTINUE ';'
         {
-            struct hlsl_ir_node *jump;
-
             check_continue(ctx, ctx->cur_scope, &@1);
 
             if (!($$ = make_empty_block(ctx)))
                 YYABORT;
-
-            if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_UNRESOLVED_CONTINUE, NULL, &@1)))
-                YYABORT;
-            hlsl_block_add_instr($$, jump);
+            hlsl_block_add_jump(ctx, $$, HLSL_IR_JUMP_UNRESOLVED_CONTINUE, NULL, &@1);
         }
     | KW_RETURN expr ';'
         {
@@ -9172,18 +8947,12 @@ jump_statement:
         }
     | KW_DISCARD ';'
         {
-            struct hlsl_ir_node *discard, *c;
+            struct hlsl_ir_node *c;
 
             if (!($$ = make_empty_block(ctx)))
                 YYABORT;
-
-            if (!(c = hlsl_new_uint_constant(ctx, ~0u, &@1)))
-                return false;
-            hlsl_block_add_instr($$, c);
-
-            if (!(discard = hlsl_new_jump(ctx, HLSL_IR_JUMP_DISCARD_NZ, c, &@1)))
-                return false;
-            hlsl_block_add_instr($$, discard);
+            c = hlsl_block_add_uint_constant(ctx, $$, ~0u, &@1);
+            hlsl_block_add_jump(ctx, $$, HLSL_IR_JUMP_DISCARD_NZ, c, &@1);
         }
 
 selection_statement:
@@ -9191,7 +8960,6 @@ selection_statement:
         {
             struct hlsl_ir_node *condition = node_from_block($4);
             const struct parse_attribute_list *attributes = &$1;
-            struct hlsl_ir_node *instr;
             unsigned int i;
 
             check_attribute_list_for_duplicates(ctx, attributes);
@@ -9221,19 +8989,13 @@ selection_statement:
                 YYABORT;
             }
 
-            if (!(instr = hlsl_new_if(ctx, condition, $6.then_block, $6.else_block, &@2)))
-            {
-                destroy_block($6.then_block);
-                destroy_block($6.else_block);
-                cleanup_parse_attribute_list(&$1);
-                YYABORT;
-            }
+            hlsl_block_add_if(ctx, $4, condition, $6.then_block, $6.else_block, &@2);
+
             destroy_block($6.then_block);
             destroy_block($6.else_block);
             cleanup_parse_attribute_list(&$1);
 
             $$ = $4;
-            hlsl_block_add_instr($$, instr);
         }
 
 if_body:
@@ -9383,30 +9145,21 @@ func_arguments:
 primary_expr:
       C_FLOAT
         {
-            struct hlsl_ir_node *c;
-
-            if (!(c = hlsl_new_float_constant(ctx, $1, &@1)))
-                YYABORT;
-            if (!($$ = make_block(ctx, c)))
+            if (!($$ = make_empty_block(ctx)))
                 YYABORT;
+            hlsl_block_add_float_constant(ctx, $$, $1, &@1);
         }
     | C_INTEGER
         {
-            struct hlsl_ir_node *c;
-
-            if (!(c = hlsl_new_int_constant(ctx, $1, &@1)))
-                YYABORT;
-            if (!($$ = make_block(ctx, c)))
+            if (!($$ = make_empty_block(ctx)))
                 YYABORT;
+            hlsl_block_add_int_constant(ctx, $$, $1, &@1);
         }
     | C_UNSIGNED
         {
-            struct hlsl_ir_node *c;
-
-            if (!(c = hlsl_new_uint_constant(ctx, $1, &@1)))
-                YYABORT;
-            if (!($$ = make_block(ctx, c)))
+            if (!($$ = make_empty_block(ctx)))
                 YYABORT;
+            hlsl_block_add_uint_constant(ctx, $$, $1, &@1);
         }
     | boolean
         {
@@ -9451,17 +9204,15 @@ primary_expr:
         }
     | VAR_IDENTIFIER
         {
-            struct hlsl_ir_load *load;
             struct hlsl_ir_var *var;
 
             if ((var = hlsl_get_var(ctx->cur_scope, $1)))
             {
                 vkd3d_free($1);
 
-                if (!(load = hlsl_new_var_load(ctx, var, &@1)))
-                    YYABORT;
-                if (!($$ = make_block(ctx, &load->node)))
+                if (!($$ = make_empty_block(ctx)))
                     YYABORT;
+                hlsl_block_add_simple_load(ctx, $$, var, &@1);
             }
             else
             {
@@ -9583,12 +9334,7 @@ postfix_expr:
 
             if (node->data_type->class == HLSL_CLASS_STRUCT)
             {
-                if (!add_record_access_recurse(ctx, $1, $3, &@2))
-                {
-                    destroy_block($1);
-                    vkd3d_free($3);
-                    YYABORT;
-                }
+                add_record_access_recurse(ctx, $1, $3, &@2);
             }
             else if (hlsl_is_numeric_type(node->data_type))
             {
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index 2afd3e1e1e5..edcd9ce62a7 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -62,14 +62,9 @@ static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, str
                 size /= 4;
             }
 
-            if (!(c = hlsl_new_uint_constant(ctx, size, loc)))
-                return NULL;
-            hlsl_block_add_instr(block, c);
-
-            if (!(idx_offset = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, c, idx)))
-                return NULL;
-            hlsl_block_add_instr(block, idx_offset);
+            c = hlsl_block_add_uint_constant(ctx, block, size, loc);
 
+            idx_offset = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MUL, c, idx);
             break;
         }
 
@@ -86,12 +81,7 @@ static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, str
                 field_offset /= 4;
             }
 
-            if (!(c = hlsl_new_uint_constant(ctx, field_offset, loc)))
-                return NULL;
-            hlsl_block_add_instr(block, c);
-
-            idx_offset = c;
-
+            idx_offset = hlsl_block_add_uint_constant(ctx, block, field_offset, loc);
             break;
         }
 
@@ -100,12 +90,7 @@ static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, str
     }
 
     if (idx_offset)
-    {
-        if (!(base_offset = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, base_offset, idx_offset)))
-            return NULL;
-        hlsl_block_add_instr(block, base_offset);
-    }
-
+        return hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, base_offset, idx_offset);
     return base_offset;
 }
 
@@ -122,9 +107,7 @@ static struct hlsl_ir_node *new_offset_instr_from_deref(struct hlsl_ctx *ctx, st
 
     hlsl_block_init(block);
 
-    if (!(offset = hlsl_new_uint_constant(ctx, 0, loc)))
-        return NULL;
-    hlsl_block_add_instr(block, offset);
+    offset = hlsl_block_add_uint_constant(ctx, block, 0, loc);
 
     VKD3D_ASSERT(deref->var);
     type = deref->var->data_type;
@@ -134,16 +117,9 @@ static struct hlsl_ir_node *new_offset_instr_from_deref(struct hlsl_ctx *ctx, st
         struct hlsl_block idx_block;
 
         hlsl_block_init(&idx_block);
-
-        if (!(offset = new_offset_from_path_index(ctx, &idx_block, type, offset, deref->path[i].node,
-                regset, offset_component, loc)))
-        {
-            hlsl_block_cleanup(&idx_block);
-            return NULL;
-        }
-
+        offset = new_offset_from_path_index(ctx, &idx_block, type, offset,
+                deref->path[i].node, regset, offset_component, loc);
         hlsl_block_add_block(block, &idx_block);
-
         type = hlsl_get_element_type_from_path_index(ctx, type, deref->path[i].node);
     }
 
@@ -174,8 +150,7 @@ static bool replace_deref_path_with_offset(struct hlsl_ctx *ctx, struct hlsl_der
 
     deref->data_type = type;
 
-    if (!(offset = new_offset_instr_from_deref(ctx, &block, deref, &offset_component, &instr->loc)))
-        return false;
+    offset = new_offset_instr_from_deref(ctx, &block, deref, &offset_component, &instr->loc);
     list_move_before(&instr->entry, &block.instrs);
 
     hlsl_cleanup_deref(deref);
@@ -203,41 +178,34 @@ static bool clean_constant_deref_offset_srcs(struct hlsl_ctx *ctx, struct hlsl_d
 }
 
 
-/* Split uniforms into two variables representing the constant and temp
- * registers, and copy the former to the latter, so that writes to uniforms
- * work. */
-static void prepend_uniform_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_var *temp)
+/* For a uniform variable, create a temp copy of it so, in case a value is
+ * stored to the uniform at some point the shader, all derefs can be diverted
+ * to this temp copy instead.
+ * Also, promote the uniform to an extern var. */
+static void prepend_uniform_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_var *uniform)
 {
-    struct hlsl_ir_var *uniform;
     struct hlsl_ir_node *store;
     struct hlsl_ir_load *load;
+    struct hlsl_ir_var *temp;
     char *new_name;
 
-    /* Use the synthetic name for the temp, rather than the uniform, so that we
-     * can write the uniform name into the shader reflection data. */
+    uniform->is_uniform = 1;
+    list_add_tail(&ctx->extern_vars, &uniform->extern_entry);
 
-    if (!(uniform = hlsl_new_var(ctx, temp->name, temp->data_type,
-            &temp->loc, NULL, temp->storage_modifiers, &temp->reg_reservation)))
+    if (!(new_name = hlsl_sprintf_alloc(ctx, "<temp-%s>", uniform->name)))
         return;
-    list_add_before(&temp->scope_entry, &uniform->scope_entry);
-    list_add_tail(&ctx->extern_vars, &uniform->extern_entry);
-    uniform->is_uniform = 1;
-    uniform->is_param = temp->is_param;
-    uniform->buffer = temp->buffer;
-    if (temp->default_values)
+
+    if (!(temp = hlsl_new_var(ctx, new_name, uniform->data_type,
+            &uniform->loc, NULL, uniform->storage_modifiers, NULL)))
     {
-        /* Transfer default values from the temp to the uniform. */
-        VKD3D_ASSERT(!uniform->default_values);
-        VKD3D_ASSERT(hlsl_type_component_count(temp->data_type) == hlsl_type_component_count(uniform->data_type));
-        uniform->default_values = temp->default_values;
-        temp->default_values = NULL;
+        vkd3d_free(new_name);
+        return;
     }
+    list_add_before(&uniform->scope_entry, &temp->scope_entry);
 
-    if (!(new_name = hlsl_sprintf_alloc(ctx, "<temp-%s>", temp->name)))
-        return;
-    temp->name = new_name;
+    uniform->temp_copy = temp;
 
-    if (!(load = hlsl_new_var_load(ctx, uniform, &temp->loc)))
+    if (!(load = hlsl_new_var_load(ctx, uniform, &uniform->loc)))
         return;
     list_add_head(&block->instrs, &load->node.entry);
 
@@ -246,6 +214,25 @@ static void prepend_uniform_copy(struct hlsl_ctx *ctx, struct hlsl_block *block,
     list_add_after(&load->node.entry, &store->entry);
 }
 
+/* If a uniform is written to at some point in the shader, all dereferences
+ * must point to the temp copy instead, which is what this pass does. */
+static bool divert_written_uniform_derefs_to_temp(struct hlsl_ctx *ctx, struct hlsl_deref *deref,
+        struct hlsl_ir_node *instr)
+{
+    if (!deref->var->is_uniform || !deref->var->first_write)
+        return false;
+
+    /* Skip derefs from instructions before first write so copies from the
+     * uniform to the temp are unaffected. */
+    if (instr->index < deref->var->first_write)
+        return false;
+
+    VKD3D_ASSERT(deref->var->temp_copy);
+
+    deref->var = deref->var->temp_copy;
+    return true;
+}
+
 static void validate_field_semantic(struct hlsl_ctx *ctx, struct hlsl_struct_field *field)
 {
     if (!field->semantic.name && hlsl_is_numeric_type(hlsl_get_multiarray_element_type(field->type))
@@ -259,13 +246,23 @@ static void validate_field_semantic(struct hlsl_ctx *ctx, struct hlsl_struct_fie
 
 static enum hlsl_base_type base_type_get_semantic_equivalent(enum hlsl_base_type base)
 {
-    if (base == HLSL_TYPE_BOOL)
-        return HLSL_TYPE_UINT;
-    if (base == HLSL_TYPE_INT)
-        return HLSL_TYPE_UINT;
-    if (base == HLSL_TYPE_HALF)
-        return HLSL_TYPE_FLOAT;
-    return base;
+    switch (base)
+    {
+        case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_INT:
+        case HLSL_TYPE_MIN16UINT:
+        case HLSL_TYPE_UINT:
+            return HLSL_TYPE_UINT;
+
+        case HLSL_TYPE_HALF:
+        case HLSL_TYPE_FLOAT:
+            return HLSL_TYPE_FLOAT;
+
+        case HLSL_TYPE_DOUBLE:
+            return HLSL_TYPE_DOUBLE;
+    }
+
+    vkd3d_unreachable();
 }
 
 static bool types_are_semantic_equivalent(struct hlsl_ctx *ctx, const struct hlsl_type *type1,
@@ -416,7 +413,7 @@ static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_dec
 
     for (i = 0; i < hlsl_type_major_size(type); ++i)
     {
-        struct hlsl_ir_node *store, *cast;
+        struct hlsl_ir_node *cast;
         struct hlsl_ir_var *input;
         struct hlsl_ir_load *load;
 
@@ -436,9 +433,7 @@ static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_dec
                 return;
             hlsl_init_simple_deref_from_var(&patch_deref, input);
 
-            if (!(idx = hlsl_new_uint_constant(ctx, patch_index, &var->loc)))
-                return;
-            hlsl_block_add_instr(block, idx);
+            idx = hlsl_block_add_uint_constant(ctx, block, patch_index, &var->loc);
 
             if (!(load = hlsl_new_load_index(ctx, &patch_deref, idx, loc)))
                 return;
@@ -455,27 +450,19 @@ static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_dec
             hlsl_block_add_instr(block, &load->node);
         }
 
-        if (!(cast = hlsl_new_cast(ctx, &load->node, vector_type_dst, &var->loc)))
-            return;
-        hlsl_block_add_instr(block, cast);
+        cast = hlsl_block_add_cast(ctx, block, &load->node, vector_type_dst, &var->loc);
 
         if (type->class == HLSL_CLASS_MATRIX)
         {
-            if (!(c = hlsl_new_uint_constant(ctx, i, &var->loc)))
-                return;
-            hlsl_block_add_instr(block, c);
+            c = hlsl_block_add_uint_constant(ctx, block, i, &var->loc);
 
-            if (!(store = hlsl_new_store_index(ctx, &lhs->src, c, cast, 0, &var->loc)))
-                return;
-            hlsl_block_add_instr(block, store);
+            hlsl_block_add_store_index(ctx, block, &lhs->src, c, cast, 0, &var->loc);
         }
         else
         {
             VKD3D_ASSERT(i == 0);
 
-            if (!(store = hlsl_new_store_index(ctx, &lhs->src, NULL, cast, 0, &var->loc)))
-                return;
-            hlsl_block_add_instr(block, store);
+            hlsl_block_add_store_index(ctx, block, &lhs->src, NULL, cast, 0, &var->loc);
         }
     }
 }
@@ -526,9 +513,7 @@ static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_ir_func
                 force_align = (i == 0);
             }
 
-            if (!(c = hlsl_new_uint_constant(ctx, i, &var->loc)))
-                return;
-            hlsl_block_add_instr(block, c);
+            c = hlsl_block_add_uint_constant(ctx, block, i, &var->loc);
 
             /* This redundant load is expected to be deleted later by DCE. */
             if (!(element_load = hlsl_new_load_index(ctx, &lhs->src, c, loc)))
@@ -593,9 +578,8 @@ static void append_output_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_dec
 
     for (i = 0; i < hlsl_type_major_size(type); ++i)
     {
-        struct hlsl_ir_node *store;
         struct hlsl_ir_var *output;
-        struct hlsl_ir_load *load;
+        struct hlsl_ir_node *load;
 
         if (!(output = add_semantic_var(ctx, func, var, vector_type,
                 modifiers, semantic, semantic_index + i, true, force_align, loc)))
@@ -603,26 +587,17 @@ static void append_output_copy(struct hlsl_ctx *ctx, struct hlsl_ir_function_dec
 
         if (type->class == HLSL_CLASS_MATRIX)
         {
-            if (!(c = hlsl_new_uint_constant(ctx, i, &var->loc)))
-                return;
-            hlsl_block_add_instr(&func->body, c);
-
-            if (!(load = hlsl_new_load_index(ctx, &rhs->src, c, &var->loc)))
-                return;
-            hlsl_block_add_instr(&func->body, &load->node);
+            c = hlsl_block_add_uint_constant(ctx, &func->body, i, &var->loc);
+            load = hlsl_block_add_load_index(ctx, &func->body, &rhs->src, c, &var->loc);
         }
         else
         {
             VKD3D_ASSERT(i == 0);
 
-            if (!(load = hlsl_new_load_index(ctx, &rhs->src, NULL, &var->loc)))
-                return;
-            hlsl_block_add_instr(&func->body, &load->node);
+            load = hlsl_block_add_load_index(ctx, &func->body, &rhs->src, NULL, &var->loc);
         }
 
-        if (!(store = hlsl_new_simple_store(ctx, output, &load->node)))
-            return;
-        hlsl_block_add_instr(&func->body, store);
+        hlsl_block_add_simple_store(ctx, &func->body, output, load);
     }
 }
 
@@ -666,9 +641,7 @@ static void append_output_copy_recurse(struct hlsl_ctx *ctx,
                 force_align = (i == 0);
             }
 
-            if (!(c = hlsl_new_uint_constant(ctx, i, &var->loc)))
-                return;
-            hlsl_block_add_instr(&func->body, c);
+            c = hlsl_block_add_uint_constant(ctx, &func->body, i, &var->loc);
 
             if (!(element_load = hlsl_new_load_index(ctx, &rhs->src, c, loc)))
                 return;
@@ -705,6 +678,9 @@ bool hlsl_transform_ir(struct hlsl_ctx *ctx, bool (*func)(struct hlsl_ctx *ctx,
     struct hlsl_ir_node *instr, *next;
     bool progress = false;
 
+    if (ctx->result)
+        return false;
+
     LIST_FOR_EACH_ENTRY_SAFE(instr, next, &block->instrs, struct hlsl_ir_node, entry)
     {
         if (instr->type == HLSL_IR_IF)
@@ -853,9 +829,9 @@ static bool find_recursive_calls(struct hlsl_ctx *ctx, struct hlsl_ir_node *inst
 static void insert_early_return_break(struct hlsl_ctx *ctx,
         struct hlsl_ir_function_decl *func, struct hlsl_ir_node *cf_instr)
 {
-    struct hlsl_ir_node *iff, *jump;
     struct hlsl_block then_block;
     struct hlsl_ir_load *load;
+    struct hlsl_ir_node *iff;
 
     hlsl_block_init(&then_block);
 
@@ -863,9 +839,7 @@ static void insert_early_return_break(struct hlsl_ctx *ctx,
         return;
     list_add_after(&cf_instr->entry, &load->node.entry);
 
-    if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_BREAK, NULL, &cf_instr->loc)))
-        return;
-    hlsl_block_add_instr(&then_block, jump);
+    hlsl_block_add_jump(ctx, &then_block, HLSL_IR_JUMP_BREAK, NULL, &cf_instr->loc);
 
     if (!(iff = hlsl_new_if(ctx, &load->node, &then_block, NULL, &cf_instr->loc)))
         return;
@@ -1037,9 +1011,8 @@ static bool lower_return(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *fun
     else if (cf_instr)
     {
         struct list *tail = list_tail(&block->instrs);
-        struct hlsl_ir_node *not, *iff;
+        struct hlsl_ir_node *not, *load;
         struct hlsl_block then_block;
-        struct hlsl_ir_load *load;
 
         /* If we're in a loop, we should have used "break" instead. */
         VKD3D_ASSERT(!in_loop);
@@ -1051,17 +1024,9 @@ static bool lower_return(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *fun
         list_move_slice_tail(&then_block.instrs, list_next(&block->instrs, &cf_instr->entry), tail);
         lower_return(ctx, func, &then_block, in_loop);
 
-        if (!(load = hlsl_new_var_load(ctx, func->early_return_var, &cf_instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, &load->node);
-
-        if (!(not = hlsl_new_unary_expr(ctx, HLSL_OP1_LOGIC_NOT, &load->node, &cf_instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, not);
-
-        if (!(iff = hlsl_new_if(ctx, not, &then_block, NULL, &cf_instr->loc)))
-            return false;
-        list_add_tail(&block->instrs, &iff->entry);
+        load = hlsl_block_add_simple_load(ctx, block, func->early_return_var, &cf_instr->loc);
+        not = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_LOGIC_NOT, load, &cf_instr->loc);
+        hlsl_block_add_if(ctx, block, not, &then_block, NULL, &cf_instr->loc);
     }
 
     return has_early_return;
@@ -1096,10 +1061,9 @@ static struct hlsl_ir_node *add_zero_mipmap_level(struct hlsl_ctx *ctx, struct h
         struct hlsl_ir_node *index, const struct vkd3d_shader_location *loc)
 {
     unsigned int dim_count = index->data_type->e.numeric.dimx;
-    struct hlsl_ir_node *store, *zero;
-    struct hlsl_ir_load *coords_load;
     struct hlsl_deref coords_deref;
     struct hlsl_ir_var *coords;
+    struct hlsl_ir_node *zero;
 
     VKD3D_ASSERT(dim_count < 4);
 
@@ -1108,23 +1072,12 @@ static struct hlsl_ir_node *add_zero_mipmap_level(struct hlsl_ctx *ctx, struct h
         return NULL;
 
     hlsl_init_simple_deref_from_var(&coords_deref, coords);
-    if (!(store = hlsl_new_store_index(ctx, &coords_deref, NULL, index, (1u << dim_count) - 1, loc)))
-        return NULL;
-    hlsl_block_add_instr(block, store);
-
-    if (!(zero = hlsl_new_uint_constant(ctx, 0, loc)))
-        return NULL;
-    hlsl_block_add_instr(block, zero);
+    hlsl_block_add_store_index(ctx, block, &coords_deref, NULL, index, (1u << dim_count) - 1, loc);
 
-    if (!(store = hlsl_new_store_index(ctx, &coords_deref, NULL, zero, 1u << dim_count, loc)))
-        return NULL;
-    hlsl_block_add_instr(block, store);
+    zero = hlsl_block_add_uint_constant(ctx, block, 0, loc);
+    hlsl_block_add_store_index(ctx, block, &coords_deref, NULL, zero, 1u << dim_count, loc);
 
-    if (!(coords_load = hlsl_new_var_load(ctx, coords, loc)))
-        return NULL;
-    hlsl_block_add_instr(block, &coords_load->node);
-
-    return &coords_load->node;
+    return hlsl_block_add_simple_load(ctx, block, coords, loc);
 }
 
 static bool lower_complex_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
@@ -1133,7 +1086,6 @@ static bool lower_complex_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
     struct hlsl_type *src_type, *dst_type;
     struct hlsl_deref var_deref;
     bool broadcast, matrix_cast;
-    struct hlsl_ir_load *load;
     struct hlsl_ir_node *arg;
     struct hlsl_ir_var *var;
     unsigned int dst_idx;
@@ -1172,7 +1124,6 @@ static bool lower_complex_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
     {
         struct hlsl_ir_node *component_load, *cast;
         struct hlsl_type *dst_comp_type;
-        struct hlsl_block store_block;
         unsigned int src_idx;
 
         if (broadcast)
@@ -1191,23 +1142,13 @@ static bool lower_complex_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
         }
 
         dst_comp_type = hlsl_type_get_component_type(ctx, dst_type, dst_idx);
+        component_load = hlsl_add_load_component(ctx, block, arg, src_idx, &arg->loc);
+        cast = hlsl_block_add_cast(ctx, block, component_load, dst_comp_type, &arg->loc);
 
-        if (!(component_load = hlsl_add_load_component(ctx, block, arg, src_idx, &arg->loc)))
-            return false;
-
-        if (!(cast = hlsl_new_cast(ctx, component_load, dst_comp_type, &arg->loc)))
-            return false;
-        hlsl_block_add_instr(block, cast);
-
-        if (!hlsl_new_store_component(ctx, &store_block, &var_deref, dst_idx, cast))
-            return false;
-        hlsl_block_add_block(block, &store_block);
+        hlsl_block_add_store_component(ctx, block, &var_deref, dst_idx, cast);
     }
 
-    if (!(load = hlsl_new_var_load(ctx, var, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, &load->node);
-
+    hlsl_block_add_simple_load(ctx, block, var, &instr->loc);
     return true;
 }
 
@@ -1219,7 +1160,6 @@ static bool lower_complex_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
 static bool lower_matrix_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_ir_swizzle *swizzle;
-    struct hlsl_ir_load *var_load;
     struct hlsl_deref var_deref;
     struct hlsl_type *matrix_type;
     struct hlsl_ir_var *var;
@@ -1238,23 +1178,15 @@ static bool lower_matrix_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
 
     for (i = 0; i < instr->data_type->e.numeric.dimx; ++i)
     {
-        struct hlsl_block store_block;
         struct hlsl_ir_node *load;
 
         k = swizzle->u.matrix.components[i].y * matrix_type->e.numeric.dimx + swizzle->u.matrix.components[i].x;
 
-        if (!(load = hlsl_add_load_component(ctx, block, swizzle->val.node, k, &instr->loc)))
-            return false;
-
-        if (!hlsl_new_store_component(ctx, &store_block, &var_deref, i, load))
-            return false;
-        hlsl_block_add_block(block, &store_block);
+        load = hlsl_add_load_component(ctx, block, swizzle->val.node, k, &instr->loc);
+        hlsl_block_add_store_component(ctx, block, &var_deref, i, load);
     }
 
-    if (!(var_load = hlsl_new_var_load(ctx, var, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, &var_load->node);
-
+    hlsl_block_add_simple_load(ctx, block, var, &instr->loc);
     return true;
 }
 
@@ -1266,10 +1198,10 @@ static bool lower_matrix_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
  * resource access. */
 static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *val, *store;
     struct hlsl_deref var_deref;
     struct hlsl_ir_index *index;
     struct hlsl_ir_load *load;
+    struct hlsl_ir_node *val;
     struct hlsl_ir_var *var;
 
     if (instr->type != HLSL_IR_INDEX)
@@ -1306,9 +1238,7 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         return false;
     hlsl_init_simple_deref_from_var(&var_deref, var);
 
-    if (!(store = hlsl_new_simple_store(ctx, var, val)))
-        return false;
-    hlsl_block_add_instr(block, store);
+    hlsl_block_add_simple_store(ctx, block, var, val);
 
     if (hlsl_index_is_noncontiguous(index))
     {
@@ -1326,9 +1256,7 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         {
             struct hlsl_ir_node *c;
 
-            if (!(c = hlsl_new_uint_constant(ctx, i, &instr->loc)))
-                return false;
-            hlsl_block_add_instr(block, c);
+            c = hlsl_block_add_uint_constant(ctx, block, i, &instr->loc);
 
             if (!(load = hlsl_new_load_index(ctx, &var_deref, c, &instr->loc)))
                 return false;
@@ -1338,20 +1266,14 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
                 return false;
             hlsl_block_add_instr(block, &load->node);
 
-            if (!(store = hlsl_new_store_index(ctx, &row_deref, c, &load->node, 0, &instr->loc)))
-                return false;
-            hlsl_block_add_instr(block, store);
+            hlsl_block_add_store_index(ctx, block, &row_deref, c, &load->node, 0, &instr->loc);
         }
 
-        if (!(load = hlsl_new_var_load(ctx, var, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, &load->node);
+        hlsl_block_add_simple_load(ctx, block, var, &instr->loc);
     }
     else
     {
-        if (!(load = hlsl_new_load_index(ctx, &var_deref, index->idx.node, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, &load->node);
+        hlsl_block_add_load_index(ctx, block, &var_deref, index->idx.node, &instr->loc);
     }
     return true;
 }
@@ -1378,9 +1300,7 @@ static bool lower_broadcasts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, s
         dst_scalar_type = hlsl_get_scalar_type(ctx, dst_type->e.numeric.type);
         /* We need to preserve the cast since it might be doing more than just
          * turning the scalar into a vector. */
-        if (!(new_cast = hlsl_new_cast(ctx, cast->operands[0].node, dst_scalar_type, &cast->node.loc)))
-            return false;
-        hlsl_block_add_instr(block, new_cast);
+        new_cast = hlsl_block_add_cast(ctx, block, cast->operands[0].node, dst_scalar_type, &cast->node.loc);
 
         if (dst_type->e.numeric.dimx != 1)
         {
@@ -1398,7 +1318,7 @@ static bool lower_broadcasts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, s
 
 /* Allocate a unique, ordered index to each instruction, which will be used for
  * copy propagation and computing liveness ranges.
- * Index 0 means unused; index 1 means function entry, so start at 2. */
+ * Index 0 means unused, so start at 1. */
 static unsigned int index_instructions(struct hlsl_block *block, unsigned int index)
 {
     struct hlsl_ir_node *instr;
@@ -2210,7 +2130,10 @@ bool hlsl_copy_propagation_execute(struct hlsl_ctx *ctx, struct hlsl_block *bloc
     struct copy_propagation_state state;
     bool progress;
 
-    index_instructions(block, 2);
+    if (ctx->result)
+        return false;
+
+    index_instructions(block, 1);
 
     copy_propagation_state_init(&state, ctx);
 
@@ -2589,9 +2512,7 @@ static bool lower_narrowing_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
         dst_vector_type = hlsl_get_vector_type(ctx, dst_type->e.numeric.type, src_type->e.numeric.dimx);
         /* We need to preserve the cast since it might be doing more than just
          * narrowing the vector. */
-        if (!(new_cast = hlsl_new_cast(ctx, cast->operands[0].node, dst_vector_type, &cast->node.loc)))
-            return false;
-        hlsl_block_add_instr(block, new_cast);
+        new_cast = hlsl_block_add_cast(ctx, block, cast->operands[0].node, dst_vector_type, &cast->node.loc);
 
         if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, Y, Z, W),
                 dst_type->e.numeric.dimx, new_cast, &cast->node.loc)))
@@ -2768,16 +2689,9 @@ static bool normalize_switch_cases(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
     }
     else
     {
-        struct hlsl_ir_node *jump;
-
         if (!(def = hlsl_new_switch_case(ctx, 0, true, NULL, &s->node.loc)))
             return true;
-        if (!(jump = hlsl_new_jump(ctx, HLSL_IR_JUMP_BREAK, NULL, &s->node.loc)))
-        {
-            hlsl_free_ir_switch_case(def);
-            return true;
-        }
-        hlsl_block_add_instr(&def->body, jump);
+        hlsl_block_add_jump(ctx, &def->body, HLSL_IR_JUMP_BREAK, NULL, &s->node.loc);
     }
     list_add_tail(&s->cases, &def->entry);
 
@@ -2808,7 +2722,7 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
 
     if (type->class == HLSL_CLASS_VECTOR && idx->type != HLSL_IR_CONSTANT)
     {
-        struct hlsl_ir_node *eq, *swizzle, *dot, *c, *operands[HLSL_MAX_OPERANDS] = {0};
+        struct hlsl_ir_node *eq, *swizzle, *c, *operands[HLSL_MAX_OPERANDS] = {0};
         unsigned int width = type->e.numeric.dimx;
         struct hlsl_constant_value value;
         struct hlsl_ir_load *vector_load;
@@ -2832,14 +2746,9 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
 
         operands[0] = swizzle;
         operands[1] = c;
-        if (!(eq = hlsl_new_expr(ctx, HLSL_OP2_EQUAL, operands,
-                hlsl_get_vector_type(ctx, HLSL_TYPE_BOOL, width), &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, eq);
-
-        if (!(eq = hlsl_new_cast(ctx, eq, type, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, eq);
+        eq = hlsl_block_add_expr(ctx, block, HLSL_OP2_EQUAL, operands,
+                hlsl_get_vector_type(ctx, HLSL_TYPE_BOOL, width), &instr->loc);
+        eq = hlsl_block_add_cast(ctx, block, eq, type, &instr->loc);
 
         op = HLSL_OP2_DOT;
         if (width == 1)
@@ -2849,10 +2758,7 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
          * LOGIC_OR + LOGIC_AND. */
         operands[0] = &vector_load->node;
         operands[1] = eq;
-        if (!(dot = hlsl_new_expr(ctx, op, operands, instr->data_type, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, dot);
-
+        hlsl_block_add_expr(ctx, block, op, operands, instr->data_type, &instr->loc);
         return true;
     }
 
@@ -2901,7 +2807,7 @@ static bool lower_nonconstant_array_loads(struct hlsl_ctx *ctx, struct hlsl_ir_n
         struct hlsl_block *block)
 {
     struct hlsl_constant_value zero_value = {0};
-    struct hlsl_ir_node *cut_index, *zero, *store;
+    struct hlsl_ir_node *cut_index, *zero;
     unsigned int i, i_cut, element_count;
     const struct hlsl_deref *deref;
     struct hlsl_type *cut_type;
@@ -2944,70 +2850,47 @@ static bool lower_nonconstant_array_loads(struct hlsl_ctx *ctx, struct hlsl_ir_n
         return false;
     hlsl_block_add_instr(block, zero);
 
-    if (!(store = hlsl_new_simple_store(ctx, var, zero)))
-        return false;
-    hlsl_block_add_instr(block, store);
+    hlsl_block_add_simple_store(ctx, block, var, zero);
 
     TRACE("Lowering non-constant %s load on variable '%s'.\n", row_major ? "row_major" : "array", deref->var->name);
 
     element_count = hlsl_type_element_count(cut_type);
     for (i = 0; i < element_count; ++i)
     {
+        struct hlsl_ir_node *const_i, *equals, *ternary, *specific_load, *var_load;
         struct hlsl_type *btype = hlsl_get_scalar_type(ctx, HLSL_TYPE_BOOL);
         struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {0};
-        struct hlsl_ir_node *const_i, *equals, *ternary, *var_store;
-        struct hlsl_ir_load *var_load, *specific_load;
         struct hlsl_deref deref_copy = {0};
 
-        if (!(const_i = hlsl_new_uint_constant(ctx, i, &cut_index->loc)))
-            return false;
-        hlsl_block_add_instr(block, const_i);
+        const_i = hlsl_block_add_uint_constant(ctx, block, i, &cut_index->loc);
 
         operands[0] = cut_index;
         operands[1] = const_i;
-        if (!(equals = hlsl_new_expr(ctx, HLSL_OP2_EQUAL, operands, btype, &cut_index->loc)))
-            return false;
-        hlsl_block_add_instr(block, equals);
+        equals = hlsl_block_add_expr(ctx, block, HLSL_OP2_EQUAL, operands, btype, &cut_index->loc);
 
         if (!(equals = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X),
                 var->data_type->e.numeric.dimx, equals, &cut_index->loc)))
             return false;
         hlsl_block_add_instr(block, equals);
 
-        if (!(var_load = hlsl_new_var_load(ctx, var, &cut_index->loc)))
-            return false;
-        hlsl_block_add_instr(block, &var_load->node);
+        var_load = hlsl_block_add_simple_load(ctx, block, var, &cut_index->loc);
 
         if (!hlsl_copy_deref(ctx, &deref_copy, deref))
             return false;
         hlsl_src_remove(&deref_copy.path[i_cut]);
         hlsl_src_from_node(&deref_copy.path[i_cut], const_i);
-
-        if (!(specific_load = hlsl_new_load_index(ctx, &deref_copy, NULL, &cut_index->loc)))
-        {
-            hlsl_cleanup_deref(&deref_copy);
-            return false;
-        }
-        hlsl_block_add_instr(block, &specific_load->node);
-
+        specific_load = hlsl_block_add_load_index(ctx, block, &deref_copy, NULL, &cut_index->loc);
         hlsl_cleanup_deref(&deref_copy);
 
         operands[0] = equals;
-        operands[1] = &specific_load->node;
-        operands[2] = &var_load->node;
-        if (!(ternary = hlsl_new_expr(ctx, HLSL_OP3_TERNARY, operands, instr->data_type, &cut_index->loc)))
-            return false;
-        hlsl_block_add_instr(block, ternary);
+        operands[1] = specific_load;
+        operands[2] = var_load;
+        ternary = hlsl_block_add_expr(ctx, block, HLSL_OP3_TERNARY, operands, instr->data_type, &cut_index->loc);
 
-        if (!(var_store = hlsl_new_simple_store(ctx, var, ternary)))
-            return false;
-        hlsl_block_add_instr(block, var_store);
+        hlsl_block_add_simple_store(ctx, block, var, ternary);
     }
 
-    if (!(load = hlsl_new_var_load(ctx, var, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, &load->node);
-
+    hlsl_block_add_simple_load(ctx, block, var, &instr->loc);
     return true;
 }
 
@@ -3305,7 +3188,7 @@ static bool lower_casts_to_int(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         return false;
 
     arg = expr->operands[0].node;
-    if (instr->data_type->e.numeric.type != HLSL_TYPE_INT && instr->data_type->e.numeric.type != HLSL_TYPE_UINT)
+    if (!hlsl_type_is_integer(instr->data_type) || instr->data_type->e.numeric.type == HLSL_TYPE_BOOL)
         return false;
     if (arg->data_type->e.numeric.type != HLSL_TYPE_FLOAT && arg->data_type->e.numeric.type != HLSL_TYPE_HALF)
         return false;
@@ -3328,13 +3211,8 @@ static bool lower_casts_to_int(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
             return false;
         hlsl_block_add_instr(block, one);
 
-        if (!(fract = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, arg, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, fract);
-
-        if (!(neg_fract = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, fract, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, neg_fract);
+        fract = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_FRACT, arg, &instr->loc);
+        neg_fract = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, fract, &instr->loc);
 
         if (!(has_fract = hlsl_new_ternary_expr(ctx, HLSL_OP3_CMP, neg_fract, zero, one)))
             return false;
@@ -3344,41 +3222,19 @@ static bool lower_casts_to_int(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
             return false;
         hlsl_block_add_instr(block, extra);
 
-        if (!(floor = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, arg, neg_fract)))
-            return false;
-        hlsl_block_add_instr(block, floor);
-
-        if (!(res = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, floor, extra)))
-            return false;
-        hlsl_block_add_instr(block, res);
+        floor = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, arg, neg_fract);
+        res = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, floor, extra);
     }
     else
     {
         struct hlsl_ir_node *neg_arg, *is_neg, *fract, *neg_fract, *has_fract, *floor;
 
-        if (!(neg_arg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, neg_arg);
-
-        if (!(is_neg = hlsl_new_binary_expr(ctx, HLSL_OP2_SLT, arg, neg_arg)))
-            return false;
-        hlsl_block_add_instr(block, is_neg);
-
-        if (!(fract = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, arg, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, fract);
-
-        if (!(neg_fract = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, fract, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, neg_fract);
-
-        if (!(has_fract = hlsl_new_binary_expr(ctx, HLSL_OP2_SLT, neg_fract, fract)))
-            return false;
-        hlsl_block_add_instr(block, has_fract);
-
-        if (!(floor = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, arg, neg_fract)))
-            return false;
-        hlsl_block_add_instr(block, floor);
+        neg_arg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, arg, &instr->loc);
+        is_neg = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_SLT, arg, neg_arg);
+        fract = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_FRACT, arg, &instr->loc);
+        neg_fract = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, fract, &instr->loc);
+        has_fract = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_SLT, neg_fract, fract);
+        floor = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, arg, neg_fract);
 
         if (!(res = hlsl_new_ternary_expr(ctx, HLSL_OP3_MAD, is_neg, has_fract, floor)))
             return false;
@@ -3387,18 +3243,17 @@ static bool lower_casts_to_int(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
 
     memset(operands, 0, sizeof(operands));
     operands[0] = res;
-    if (!(res = hlsl_new_expr(ctx, HLSL_OP1_REINTERPRET, operands, instr->data_type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, res);
-
+    hlsl_block_add_expr(ctx, block, HLSL_OP1_REINTERPRET, operands, instr->data_type, &instr->loc);
     return true;
 }
 
 /* Lower DIV to RCP + MUL. */
 static bool lower_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *rcp, *mul;
+    struct hlsl_ir_node *rcp, *ret, *operands[2];
+    struct hlsl_type *float_type;
     struct hlsl_ir_expr *expr;
+    bool is_float;
 
     if (instr->type != HLSL_IR_EXPR)
         return false;
@@ -3406,13 +3261,21 @@ static bool lower_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, str
     if (expr->op != HLSL_OP2_DIV)
         return false;
 
-    if (!(rcp = hlsl_new_unary_expr(ctx, HLSL_OP1_RCP, expr->operands[1].node, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, rcp);
+    is_float = instr->data_type->e.numeric.type == HLSL_TYPE_FLOAT
+            || instr->data_type->e.numeric.type == HLSL_TYPE_HALF;
+    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->e.numeric.dimx);
 
-    if (!(mul = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, expr->operands[0].node, rcp)))
-        return false;
-    hlsl_block_add_instr(block, mul);
+    for (unsigned int i = 0; i < 2; ++i)
+    {
+        operands[i] = expr->operands[i].node;
+        if (!is_float)
+            operands[i] = hlsl_block_add_cast(ctx, block, operands[i], float_type, &instr->loc);
+    }
+
+    rcp = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_RCP, operands[1], &instr->loc);
+    ret = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MUL, operands[0], rcp);
+    if (!is_float)
+        ret = hlsl_block_add_cast(ctx, block, ret, instr->data_type, &instr->loc);
 
     return true;
 }
@@ -3420,8 +3283,8 @@ static bool lower_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, str
 /* Lower SQRT to RSQ + RCP. */
 static bool lower_sqrt(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *rsq, *rcp;
     struct hlsl_ir_expr *expr;
+    struct hlsl_ir_node *rsq;
 
     if (instr->type != HLSL_IR_EXPR)
         return false;
@@ -3429,20 +3292,15 @@ static bool lower_sqrt(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
     if (expr->op != HLSL_OP1_SQRT)
         return false;
 
-    if (!(rsq = hlsl_new_unary_expr(ctx, HLSL_OP1_RSQ, expr->operands[0].node, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, rsq);
-
-    if (!(rcp = hlsl_new_unary_expr(ctx, HLSL_OP1_RCP, rsq, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, rcp);
+    rsq = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_RSQ, expr->operands[0].node, &instr->loc);
+    hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_RCP, rsq, &instr->loc);
     return true;
 }
 
 /* Lower DP2 to MUL + ADD */
 static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *arg1, *arg2, *mul, *replacement, *zero, *add_x, *add_y;
+    struct hlsl_ir_node *arg1, *arg2, *mul, *add_x, *add_y;
     struct hlsl_ir_expr *expr;
 
     if (instr->type != HLSL_IR_EXPR)
@@ -3459,22 +3317,15 @@ static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
     {
         struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = { 0 };
 
-        if (!(zero = hlsl_new_float_constant(ctx, 0.0f, &expr->node.loc)))
-            return false;
-        hlsl_block_add_instr(block, zero);
-
         operands[0] = arg1;
         operands[1] = arg2;
-        operands[2] = zero;
+        operands[2] = hlsl_block_add_float_constant(ctx, block, 0.0f, &expr->node.loc);
 
-        if (!(replacement = hlsl_new_expr(ctx, HLSL_OP3_DP2ADD, operands, instr->data_type, &expr->node.loc)))
-            return false;
+        hlsl_block_add_expr(ctx, block, HLSL_OP3_DP2ADD, operands, instr->data_type, &expr->node.loc);
     }
     else
     {
-        if (!(mul = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, expr->operands[0].node, expr->operands[1].node)))
-            return false;
-        hlsl_block_add_instr(block, mul);
+        mul = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MUL, expr->operands[0].node, expr->operands[1].node);
 
         if (!(add_x = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X),
                 instr->data_type->e.numeric.dimx, mul, &expr->node.loc)))
@@ -3486,10 +3337,8 @@ static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
             return false;
         hlsl_block_add_instr(block, add_y);
 
-        if (!(replacement = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, add_x, add_y)))
-            return false;
+        hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, add_x, add_y);
     }
-    hlsl_block_add_instr(block, replacement);
 
     return true;
 }
@@ -3497,7 +3346,7 @@ static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
 /* Lower ABS to MAX */
 static bool lower_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *arg, *neg, *replacement;
+    struct hlsl_ir_node *arg, *neg;
     struct hlsl_ir_expr *expr;
 
     if (instr->type != HLSL_IR_EXPR)
@@ -3507,21 +3356,15 @@ static bool lower_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
     if (expr->op != HLSL_OP1_ABS)
         return false;
 
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
-
-    if (!(replacement = hlsl_new_binary_expr(ctx, HLSL_OP2_MAX, neg, arg)))
-        return false;
-    hlsl_block_add_instr(block, replacement);
-
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, arg, &instr->loc);
+    hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MAX, neg, arg);
     return true;
 }
 
 /* Lower ROUND using FRC, ROUND(x) -> ((x + 0.5) - FRC(x + 0.5)). */
 static bool lower_round(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *arg, *neg, *sum, *frc, *half, *replacement;
+    struct hlsl_ir_node *arg, *neg, *sum, *frc, *half;
     struct hlsl_type *type = instr->data_type;
     struct hlsl_constant_value half_value;
     unsigned int i, component_count;
@@ -3542,29 +3385,17 @@ static bool lower_round(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
         return false;
     hlsl_block_add_instr(block, half);
 
-    if (!(sum = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, arg, half)))
-        return false;
-    hlsl_block_add_instr(block, sum);
-
-    if (!(frc = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, sum, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, frc);
-
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, frc, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
-
-    if (!(replacement = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, sum, neg)))
-        return false;
-    hlsl_block_add_instr(block, replacement);
-
+    sum = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, arg, half);
+    frc = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_FRACT, sum, &instr->loc);
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, frc, &instr->loc);
+    hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, sum, neg);
     return true;
 }
 
 /* Lower CEIL to FRC */
 static bool lower_ceil(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *arg, *neg, *sum, *frc;
+    struct hlsl_ir_node *arg, *neg, *frc;
     struct hlsl_ir_expr *expr;
 
     if (instr->type != HLSL_IR_EXPR)
@@ -3575,25 +3406,16 @@ static bool lower_ceil(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
     if (expr->op != HLSL_OP1_CEIL)
         return false;
 
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
-
-    if (!(frc = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, neg, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, frc);
-
-    if (!(sum = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, frc, arg)))
-        return false;
-    hlsl_block_add_instr(block, sum);
-
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, arg, &instr->loc);
+    frc = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_FRACT, neg, &instr->loc);
+    hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, frc, arg);
     return true;
 }
 
 /* Lower FLOOR to FRC */
 static bool lower_floor(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *arg, *neg, *sum, *frc;
+    struct hlsl_ir_node *arg, *neg, *frc;
     struct hlsl_ir_expr *expr;
 
     if (instr->type != HLSL_IR_EXPR)
@@ -3604,18 +3426,9 @@ static bool lower_floor(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
     if (expr->op != HLSL_OP1_FLOOR)
         return false;
 
-    if (!(frc = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, arg, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, frc);
-
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, frc, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
-
-    if (!(sum = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, neg, arg)))
-        return false;
-    hlsl_block_add_instr(block, sum);
-
+    frc = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_FRACT, arg, &instr->loc);
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, frc, &instr->loc);
+    hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, neg, arg);
     return true;
 }
 
@@ -3667,25 +3480,20 @@ static bool lower_trig(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
     if (!(mad = hlsl_new_ternary_expr(ctx, HLSL_OP3_MAD, arg, reciprocal_two_pi, half)))
         return false;
     hlsl_block_add_instr(block, mad);
-    if (!(frc = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, mad, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, frc);
+    frc = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_FRACT, mad, &instr->loc);
     if (!(reduced = hlsl_new_ternary_expr(ctx, HLSL_OP3_MAD, frc, two_pi, neg_pi)))
         return false;
     hlsl_block_add_instr(block, reduced);
 
     if (type->e.numeric.dimx == 1)
     {
-        if (!(sincos = hlsl_new_unary_expr(ctx, op, reduced, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, sincos);
+        sincos = hlsl_block_add_unary_expr(ctx, block, op, reduced, &instr->loc);
     }
     else
     {
         struct hlsl_ir_node *comps[4] = {0};
         struct hlsl_ir_var *var;
         struct hlsl_deref var_deref;
-        struct hlsl_ir_load *var_load;
 
         for (i = 0; i < type->e.numeric.dimx; ++i)
         {
@@ -3702,20 +3510,11 @@ static bool lower_trig(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
 
         for (i = 0; i < type->e.numeric.dimx; ++i)
         {
-            struct hlsl_block store_block;
-
-            if (!(sincos = hlsl_new_unary_expr(ctx, op, comps[i], &instr->loc)))
-                return false;
-            hlsl_block_add_instr(block, sincos);
-
-            if (!hlsl_new_store_component(ctx, &store_block, &var_deref, i, sincos))
-                return false;
-            hlsl_block_add_block(block, &store_block);
+            sincos = hlsl_block_add_unary_expr(ctx, block, op, comps[i], &instr->loc);
+            hlsl_block_add_store_component(ctx, block, &var_deref, i, sincos);
         }
 
-        if (!(var_load = hlsl_new_load_index(ctx, &var_deref, NULL, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, &var_load->node);
+        hlsl_block_add_load_index(ctx, block, &var_deref, NULL, &instr->loc);
     }
 
     return true;
@@ -3723,8 +3522,8 @@ static bool lower_trig(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
 
 static bool lower_logic_not(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
+    struct hlsl_ir_node *arg, *arg_cast, *neg, *one, *sub;
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS];
-    struct hlsl_ir_node *arg, *arg_cast, *neg, *one, *sub, *res;
     struct hlsl_constant_value one_value;
     struct hlsl_type *float_type;
     struct hlsl_ir_expr *expr;
@@ -3741,13 +3540,9 @@ static bool lower_logic_not(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, st
     /* If this is happens, it means we failed to cast the argument to boolean somewhere. */
     VKD3D_ASSERT(arg->data_type->e.numeric.type == HLSL_TYPE_BOOL);
 
-    if (!(arg_cast = hlsl_new_cast(ctx, arg, float_type, &arg->loc)))
-        return false;
-    hlsl_block_add_instr(block, arg_cast);
+    arg_cast = hlsl_block_add_cast(ctx, block, arg, float_type, &arg->loc);
 
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg_cast, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, arg_cast, &instr->loc);
 
     one_value.u[0].f = 1.0;
     one_value.u[1].f = 1.0;
@@ -3757,24 +3552,19 @@ static bool lower_logic_not(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, st
         return false;
     hlsl_block_add_instr(block, one);
 
-    if (!(sub = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, one, neg)))
-        return false;
-    hlsl_block_add_instr(block, sub);
+    sub = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, one, neg);
 
     memset(operands, 0, sizeof(operands));
     operands[0] = sub;
-    if (!(res = hlsl_new_expr(ctx, HLSL_OP1_REINTERPRET, operands, instr->data_type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, res);
-
+    hlsl_block_add_expr(ctx, block, HLSL_OP1_REINTERPRET, operands, instr->data_type, &instr->loc);
     return true;
 }
 
 /* Lower TERNARY to CMP for SM1. */
 static bool lower_ternary(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = { 0 }, *replacement;
     struct hlsl_ir_node *cond, *first, *second, *float_cond, *neg;
+    struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {0};
     struct hlsl_ir_expr *expr;
     struct hlsl_type *type;
 
@@ -3799,23 +3589,14 @@ static bool lower_ternary(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
 
     type = hlsl_get_numeric_type(ctx, instr->data_type->class, HLSL_TYPE_FLOAT,
             instr->data_type->e.numeric.dimx, instr->data_type->e.numeric.dimy);
-
-    if (!(float_cond = hlsl_new_cast(ctx, cond, type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, float_cond);
-
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, float_cond, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
+    float_cond = hlsl_block_add_cast(ctx, block, cond, type, &instr->loc);
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, float_cond, &instr->loc);
 
     memset(operands, 0, sizeof(operands));
     operands[0] = neg;
     operands[1] = second;
     operands[2] = first;
-    if (!(replacement = hlsl_new_expr(ctx, HLSL_OP3_CMP, operands, first->data_type, &instr->loc)))
-        return false;
-
-    hlsl_block_add_instr(block, replacement);
+    hlsl_block_add_expr(ctx, block, HLSL_OP3_CMP, operands, first->data_type, &instr->loc);
     return true;
 }
 
@@ -3867,7 +3648,7 @@ static bool lower_resource_load_bias(struct hlsl_ctx *ctx, struct hlsl_ir_node *
 static bool lower_comparison_operators(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         struct hlsl_block *block)
 {
-    struct hlsl_ir_node *arg1, *arg1_cast, *arg2, *arg2_cast, *slt, *res, *ret;
+    struct hlsl_ir_node *arg1, *arg1_cast, *arg2, *arg2_cast, *slt, *res;
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS];
     struct hlsl_type *float_type;
     struct hlsl_ir_expr *expr;
@@ -3884,13 +3665,8 @@ static bool lower_comparison_operators(struct hlsl_ctx *ctx, struct hlsl_ir_node
     arg2 = expr->operands[1].node;
     float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->e.numeric.dimx);
 
-    if (!(arg1_cast = hlsl_new_cast(ctx, arg1, float_type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, arg1_cast);
-
-    if (!(arg2_cast = hlsl_new_cast(ctx, arg2, float_type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, arg2_cast);
+    arg1_cast = hlsl_block_add_cast(ctx, block, arg1, float_type, &instr->loc);
+    arg2_cast = hlsl_block_add_cast(ctx, block, arg2, float_type, &instr->loc);
 
     switch (expr->op)
     {
@@ -3899,36 +3675,21 @@ static bool lower_comparison_operators(struct hlsl_ctx *ctx, struct hlsl_ir_node
         {
             struct hlsl_ir_node *neg, *sub, *abs, *abs_neg;
 
-            if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg2_cast, &instr->loc)))
-                return false;
-            hlsl_block_add_instr(block, neg);
-
-            if (!(sub = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, arg1_cast, neg)))
-                return false;
-            hlsl_block_add_instr(block, sub);
+            neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, arg2_cast, &instr->loc);
+            sub = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, arg1_cast, neg);
 
             if (ctx->profile->major_version >= 3)
             {
-                if (!(abs = hlsl_new_unary_expr(ctx, HLSL_OP1_ABS, sub, &instr->loc)))
-                    return false;
-                hlsl_block_add_instr(block, abs);
+                abs = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_ABS, sub, &instr->loc);
             }
             else
             {
                 /* Use MUL as a precarious ABS. */
-                if (!(abs = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, sub, sub)))
-                    return false;
-                hlsl_block_add_instr(block, abs);
+                abs = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MUL, sub, sub);
             }
 
-            if (!(abs_neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, abs, &instr->loc)))
-                return false;
-            hlsl_block_add_instr(block, abs_neg);
-
-            if (!(slt = hlsl_new_binary_expr(ctx, HLSL_OP2_SLT, abs_neg, abs)))
-                return false;
-            hlsl_block_add_instr(block, slt);
-
+            abs_neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, abs, &instr->loc);
+            slt = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_SLT, abs_neg, abs);
             negate = (expr->op == HLSL_OP2_EQUAL);
             break;
         }
@@ -3936,10 +3697,7 @@ static bool lower_comparison_operators(struct hlsl_ctx *ctx, struct hlsl_ir_node
         case HLSL_OP2_GEQUAL:
         case HLSL_OP2_LESS:
         {
-            if (!(slt = hlsl_new_binary_expr(ctx, HLSL_OP2_SLT, arg1_cast, arg2_cast)))
-                return false;
-            hlsl_block_add_instr(block, slt);
-
+            slt = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_SLT, arg1_cast, arg2_cast);
             negate = (expr->op == HLSL_OP2_GEQUAL);
             break;
         }
@@ -3961,13 +3719,8 @@ static bool lower_comparison_operators(struct hlsl_ctx *ctx, struct hlsl_ir_node
             return false;
         hlsl_block_add_instr(block, one);
 
-        if (!(slt_neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, slt, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, slt_neg);
-
-        if (!(res = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, one, slt_neg)))
-            return false;
-        hlsl_block_add_instr(block, res);
+        slt_neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, slt, &instr->loc);
+        res = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, one, slt_neg);
     }
     else
     {
@@ -3978,10 +3731,7 @@ static bool lower_comparison_operators(struct hlsl_ctx *ctx, struct hlsl_ir_node
      * and casts to BOOL have already been lowered to "!= 0". */
     memset(operands, 0, sizeof(operands));
     operands[0] = res;
-    if (!(ret = hlsl_new_expr(ctx, HLSL_OP1_REINTERPRET, operands, instr->data_type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, ret);
-
+    hlsl_block_add_expr(ctx, block, HLSL_OP1_REINTERPRET, operands, instr->data_type, &instr->loc);
     return true;
 }
 
@@ -4010,21 +3760,10 @@ static bool lower_slt(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
     arg2 = expr->operands[1].node;
     float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->e.numeric.dimx);
 
-    if (!(arg1_cast = hlsl_new_cast(ctx, arg1, float_type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, arg1_cast);
-
-    if (!(arg2_cast = hlsl_new_cast(ctx, arg2, float_type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, arg2_cast);
-
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg2_cast, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
-
-    if (!(sub = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, arg1_cast, neg)))
-        return false;
-    hlsl_block_add_instr(block, sub);
+    arg1_cast = hlsl_block_add_cast(ctx, block, arg1, float_type, &instr->loc);
+    arg2_cast = hlsl_block_add_cast(ctx, block, arg2, float_type, &instr->loc);
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, arg2_cast, &instr->loc);
+    sub = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, arg1_cast, neg);
 
     memset(&zero_value, 0, sizeof(zero_value));
     if (!(zero = hlsl_new_constant(ctx, float_type, &zero_value, &instr->loc)))
@@ -4056,7 +3795,7 @@ static bool lower_slt(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
  */
 static bool lower_cmp(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *args[3], *args_cast[3], *slt, *neg_slt, *sub, *zero, *one, *mul1, *mul2, *add;
+    struct hlsl_ir_node *args[3], *args_cast[3], *slt, *neg_slt, *sub, *zero, *one, *mul1, *mul2;
     struct hlsl_constant_value zero_value, one_value;
     struct hlsl_type *float_type;
     struct hlsl_ir_expr *expr;
@@ -4073,10 +3812,7 @@ static bool lower_cmp(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
     for (i = 0; i < 3; ++i)
     {
         args[i] = expr->operands[i].node;
-
-        if (!(args_cast[i] = hlsl_new_cast(ctx, args[i], float_type, &instr->loc)))
-            return false;
-        hlsl_block_add_instr(block, args_cast[i]);
+        args_cast[i] = hlsl_block_add_cast(ctx, block, args[i], float_type, &instr->loc);
     }
 
     memset(&zero_value, 0, sizeof(zero_value));
@@ -4092,30 +3828,12 @@ static bool lower_cmp(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
         return false;
     hlsl_block_add_instr(block, one);
 
-    if (!(slt = hlsl_new_binary_expr(ctx, HLSL_OP2_SLT, args_cast[0], zero)))
-        return false;
-    hlsl_block_add_instr(block, slt);
-
-    if (!(mul1 = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, args_cast[2], slt)))
-        return false;
-    hlsl_block_add_instr(block, mul1);
-
-    if (!(neg_slt = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, slt, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg_slt);
-
-    if (!(sub = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, one, neg_slt)))
-        return false;
-    hlsl_block_add_instr(block, sub);
-
-    if (!(mul2 = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, args_cast[1], sub)))
-        return false;
-    hlsl_block_add_instr(block, mul2);
-
-    if (!(add = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, mul1, mul2)))
-        return false;
-    hlsl_block_add_instr(block, add);
-
+    slt = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_SLT, args_cast[0], zero);
+    mul1 = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MUL, args_cast[2], slt);
+    neg_slt = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, slt, &instr->loc);
+    sub = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, one, neg_slt);
+    mul2 = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MUL, args_cast[1], sub);
+    hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_ADD, mul1, mul2);
     return true;
 }
 
@@ -4145,10 +3863,8 @@ static bool lower_casts_to_bool(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
         return false;
     hlsl_block_add_instr(block, zero);
 
-    if (!(neq = hlsl_new_binary_expr(ctx, HLSL_OP2_NEQUAL, expr->operands[0].node, zero)))
-        return false;
+    neq = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_NEQUAL, expr->operands[0].node, zero);
     neq->data_type = expr->node.data_type;
-    hlsl_block_add_instr(block, neq);
 
     return true;
 }
@@ -4158,7 +3874,6 @@ struct hlsl_ir_node *hlsl_add_conditional(struct hlsl_ctx *ctx, struct hlsl_bloc
 {
     struct hlsl_type *cond_type = condition->data_type;
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS];
-    struct hlsl_ir_node *cond;
 
     VKD3D_ASSERT(hlsl_types_are_equal(if_true->data_type, if_false->data_type));
 
@@ -4166,20 +3881,13 @@ struct hlsl_ir_node *hlsl_add_conditional(struct hlsl_ctx *ctx, struct hlsl_bloc
     {
         cond_type = hlsl_get_numeric_type(ctx, cond_type->class, HLSL_TYPE_BOOL,
                 cond_type->e.numeric.dimx, cond_type->e.numeric.dimy);
-
-        if (!(condition = hlsl_new_cast(ctx, condition, cond_type, &condition->loc)))
-            return NULL;
-        hlsl_block_add_instr(instrs, condition);
+        condition = hlsl_block_add_cast(ctx, instrs, condition, cond_type, &condition->loc);
     }
 
     operands[0] = condition;
     operands[1] = if_true;
     operands[2] = if_false;
-    if (!(cond = hlsl_new_expr(ctx, HLSL_OP3_TERNARY, operands, if_true->data_type, &condition->loc)))
-        return false;
-    hlsl_block_add_instr(instrs, cond);
-
-    return cond;
+    return hlsl_block_add_expr(ctx, instrs, HLSL_OP3_TERNARY, operands, if_true->data_type, &condition->loc);
 }
 
 static bool lower_int_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
@@ -4203,9 +3911,7 @@ static bool lower_int_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         return false;
     utype = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_UINT, type->e.numeric.dimx, type->e.numeric.dimy);
 
-    if (!(xor = hlsl_new_binary_expr(ctx, HLSL_OP2_BIT_XOR, arg1, arg2)))
-        return false;
-    hlsl_block_add_instr(block, xor);
+    xor = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_BIT_XOR, arg1, arg2);
 
     for (i = 0; i < type->e.numeric.dimx; ++i)
         high_bit_value.u[i].u = 0x80000000;
@@ -4213,38 +3919,14 @@ static bool lower_int_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         return false;
     hlsl_block_add_instr(block, high_bit);
 
-    if (!(and = hlsl_new_binary_expr(ctx, HLSL_OP2_BIT_AND, xor, high_bit)))
-        return false;
-    hlsl_block_add_instr(block, and);
-
-    if (!(abs1 = hlsl_new_unary_expr(ctx, HLSL_OP1_ABS, arg1, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, abs1);
-
-    if (!(cast1 = hlsl_new_cast(ctx, abs1, utype, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, cast1);
-
-    if (!(abs2 = hlsl_new_unary_expr(ctx, HLSL_OP1_ABS, arg2, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, abs2);
-
-    if (!(cast2 = hlsl_new_cast(ctx, abs2, utype, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, cast2);
-
-    if (!(div = hlsl_new_binary_expr(ctx, HLSL_OP2_DIV, cast1, cast2)))
-        return false;
-    hlsl_block_add_instr(block, div);
-
-    if (!(cast3 = hlsl_new_cast(ctx, div, type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, cast3);
-
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, cast3, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
-
+    and = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_BIT_AND, xor, high_bit);
+    abs1 = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_ABS, arg1, &instr->loc);
+    cast1 = hlsl_block_add_cast(ctx, block, abs1, utype, &instr->loc);
+    abs2 = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_ABS, arg2, &instr->loc);
+    cast2 = hlsl_block_add_cast(ctx, block, abs2, utype, &instr->loc);
+    div = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_DIV, cast1, cast2);
+    cast3 = hlsl_block_add_cast(ctx, block, div, type, &instr->loc);
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, cast3, &instr->loc);
     return hlsl_add_conditional(ctx, block, and, neg, cast3);
 }
 
@@ -4275,45 +3957,21 @@ static bool lower_int_modulus(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         return false;
     hlsl_block_add_instr(block, high_bit);
 
-    if (!(and = hlsl_new_binary_expr(ctx, HLSL_OP2_BIT_AND, arg1, high_bit)))
-        return false;
-    hlsl_block_add_instr(block, and);
-
-    if (!(abs1 = hlsl_new_unary_expr(ctx, HLSL_OP1_ABS, arg1, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, abs1);
-
-    if (!(cast1 = hlsl_new_cast(ctx, abs1, utype, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, cast1);
-
-    if (!(abs2 = hlsl_new_unary_expr(ctx, HLSL_OP1_ABS, arg2, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, abs2);
-
-    if (!(cast2 = hlsl_new_cast(ctx, abs2, utype, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, cast2);
-
-    if (!(div = hlsl_new_binary_expr(ctx, HLSL_OP2_MOD, cast1, cast2)))
-        return false;
-    hlsl_block_add_instr(block, div);
-
-    if (!(cast3 = hlsl_new_cast(ctx, div, type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, cast3);
-
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, cast3, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
-
+    and = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_BIT_AND, arg1, high_bit);
+    abs1 = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_ABS, arg1, &instr->loc);
+    cast1 = hlsl_block_add_cast(ctx, block, abs1, utype, &instr->loc);
+    abs2 = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_ABS, arg2, &instr->loc);
+    cast2 = hlsl_block_add_cast(ctx, block, abs2, utype, &instr->loc);
+    div = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MOD, cast1, cast2);
+    cast3 = hlsl_block_add_cast(ctx, block, div, type, &instr->loc);
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, cast3, &instr->loc);
     return hlsl_add_conditional(ctx, block, and, neg, cast3);
 }
 
 static bool lower_int_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_type *type = instr->data_type;
-    struct hlsl_ir_node *arg, *neg, *max;
+    struct hlsl_ir_node *arg, *neg;
     struct hlsl_ir_expr *expr;
 
     if (instr->type != HLSL_IR_EXPR)
@@ -4329,14 +3987,8 @@ static bool lower_int_abs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
 
     arg = expr->operands[0].node;
 
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg);
-
-    if (!(max = hlsl_new_binary_expr(ctx, HLSL_OP2_MAX, arg, neg)))
-        return false;
-    hlsl_block_add_instr(block, max);
-
+    neg = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, arg, &instr->loc);
+    hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MAX, arg, neg);
     return true;
 }
 
@@ -4355,8 +4007,7 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
     if (expr->op != HLSL_OP2_DOT)
         return false;
 
-    if (type->e.numeric.type == HLSL_TYPE_INT || type->e.numeric.type == HLSL_TYPE_UINT
-            || type->e.numeric.type == HLSL_TYPE_BOOL)
+    if (hlsl_type_is_integer(type))
     {
         arg1 = expr->operands[0].node;
         arg2 = expr->operands[1].node;
@@ -4364,9 +4015,7 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
         dimx = arg1->data_type->e.numeric.dimx;
         is_bool = type->e.numeric.type == HLSL_TYPE_BOOL;
 
-        if (!(mult = hlsl_new_binary_expr(ctx, is_bool ? HLSL_OP2_LOGIC_AND : HLSL_OP2_MUL, arg1, arg2)))
-            return false;
-        hlsl_block_add_instr(block, mult);
+        mult = hlsl_block_add_binary_expr(ctx, block, is_bool ? HLSL_OP2_LOGIC_AND : HLSL_OP2_MUL, arg1, arg2);
 
         for (i = 0; i < dimx; ++i)
         {
@@ -4379,11 +4028,7 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
 
         res = comps[0];
         for (i = 1; i < dimx; ++i)
-        {
-            if (!(res = hlsl_new_binary_expr(ctx, is_bool ? HLSL_OP2_LOGIC_OR : HLSL_OP2_ADD, res, comps[i])))
-                return false;
-            hlsl_block_add_instr(block, res);
-        }
+            res = hlsl_block_add_binary_expr(ctx, block, is_bool ? HLSL_OP2_LOGIC_OR : HLSL_OP2_ADD, res, comps[i]);
 
         return true;
     }
@@ -4393,7 +4038,7 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
 
 static bool lower_float_modulus(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *arg1, *arg2, *mul1, *neg1, *ge, *neg2, *div, *mul2, *frc, *cond, *one, *mul3;
+    struct hlsl_ir_node *arg1, *arg2, *mul1, *neg1, *ge, *neg2, *div, *mul2, *frc, *cond, *one;
     struct hlsl_type *type = instr->data_type, *btype;
     struct hlsl_constant_value one_value;
     struct hlsl_ir_expr *expr;
@@ -4412,25 +4057,14 @@ static bool lower_float_modulus(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
         return false;
     btype = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_BOOL, type->e.numeric.dimx, type->e.numeric.dimy);
 
-    if (!(mul1 = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, arg2, arg1)))
-        return false;
-    hlsl_block_add_instr(block, mul1);
-
-    if (!(neg1 = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, mul1, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg1);
+    mul1 = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MUL, arg2, arg1);
+    neg1 = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, mul1, &instr->loc);
 
-    if (!(ge = hlsl_new_binary_expr(ctx, HLSL_OP2_GEQUAL, mul1, neg1)))
-        return false;
+    ge = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_GEQUAL, mul1, neg1);
     ge->data_type = btype;
-    hlsl_block_add_instr(block, ge);
 
-    if (!(neg2 = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg2, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, neg2);
-
-    if (!(cond = hlsl_add_conditional(ctx, block, ge, arg2, neg2)))
-        return false;
+    neg2 = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_NEG, arg2, &instr->loc);
+    cond = hlsl_add_conditional(ctx, block, ge, arg2, neg2);
 
     for (i = 0; i < type->e.numeric.dimx; ++i)
         one_value.u[i].f = 1.0f;
@@ -4438,82 +4072,13 @@ static bool lower_float_modulus(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
         return false;
     hlsl_block_add_instr(block, one);
 
-    if (!(div = hlsl_new_binary_expr(ctx, HLSL_OP2_DIV, one, cond)))
-        return false;
-    hlsl_block_add_instr(block, div);
-
-    if (!(mul2 = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, div, arg1)))
-        return false;
-    hlsl_block_add_instr(block, mul2);
-
-    if (!(frc = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, mul2, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, frc);
-
-    if (!(mul3 = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, frc, cond)))
-        return false;
-    hlsl_block_add_instr(block, mul3);
-
+    div = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_DIV, one, cond);
+    mul2 = hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MUL, div, arg1);
+    frc = hlsl_block_add_unary_expr(ctx, block, HLSL_OP1_FRACT, mul2, &instr->loc);
+    hlsl_block_add_binary_expr(ctx, block, HLSL_OP2_MUL, frc, cond);
     return true;
 }
 
-static bool lower_nonfloat_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
-{
-    struct hlsl_ir_expr *expr;
-
-    if (instr->type != HLSL_IR_EXPR)
-        return false;
-    expr = hlsl_ir_expr(instr);
-    if (expr->op == HLSL_OP1_CAST || instr->data_type->e.numeric.type == HLSL_TYPE_FLOAT)
-        return false;
-
-    switch (expr->op)
-    {
-        case HLSL_OP1_ABS:
-        case HLSL_OP1_NEG:
-        case HLSL_OP2_ADD:
-        case HLSL_OP2_DIV:
-        case HLSL_OP2_LOGIC_AND:
-        case HLSL_OP2_LOGIC_OR:
-        case HLSL_OP2_MAX:
-        case HLSL_OP2_MIN:
-        case HLSL_OP2_MUL:
-        {
-            struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {0};
-            struct hlsl_ir_node *arg, *arg_cast, *float_expr, *ret;
-            struct hlsl_type *float_type;
-            unsigned int i;
-
-            for (i = 0; i < HLSL_MAX_OPERANDS; ++i)
-            {
-                arg = expr->operands[i].node;
-                if (!arg)
-                    continue;
-
-                float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, arg->data_type->e.numeric.dimx);
-                if (!(arg_cast = hlsl_new_cast(ctx, arg, float_type, &instr->loc)))
-                    return false;
-                hlsl_block_add_instr(block, arg_cast);
-
-                operands[i] = arg_cast;
-            }
-
-            float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->e.numeric.dimx);
-            if (!(float_expr = hlsl_new_expr(ctx, expr->op, operands, float_type, &instr->loc)))
-                return false;
-            hlsl_block_add_instr(block, float_expr);
-
-            if (!(ret = hlsl_new_cast(ctx, float_expr, instr->data_type, &instr->loc)))
-                return false;
-            hlsl_block_add_instr(block, ret);
-
-            return true;
-        }
-        default:
-            return false;
-    }
-}
-
 static bool lower_discard_neg(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
 {
     struct hlsl_ir_node *zero, *bool_false, *or, *cmp, *load;
@@ -4541,9 +4106,7 @@ static bool lower_discard_neg(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
     operands[1] = zero;
     cmp_type = hlsl_get_numeric_type(ctx, arg_type->class, HLSL_TYPE_BOOL,
             arg_type->e.numeric.dimx, arg_type->e.numeric.dimy);
-    if (!(cmp = hlsl_new_expr(ctx, HLSL_OP2_LESS, operands, cmp_type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(&block, cmp);
+    cmp = hlsl_block_add_expr(ctx, &block, HLSL_OP2_LESS, operands, cmp_type, &instr->loc);
 
     if (!(bool_false = hlsl_new_constant(ctx, hlsl_get_scalar_type(ctx, HLSL_TYPE_BOOL), &zero_value, &instr->loc)))
         return false;
@@ -4554,12 +4117,8 @@ static bool lower_discard_neg(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
     count = hlsl_type_component_count(cmp_type);
     for (i = 0; i < count; ++i)
     {
-        if (!(load = hlsl_add_load_component(ctx, &block, cmp, i, &instr->loc)))
-            return false;
-
-        if (!(or = hlsl_new_binary_expr(ctx, HLSL_OP2_LOGIC_OR, or, load)))
-                return NULL;
-        hlsl_block_add_instr(&block, or);
+        load = hlsl_add_load_component(ctx, &block, cmp, i, &instr->loc);
+        or = hlsl_block_add_binary_expr(ctx, &block, HLSL_OP2_LOGIC_OR, or, load);
     }
 
     list_move_tail(&instr->entry, &block.instrs);
@@ -4588,17 +4147,9 @@ static bool lower_discard_nz(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, v
 
     hlsl_block_init(&block);
 
-    if (!(cond_cast = hlsl_new_cast(ctx, cond, float_type, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(&block, cond_cast);
-
-    if (!(abs = hlsl_new_unary_expr(ctx, HLSL_OP1_ABS, cond_cast, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(&block, abs);
-
-    if (!(neg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, abs, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(&block, neg);
+    cond_cast = hlsl_block_add_cast(ctx, &block, cond, float_type, &instr->loc);
+    abs = hlsl_block_add_unary_expr(ctx, &block, HLSL_OP1_ABS, cond_cast, &instr->loc);
+    neg = hlsl_block_add_unary_expr(ctx, &block, HLSL_OP1_NEG, abs, &instr->loc);
 
     list_move_tail(&instr->entry, &block.instrs);
     hlsl_src_remove(&jump->condition);
@@ -4634,6 +4185,9 @@ static bool dce(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
             struct hlsl_ir_store *store = hlsl_ir_store(instr);
             struct hlsl_ir_var *var = store->lhs.var;
 
+            if (var->is_output_semantic)
+                break;
+
             if (var->last_read < instr->index)
             {
                 list_remove(&instr->entry);
@@ -4938,20 +4492,15 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
     }
 }
 
-static void init_var_liveness(struct hlsl_ir_var *var)
-{
-    if (var->is_uniform || var->is_input_semantic)
-        var->first_write = 1;
-    else if (var->is_output_semantic)
-        var->last_read = UINT_MAX;
-}
-
 static void compute_liveness(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func)
 {
     struct hlsl_scope *scope;
     struct hlsl_ir_var *var;
 
-    index_instructions(&entry_func->body, 2);
+    if (ctx->result)
+        return;
+
+    index_instructions(&entry_func->body, 1);
 
     LIST_FOR_EACH_ENTRY(scope, &ctx->scopes, struct hlsl_scope, entry)
     {
@@ -4959,12 +4508,6 @@ static void compute_liveness(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl
             var->first_write = var->last_read = 0;
     }
 
-    LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
-        init_var_liveness(var);
-
-    LIST_FOR_EACH_ENTRY(var, &entry_func->extern_vars, struct hlsl_ir_var, extern_entry)
-        init_var_liveness(var);
-
     compute_liveness_recurse(&entry_func->body, 0, 0);
 }
 
@@ -5001,7 +4544,7 @@ struct register_allocator
 
     /* Indexable temps are allocated separately and always keep their index regardless of their
      * lifetime. */
-    size_t indexable_count;
+    uint32_t indexable_count;
 
     /* Total number of registers allocated so far. Used to declare sm4 temp count. */
     uint32_t reg_count;
@@ -5553,6 +5096,7 @@ static void allocate_const_registers_recurse(struct hlsl_ctx *ctx,
                             f = value->i;
                             break;
 
+                        case HLSL_TYPE_MIN16UINT:
                         case HLSL_TYPE_UINT:
                             f = value->u;
                             break;
@@ -5765,15 +5309,12 @@ static uint32_t allocate_temp_registers(struct hlsl_ctx *ctx, struct hlsl_ir_fun
     /* ps_1_* outputs are special and go in temp register 0. */
     if (ctx->profile->major_version == 1 && ctx->profile->type == VKD3D_SHADER_TYPE_PIXEL)
     {
-        size_t i;
-
-        for (i = 0; i < entry_func->parameters.count; ++i)
+        LIST_FOR_EACH_ENTRY(var, &entry_func->extern_vars, struct hlsl_ir_var, extern_entry)
         {
-            var = entry_func->parameters.vars[i];
             if (var->is_output_semantic)
             {
                 record_allocation(ctx, &allocator, 0, VKD3DSP_WRITEMASK_ALL,
-                        var->first_write, var->last_read, 0, false);
+                        var->first_write, UINT_MAX, 0, false);
                 break;
             }
         }
@@ -5782,6 +5323,13 @@ static uint32_t allocate_temp_registers(struct hlsl_ctx *ctx, struct hlsl_ir_fun
     allocate_temp_registers_recurse(ctx, &entry_func->body, &allocator);
     vkd3d_free(allocator.allocations);
 
+    if (allocator.indexable_count)
+        TRACE("Declaration of function \"%s\" required %u temp registers, and %u indexable temps.\n",
+                entry_func->func->name, allocator.reg_count, allocator.indexable_count);
+    else
+        TRACE("Declaration of function \"%s\" required %u temp registers.\n",
+                entry_func->func->name, allocator.reg_count);
+
     return allocator.reg_count;
 }
 
@@ -5803,6 +5351,11 @@ static enum vkd3d_shader_interpolation_mode sm4_get_interpolation_mode(struct hl
         {HLSL_STORAGE_CENTROID | HLSL_STORAGE_LINEAR, VKD3DSIM_LINEAR_CENTROID},
     };
 
+    if (hlsl_type_is_patch_array(type))
+        type = type->e.array.type;
+
+    VKD3D_ASSERT(hlsl_is_numeric_type(type));
+
     if ((storage_modifiers & HLSL_STORAGE_NOINTERPOLATION)
             || base_type_get_semantic_equivalent(type->e.numeric.type) == HLSL_TYPE_UINT)
         return VKD3DSIM_CONSTANT;
@@ -7016,6 +6569,24 @@ void hlsl_lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_block *body)
     lower_ir(ctx, lower_index_loads, body);
 }
 
+static void hlsl_run_folding_passes(struct hlsl_ctx *ctx, struct hlsl_block *body)
+{
+    bool progress;
+
+    hlsl_transform_ir(ctx, fold_redundant_casts, body, NULL);
+    do
+    {
+        progress = hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, body, NULL);
+        progress |= hlsl_transform_ir(ctx, hlsl_fold_constant_identities, body, NULL);
+        progress |= hlsl_transform_ir(ctx, hlsl_normalize_binary_exprs, body, NULL);
+        progress |= hlsl_transform_ir(ctx, hlsl_fold_constant_swizzles, body, NULL);
+        progress |= hlsl_copy_propagation_execute(ctx, body);
+        progress |= hlsl_transform_ir(ctx, fold_swizzle_chains, body, NULL);
+        progress |= hlsl_transform_ir(ctx, remove_trivial_swizzles, body, NULL);
+        progress |= hlsl_transform_ir(ctx, remove_trivial_conditional_branches, body, NULL);
+    } while (progress);
+}
+
 void hlsl_run_const_passes(struct hlsl_ctx *ctx, struct hlsl_block *body)
 {
     bool progress;
@@ -7040,19 +6611,8 @@ void hlsl_run_const_passes(struct hlsl_ctx *ctx, struct hlsl_block *body)
     lower_ir(ctx, lower_int_abs, body);
     lower_ir(ctx, lower_casts_to_bool, body);
     lower_ir(ctx, lower_float_modulus, body);
-    hlsl_transform_ir(ctx, fold_redundant_casts, body, NULL);
 
-    do
-    {
-        progress = hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, body, NULL);
-        progress |= hlsl_transform_ir(ctx, hlsl_fold_constant_identities, body, NULL);
-        progress |= hlsl_transform_ir(ctx, hlsl_normalize_binary_exprs, body, NULL);
-        progress |= hlsl_transform_ir(ctx, hlsl_fold_constant_swizzles, body, NULL);
-        progress |= hlsl_copy_propagation_execute(ctx, body);
-        progress |= hlsl_transform_ir(ctx, fold_swizzle_chains, body, NULL);
-        progress |= hlsl_transform_ir(ctx, remove_trivial_swizzles, body, NULL);
-        progress |= hlsl_transform_ir(ctx, remove_trivial_conditional_branches, body, NULL);
-    } while (progress);
+    hlsl_run_folding_passes(ctx, body);
 }
 
 static void generate_vsir_signature_entry(struct hlsl_ctx *ctx, struct vsir_program *program,
@@ -7109,6 +6669,7 @@ static void generate_vsir_signature_entry(struct hlsl_ctx *ctx, struct vsir_prog
                 break;
 
             case HLSL_TYPE_BOOL:
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 component_type = VKD3D_SHADER_COMPONENT_UINT;
                 break;
@@ -7198,6 +6759,22 @@ static void generate_vsir_signature_entry(struct hlsl_ctx *ctx, struct vsir_prog
     element->used_mask = use_mask;
     if (program->shader_version.type == VKD3D_SHADER_TYPE_PIXEL && !output)
         element->interpolation_mode = VKD3DSIM_LINEAR;
+
+    switch (var->data_type->e.numeric.type)
+    {
+        case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_DOUBLE:
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_HALF:
+        case HLSL_TYPE_INT:
+        case HLSL_TYPE_UINT:
+            element->min_precision = VKD3D_SHADER_MINIMUM_PRECISION_NONE;
+            break;
+
+        case HLSL_TYPE_MIN16UINT:
+            element->min_precision = VKD3D_SHADER_MINIMUM_PRECISION_UINT_16;
+            break;
+    }
 }
 
 static void generate_vsir_signature(struct hlsl_ctx *ctx,
@@ -7265,6 +6842,7 @@ static enum vkd3d_data_type vsir_data_type_from_hlsl_type(struct hlsl_ctx *ctx,
                 return VKD3D_DATA_INT;
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_BOOL:
+            case HLSL_TYPE_MIN16UINT:
                 return VKD3D_DATA_UINT;
         }
     }
@@ -7929,7 +7507,7 @@ static void sm1_generate_vsir_instr_expr_sincos(struct hlsl_ctx *ctx, struct vsi
         src_param->reg.idx[0].offset = ctx->d3dsincosconst1.id;
         src_param->swizzle = VKD3D_SHADER_NO_SWIZZLE;
 
-        src_param = &ins->src[1];
+        src_param = &ins->src[2];
         vsir_register_init(&src_param->reg, VKD3DSPR_CONST, VKD3D_DATA_FLOAT, 1);
         src_param->reg.idx[0].offset = ctx->d3dsincosconst2.id;
         src_param->swizzle = VKD3D_SHADER_NO_SWIZZLE;
@@ -7957,6 +7535,7 @@ static bool sm1_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
             switch (src_type->e.numeric.type)
             {
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT:
                 case HLSL_TYPE_UINT:
                 case HLSL_TYPE_BOOL:
                     /* Integrals are internally represented as floats, so no change is necessary.*/
@@ -7978,8 +7557,9 @@ static bool sm1_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
             break;
 
         case HLSL_TYPE_INT:
+        case HLSL_TYPE_MIN16UINT:
         case HLSL_TYPE_UINT:
-            switch(src_type->e.numeric.type)
+            switch (src_type->e.numeric.type)
             {
                 case HLSL_TYPE_HALF:
                 case HLSL_TYPE_FLOAT:
@@ -7989,6 +7569,7 @@ static bool sm1_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
                     break;
 
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT:
                 case HLSL_TYPE_UINT:
                 case HLSL_TYPE_BOOL:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MOV, 0, 0, true);
@@ -8004,13 +7585,8 @@ static bool sm1_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
             switch (src_type->e.numeric.type)
             {
                 case HLSL_TYPE_FLOAT:
-                    if (ctx->double_as_float_alias)
-                    {
-                        generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MOV, 0, 0, true);
-                        return true;
-                    }
-                    hlsl_error(ctx, &instr->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
-                            "The 'double' type is not supported for the %s profile.", ctx->profile->name);
+                    generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MOV, 0, 0, true);
+                    return true;
                     break;
 
                 default:
@@ -8033,12 +7609,15 @@ static bool sm1_generate_vsir_instr_expr(struct hlsl_ctx *ctx, struct vsir_progr
         struct hlsl_ir_expr *expr)
 {
     struct hlsl_ir_node *instr = &expr->node;
+    struct hlsl_type *type = instr->data_type;
 
-    if (expr->op != HLSL_OP1_REINTERPRET && expr->op != HLSL_OP1_CAST
-            && instr->data_type->e.numeric.type != HLSL_TYPE_FLOAT)
+    if (!hlsl_is_numeric_type(type))
+        goto err;
+
+    if (type->e.numeric.type == HLSL_TYPE_DOUBLE && !ctx->double_as_float_alias)
     {
-        /* These need to be lowered. */
-        hlsl_fixme(ctx, &instr->loc, "SM1 non-float expression.");
+        hlsl_error(ctx, &instr->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                "The 'double' type is not supported for the %s profile.", ctx->profile->name);
         return false;
     }
 
@@ -8053,30 +7632,44 @@ static bool sm1_generate_vsir_instr_expr(struct hlsl_ctx *ctx, struct vsir_progr
 
         case HLSL_OP1_COS_REDUCED:
             VKD3D_ASSERT(expr->node.reg.writemask == VKD3DSP_WRITEMASK_0);
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             sm1_generate_vsir_instr_expr_sincos(ctx, program, expr);
             break;
 
         case HLSL_OP1_DSX:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_DSX, 0, 0, true);
             break;
 
         case HLSL_OP1_DSY:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_DSY, 0, 0, true);
             break;
 
         case HLSL_OP1_EXP2:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             sm1_generate_vsir_instr_expr_per_component_instr_op(ctx, program, expr, VKD3DSIH_EXP);
             break;
 
         case HLSL_OP1_LOG2:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             sm1_generate_vsir_instr_expr_per_component_instr_op(ctx, program, expr, VKD3DSIH_LOG);
             break;
 
         case HLSL_OP1_NEG:
+            if (type->e.numeric.type == HLSL_TYPE_BOOL)
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MOV, VKD3DSPSM_NEG, 0, true);
             break;
 
         case HLSL_OP1_RCP:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             sm1_generate_vsir_instr_expr_per_component_instr_op(ctx, program, expr, VKD3DSIH_RCP);
             break;
 
@@ -8085,23 +7678,33 @@ static bool sm1_generate_vsir_instr_expr(struct hlsl_ctx *ctx, struct vsir_progr
             break;
 
         case HLSL_OP1_RSQ:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             sm1_generate_vsir_instr_expr_per_component_instr_op(ctx, program, expr, VKD3DSIH_RSQ);
             break;
 
         case HLSL_OP1_SAT:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MOV, 0, VKD3DSPDM_SATURATE, true);
             break;
 
         case HLSL_OP1_SIN_REDUCED:
             VKD3D_ASSERT(expr->node.reg.writemask == VKD3DSP_WRITEMASK_1);
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             sm1_generate_vsir_instr_expr_sincos(ctx, program, expr);
             break;
 
         case HLSL_OP2_ADD:
+            if (type->e.numeric.type == HLSL_TYPE_BOOL)
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_ADD, 0, 0, true);
             break;
 
         case HLSL_OP2_DOT:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             switch (expr->operands[0].node->data_type->e.numeric.dimx)
             {
                 case 3:
@@ -8135,35 +7738,49 @@ static bool sm1_generate_vsir_instr_expr(struct hlsl_ctx *ctx, struct vsir_progr
             break;
 
         case HLSL_OP2_LOGIC_AND:
+            if (type->e.numeric.type != HLSL_TYPE_BOOL)
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MIN, 0, 0, true);
             break;
 
         case HLSL_OP2_LOGIC_OR:
+            if (type->e.numeric.type != HLSL_TYPE_BOOL)
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MAX, 0, 0, true);
             break;
 
         case HLSL_OP2_SLT:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_SLT, 0, 0, true);
             break;
 
         case HLSL_OP3_CMP:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_CMP, 0, 0, true);
             break;
 
         case HLSL_OP3_DP2ADD:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_DP2ADD, 0, 0, false);
             break;
 
         case HLSL_OP3_MAD:
+            if (!hlsl_type_is_floating_point(type))
+                goto err;
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MAD, 0, 0, true);
             break;
 
         default:
-            hlsl_fixme(ctx, &instr->loc, "SM1 \"%s\" expression.", debug_hlsl_expr_op(expr->op));
-            return false;
+            goto err;
     }
-
     return true;
+
+err:
+    hlsl_fixme(ctx, &instr->loc, "SM1 %s expression of type %s.", debug_hlsl_expr_op(expr->op), instr->data_type->name);
+    return false;
 }
 
 static void sm1_generate_vsir_init_dst_param_from_deref(struct hlsl_ctx *ctx,
@@ -8650,6 +8267,10 @@ D3DXPARAMETER_TYPE hlsl_sm1_base_type(const struct hlsl_type *type, bool is_comb
                 case HLSL_TYPE_INT:
                 case HLSL_TYPE_UINT:
                     return D3DXPT_INT;
+                /* Minimum-precision types are not supported until 46, but at
+                 * that point they do the same thing, and return sm4 types. */
+                case HLSL_TYPE_MIN16UINT:
+                    return 0x39;
             }
             break;
 
@@ -8934,6 +8555,7 @@ static void write_sm1_uniforms(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffe
                                 uni.f = var->default_values[k].number.i;
                                 break;
 
+                            case HLSL_TYPE_MIN16UINT:
                             case HLSL_TYPE_UINT:
                             case HLSL_TYPE_BOOL:
                                 uni.f = var->default_values[k].number.u;
@@ -9127,13 +8749,6 @@ static bool type_is_float(const struct hlsl_type *type)
     return type->e.numeric.type == HLSL_TYPE_FLOAT || type->e.numeric.type == HLSL_TYPE_HALF;
 }
 
-static bool type_is_integer(const struct hlsl_type *type)
-{
-    return type->e.numeric.type == HLSL_TYPE_BOOL
-            || type->e.numeric.type == HLSL_TYPE_INT
-            || type->e.numeric.type == HLSL_TYPE_UINT;
-}
-
 static void sm4_generate_vsir_cast_from_bool(struct hlsl_ctx *ctx, struct vsir_program *program,
         const struct hlsl_ir_expr *expr, uint32_t bits)
 {
@@ -9188,6 +8803,7 @@ static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_ITOF, 0, 0, true);
                     return true;
 
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_UTOF, 0, 0, true);
                     return true;
@@ -9211,6 +8827,7 @@ static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
                     return true;
 
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MOV, 0, 0, true);
                     return true;
@@ -9225,6 +8842,7 @@ static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
             }
             break;
 
+        case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
         case HLSL_TYPE_UINT:
             switch (src_type->e.numeric.type)
             {
@@ -9234,6 +8852,7 @@ static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
                     return true;
 
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MOV, 0, 0, true);
                     return true;
@@ -9339,7 +8958,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
             return true;
 
         case HLSL_OP1_BIT_NOT:
-            VKD3D_ASSERT(type_is_integer(dst_type));
+            VKD3D_ASSERT(hlsl_type_is_integer(dst_type));
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_NOT, 0, 0, true);
             return true;
 
@@ -9431,6 +9050,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
                     return true;
 
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_INEG, 0, 0, true);
                     return true;
@@ -9498,6 +9118,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
                     return true;
 
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_IADD, 0, 0, true);
                     return true;
@@ -9508,17 +9129,17 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
             }
 
         case HLSL_OP2_BIT_AND:
-            VKD3D_ASSERT(type_is_integer(dst_type));
+            VKD3D_ASSERT(hlsl_type_is_integer(dst_type));
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_AND, 0, 0, true);
             return true;
 
         case HLSL_OP2_BIT_OR:
-            VKD3D_ASSERT(type_is_integer(dst_type));
+            VKD3D_ASSERT(hlsl_type_is_integer(dst_type));
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_OR, 0, 0, true);
             return true;
 
         case HLSL_OP2_BIT_XOR:
-            VKD3D_ASSERT(type_is_integer(dst_type));
+            VKD3D_ASSERT(hlsl_type_is_integer(dst_type));
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_XOR, 0, 0, true);
             return true;
 
@@ -9529,6 +9150,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_DIV, 0, 0, true);
                     return true;
 
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     sm4_generate_vsir_expr_with_two_destinations(ctx, program, VKD3DSIH_UDIV, expr, 0);
                     return true;
@@ -9577,6 +9199,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
 
                 case HLSL_TYPE_BOOL:
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_IEQ, 0, 0, true);
                     return true;
@@ -9601,6 +9224,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
                     return true;
 
                 case HLSL_TYPE_BOOL:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_UGE, 0, 0, true);
                     return true;
@@ -9625,6 +9249,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
                     return true;
 
                 case HLSL_TYPE_BOOL:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_ULT, 0, 0, true);
                     return true;
@@ -9646,7 +9271,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
             return true;
 
         case HLSL_OP2_LSHIFT:
-            VKD3D_ASSERT(type_is_integer(dst_type));
+            VKD3D_ASSERT(hlsl_type_is_integer(dst_type));
             VKD3D_ASSERT(dst_type->e.numeric.type != HLSL_TYPE_BOOL);
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_ISHL, 0, 0, true);
             return true;
@@ -9659,6 +9284,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
                     return true;
 
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_IMAD, 0, 0, true);
                     return true;
@@ -9679,6 +9305,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_IMAX, 0, 0, true);
                     return true;
 
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_UMAX, 0, 0, true);
                     return true;
@@ -9699,6 +9326,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_IMIN, 0, 0, true);
                     return true;
 
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_UMIN, 0, 0, true);
                     return true;
@@ -9711,6 +9339,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
         case HLSL_OP2_MOD:
             switch (dst_type->e.numeric.type)
             {
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     sm4_generate_vsir_expr_with_two_destinations(ctx, program, VKD3DSIH_UDIV, expr, 1);
                     return true;
@@ -9728,6 +9357,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
                     return true;
 
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     /* Using IMUL instead of UMUL because we're taking the low
                      * bits, and the native compiler generates IMUL. */
@@ -9750,6 +9380,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
 
                 case HLSL_TYPE_BOOL:
                 case HLSL_TYPE_INT:
+                case HLSL_TYPE_MIN16UINT: /* FIXME: Needs minimum-precision annotations. */
                 case HLSL_TYPE_UINT:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_INE, 0, 0, true);
                     return true;
@@ -9761,7 +9392,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
             }
 
         case HLSL_OP2_RSHIFT:
-            VKD3D_ASSERT(type_is_integer(dst_type));
+            VKD3D_ASSERT(hlsl_type_is_integer(dst_type));
             VKD3D_ASSERT(dst_type->e.numeric.type != HLSL_TYPE_BOOL);
             generate_vsir_instr_expr_single_instr_op(ctx, program, expr,
                     dst_type->e.numeric.type == HLSL_TYPE_INT ? VKD3DSIH_ISHR : VKD3DSIH_USHR, 0, 0, true);
@@ -10840,12 +10471,32 @@ static void generate_vsir_scan_required_features(struct hlsl_ctx *ctx, struct vs
      * STENCIL_REF, and TYPED_UAV_LOAD_ADDITIONAL_FORMATS. */
 }
 
+static bool is_minimum_precision(enum hlsl_base_type type)
+{
+    switch (type)
+    {
+        case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_DOUBLE:
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_HALF:
+        case HLSL_TYPE_INT:
+        case HLSL_TYPE_UINT:
+            return false;
+
+        case HLSL_TYPE_MIN16UINT:
+            return true;
+    }
+
+    vkd3d_unreachable();
+}
+
 static void generate_vsir_scan_global_flags(struct hlsl_ctx *ctx,
         struct vsir_program *program, const struct hlsl_ir_function_decl *entry_func)
 {
     const struct vkd3d_shader_version *version = &program->shader_version;
     struct extern_resource *extern_resources;
     unsigned int extern_resources_count, i;
+    struct hlsl_ir_var *var;
 
     extern_resources = sm4_get_extern_resources(ctx, &extern_resources_count);
 
@@ -10866,6 +10517,25 @@ static void generate_vsir_scan_global_flags(struct hlsl_ctx *ctx,
 
     sm4_free_extern_resources(extern_resources, extern_resources_count);
 
+    LIST_FOR_EACH_ENTRY(var, &entry_func->extern_vars, struct hlsl_ir_var, extern_entry)
+    {
+        const struct hlsl_type *type = var->data_type;
+
+        if (hlsl_type_is_patch_array(type))
+            type = var->data_type->e.array.type;
+
+        /* Note that it doesn't matter if the semantic is unused or doesn't
+         * generate a signature element (e.g. SV_DispatchThreadID). */
+        if ((var->is_input_semantic || var->is_output_semantic)
+                && (type->is_minimum_precision || is_minimum_precision(type->e.numeric.type)))
+        {
+            program->global_flags |= VKD3DSGF_ENABLE_MINIMUM_PRECISION;
+            break;
+        }
+    }
+    /* FIXME: We also need to check for minimum-precision uniforms and local
+     * variable arithmetic. */
+
     if (entry_func->early_depth_test && vkd3d_shader_ver_ge(version, 5, 0))
         program->global_flags |= VKD3DSGF_FORCE_EARLY_DEPTH_STENCIL;
 }
@@ -10994,6 +10664,7 @@ static enum vkd3d_data_type sm4_generate_vsir_get_format_type(const struct hlsl_
             return VKD3D_DATA_INT;
 
         case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_MIN16UINT:
         case HLSL_TYPE_UINT:
             return VKD3D_DATA_UINT;
     }
@@ -11288,6 +10959,7 @@ static enum D3D_RESOURCE_RETURN_TYPE sm4_data_type(const struct hlsl_type *type)
             break;
 
         case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_MIN16UINT:
         case HLSL_TYPE_UINT:
             return D3D_RETURN_TYPE_UINT;
     }
@@ -11373,6 +11045,8 @@ static D3D_SHADER_VARIABLE_TYPE sm4_base_type(const struct hlsl_type *type)
             return D3D_SVT_INT;
         case HLSL_TYPE_UINT:
             return D3D_SVT_UINT;
+        case HLSL_TYPE_MIN16UINT:
+            return D3D_SVT_MIN16UINT;
     }
 
     vkd3d_unreachable();
@@ -11696,16 +11370,13 @@ static void sm4_generate_rdef(struct hlsl_ctx *ctx, struct vkd3d_shader_code *rd
 static bool loop_unrolling_generate_const_bool_store(struct hlsl_ctx *ctx, struct hlsl_ir_var *var,
         bool val, struct hlsl_block *block, struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_node *const_node, *store;
+    struct hlsl_ir_node *const_node;
 
     if (!(const_node = hlsl_new_bool_constant(ctx, val, loc)))
         return false;
     hlsl_block_add_instr(block, const_node);
 
-    if (!(store = hlsl_new_simple_store(ctx, var, const_node)))
-        return false;
-    hlsl_block_add_instr(block, store);
-
+    hlsl_block_add_simple_store(ctx, block, var, const_node);
     return true;
 }
 
@@ -11759,19 +11430,13 @@ static bool loop_unrolling_remove_jumps_visit(struct hlsl_ctx *ctx, struct hlsl_
 static struct hlsl_ir_if *loop_unrolling_generate_var_check(struct hlsl_ctx *ctx,
         struct hlsl_block *dst, struct hlsl_ir_var *var, struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_node *cond, *iff;
+    struct hlsl_ir_node *cond, *load, *iff;
     struct hlsl_block then_block;
-    struct hlsl_ir_load *load;
 
     hlsl_block_init(&then_block);
 
-    if (!(load = hlsl_new_var_load(ctx, var, loc)))
-        return NULL;
-    hlsl_block_add_instr(dst, &load->node);
-
-    if (!(cond = hlsl_new_unary_expr(ctx, HLSL_OP1_LOGIC_NOT, &load->node, loc)))
-        return NULL;
-    hlsl_block_add_instr(dst, cond);
+    load = hlsl_block_add_simple_load(ctx, dst, var, loc);
+    cond = hlsl_block_add_unary_expr(ctx, dst, HLSL_OP1_LOGIC_NOT, load, loc);
 
     if (!(iff = hlsl_new_if(ctx, cond, &then_block, NULL, loc)))
         return NULL;
@@ -12113,10 +11778,9 @@ static void loop_unrolling_execute(struct hlsl_ctx *ctx, struct hlsl_block *bloc
 
 static bool lower_f16tof32(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *call, *rhs, *store;
     struct hlsl_ir_function_decl *func;
+    struct hlsl_ir_node *call, *rhs;
     unsigned int component_count;
-    struct hlsl_ir_load *load;
     struct hlsl_ir_expr *expr;
     struct hlsl_ir_var *lhs;
     char *body;
@@ -12179,28 +11843,21 @@ static bool lower_f16tof32(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, stru
         return false;
 
     lhs = func->parameters.vars[0];
-
-    if (!(store = hlsl_new_simple_store(ctx, lhs, rhs)))
-        return false;
-    hlsl_block_add_instr(block, store);
+    hlsl_block_add_simple_store(ctx, block, lhs, rhs);
 
     if (!(call = hlsl_new_call(ctx, func, &node->loc)))
         return false;
     hlsl_block_add_instr(block, call);
 
-    if (!(load = hlsl_new_var_load(ctx, func->return_var, &node->loc)))
-        return false;
-    hlsl_block_add_instr(block, &load->node);
-
+    hlsl_block_add_simple_load(ctx, block, func->return_var, &node->loc);
     return true;
 }
 
 static bool lower_f32tof16(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *call, *rhs, *store;
     struct hlsl_ir_function_decl *func;
+    struct hlsl_ir_node *call, *rhs;
     unsigned int component_count;
-    struct hlsl_ir_load *load;
     struct hlsl_ir_expr *expr;
     struct hlsl_ir_var *lhs;
     char *body;
@@ -12251,30 +11908,22 @@ static bool lower_f32tof16(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, stru
         return false;
 
     lhs = func->parameters.vars[0];
-
-    if (!(store = hlsl_new_simple_store(ctx, lhs, rhs)))
-        return false;
-    hlsl_block_add_instr(block, store);
+    hlsl_block_add_simple_store(ctx, block, lhs, rhs);
 
     if (!(call = hlsl_new_call(ctx, func, &node->loc)))
         return false;
     hlsl_block_add_instr(block, call);
 
-    if (!(load = hlsl_new_var_load(ctx, func->return_var, &node->loc)))
-        return false;
-    hlsl_block_add_instr(block, &load->node);
-
+    hlsl_block_add_simple_load(ctx, block, func->return_var, &node->loc);
     return true;
 }
 
 static bool lower_isinf(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct hlsl_block *block)
 {
-    struct hlsl_ir_node *call, *rhs, *store;
     struct hlsl_ir_function_decl *func;
+    struct hlsl_ir_node *call, *rhs;
     unsigned int component_count;
-    struct hlsl_ir_load *load;
     struct hlsl_ir_expr *expr;
-    struct hlsl_ir_var *lhs;
     const char *template;
     char *body;
 
@@ -12327,7 +11976,7 @@ static bool lower_isinf(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct
         template = template_sm2;
     else if (hlsl_version_lt(ctx, 4, 0))
         template = template_sm3;
-    else if (type_is_integer(rhs->data_type))
+    else if (hlsl_type_is_integer(rhs->data_type))
         template = template_int;
     else
         template = template_sm4;
@@ -12339,20 +11988,13 @@ static bool lower_isinf(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct
     if (!(func = hlsl_compile_internal_function(ctx, "isinf", body)))
         return false;
 
-    lhs = func->parameters.vars[0];
-
-    if (!(store = hlsl_new_simple_store(ctx, lhs, rhs)))
-        return false;
-    hlsl_block_add_instr(block, store);
+    hlsl_block_add_simple_store(ctx, block, func->parameters.vars[0], rhs);
 
     if (!(call = hlsl_new_call(ctx, func, &node->loc)))
         return false;
     hlsl_block_add_instr(block, call);
 
-    if (!(load = hlsl_new_var_load(ctx, func->return_var, &node->loc)))
-        return false;
-    hlsl_block_add_instr(block, &load->node);
-
+    hlsl_block_add_simple_load(ctx, block, func->return_var, &node->loc);
     return true;
 }
 
@@ -12513,6 +12155,9 @@ static void process_entry_function(struct hlsl_ctx *ctx,
     lower_ir(ctx, lower_casts_to_bool, body);
     lower_ir(ctx, lower_int_dot, body);
 
+    compute_liveness(ctx, entry_func);
+    transform_derefs(ctx, divert_written_uniform_derefs_to_temp, &entry_func->body);
+
     if (hlsl_version_lt(ctx, 4, 0))
         hlsl_transform_ir(ctx, lower_separate_samples, body, NULL);
 
@@ -12537,14 +12182,12 @@ static void process_entry_function(struct hlsl_ctx *ctx,
         while (lower_ir(ctx, lower_nonconstant_array_loads, body));
 
         lower_ir(ctx, lower_ternary, body);
-
-        lower_ir(ctx, lower_nonfloat_exprs, body);
+        lower_ir(ctx, lower_division, body);
         /* Constants casted to float must be folded, and new casts to bool also need to be lowered. */
         hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, body, NULL);
         lower_ir(ctx, lower_casts_to_bool, body);
 
         lower_ir(ctx, lower_casts_to_int, body);
-        lower_ir(ctx, lower_division, body);
         lower_ir(ctx, lower_sqrt, body);
         lower_ir(ctx, lower_dot, body);
         lower_ir(ctx, lower_round, body);
@@ -12566,6 +12209,8 @@ static void process_entry_function(struct hlsl_ctx *ctx,
 
     lower_ir(ctx, validate_nonconstant_vector_store_derefs, body);
 
+    hlsl_run_folding_passes(ctx, body);
+
     do
         compute_liveness(ctx, entry_func);
     while (hlsl_transform_ir(ctx, dce, body, NULL));
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
index 538f0f46854..f4715a9224c 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
@@ -51,6 +51,7 @@ static bool fold_abs(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
                     dst->u[k].i = abs(src->value.u[k].i);
                 break;
 
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 dst->u[k].u = src->value.u[k].u;
                 break;
@@ -126,6 +127,7 @@ static bool fold_bit_not(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
         switch (type)
         {
             case HLSL_TYPE_INT:
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_BOOL:
                 dst->u[k].u = ~src->value.u[k].u;
@@ -175,6 +177,7 @@ static bool fold_cast(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
                 break;
 
             case HLSL_TYPE_UINT:
+            case HLSL_TYPE_MIN16UINT:
                 u = src->value.u[k].u;
                 i = src->value.u[k].u;
                 f = src->value.u[k].u;
@@ -205,6 +208,7 @@ static bool fold_cast(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
                 break;
 
             case HLSL_TYPE_UINT:
+            case HLSL_TYPE_MIN16UINT:
                 dst->u[k].u = u;
                 break;
 
@@ -395,6 +399,7 @@ static bool fold_neg(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
                 break;
 
             case HLSL_TYPE_INT:
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 dst->u[k].u = -src->value.u[k].u;
                 break;
@@ -612,6 +617,7 @@ static bool fold_add(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
             /* Handling HLSL_TYPE_INT through the unsigned field to avoid
              * undefined behavior with signed integers in C. */
             case HLSL_TYPE_INT:
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 dst->u[k].u = src1->value.u[k].u + src2->value.u[k].u;
                 break;
@@ -638,6 +644,7 @@ static bool fold_and(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
         switch (type)
         {
             case HLSL_TYPE_INT:
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_BOOL:
                 dst->u[k].u = src1->value.u[k].u & src2->value.u[k].u;
@@ -665,6 +672,7 @@ static bool fold_or(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const
         switch (type)
         {
             case HLSL_TYPE_INT:
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_BOOL:
                 dst->u[k].u = src1->value.u[k].u | src2->value.u[k].u;
@@ -692,6 +700,7 @@ static bool fold_bit_xor(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
         switch (type)
         {
             case HLSL_TYPE_INT:
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 dst->u[k].u = src1->value.u[k].u ^ src2->value.u[k].u;
                 break;
@@ -813,6 +822,7 @@ static bool fold_div(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
                     dst->u[k].i = src1->value.u[k].i / src2->value.u[k].i;
                 break;
 
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 if (src2->value.u[k].u == 0)
                 {
@@ -855,6 +865,7 @@ static bool fold_equal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, co
             case HLSL_TYPE_INT:
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_BOOL:
+            case HLSL_TYPE_MIN16UINT:
                 dst->u[k].u = src1->value.u[k].u == src2->value.u[k].u;
                 break;
         }
@@ -891,6 +902,7 @@ static bool fold_gequal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
 
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_BOOL:
+            case HLSL_TYPE_MIN16UINT:
                 dst->u[k].u = src1->value.u[k].u >= src2->value.u[k].u;
                 break;
         }
@@ -927,6 +939,7 @@ static bool fold_less(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, con
 
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_BOOL:
+            case HLSL_TYPE_MIN16UINT:
                 dst->u[k].u = src1->value.u[k].u < src2->value.u[k].u;
                 break;
         }
@@ -951,6 +964,7 @@ static bool fold_lshift(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
         switch (src1->node.data_type->e.numeric.type)
         {
             case HLSL_TYPE_INT:
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 dst->u[k].u = src1->value.u[k].u << shift;
                 break;
@@ -989,6 +1003,7 @@ static bool fold_max(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
                 dst->u[k].i = max(src1->value.u[k].i, src2->value.u[k].i);
                 break;
 
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 dst->u[k].u = max(src1->value.u[k].u, src2->value.u[k].u);
                 break;
@@ -1027,6 +1042,7 @@ static bool fold_min(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
                 dst->u[k].i = min(src1->value.u[k].i, src2->value.u[k].i);
                 break;
 
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 dst->u[k].u = min(src1->value.u[k].u, src2->value.u[k].u);
                 break;
@@ -1065,6 +1081,7 @@ static bool fold_mod(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
                     dst->u[k].i = src1->value.u[k].i % src2->value.u[k].i;
                 break;
 
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 if (src2->value.u[k].u == 0)
                 {
@@ -1105,6 +1122,7 @@ static bool fold_mul(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
                 break;
 
             case HLSL_TYPE_INT:
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 dst->u[k].u = src1->value.u[k].u * src2->value.u[k].u;
                 break;
@@ -1141,6 +1159,7 @@ static bool fold_nequal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
             case HLSL_TYPE_INT:
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_BOOL:
+            case HLSL_TYPE_MIN16UINT:
                 dst->u[k].u = src1->value.u[k].u != src2->value.u[k].u;
                 break;
         }
@@ -1183,6 +1202,7 @@ static bool fold_rshift(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
                 dst->u[k].i = src1->value.u[k].i >> shift;
                 break;
 
+            case HLSL_TYPE_MIN16UINT:
             case HLSL_TYPE_UINT:
                 dst->u[k].u = src1->value.u[k].u >> shift;
                 break;
@@ -1399,6 +1419,7 @@ static bool constant_is_zero(struct hlsl_ir_constant *const_arg)
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_INT:
             case HLSL_TYPE_BOOL:
+            case HLSL_TYPE_MIN16UINT:
                 if (const_arg->value.u[k].u != 0)
                     return false;
                 break;
@@ -1429,6 +1450,7 @@ static bool constant_is_one(struct hlsl_ir_constant *const_arg)
 
             case HLSL_TYPE_UINT:
             case HLSL_TYPE_INT:
+            case HLSL_TYPE_MIN16UINT:
                 if (const_arg->value.u[k].u != 1)
                     return false;
                 break;
@@ -1524,7 +1546,7 @@ static bool is_op_associative(enum hlsl_ir_expr_op op, enum hlsl_base_type type)
     {
         case HLSL_OP2_ADD:
         case HLSL_OP2_MUL:
-            return type == HLSL_TYPE_INT || type == HLSL_TYPE_UINT;
+            return hlsl_base_type_is_integer(type);
 
         case HLSL_OP2_BIT_AND:
         case HLSL_OP2_BIT_OR:
@@ -1574,7 +1596,7 @@ static bool is_op_left_distributive(enum hlsl_ir_expr_op opl, enum hlsl_ir_expr_
 
         case HLSL_OP2_DOT:
         case HLSL_OP2_MUL:
-            return opr == HLSL_OP2_ADD && (type == HLSL_TYPE_INT || type == HLSL_TYPE_UINT);
+            return opr == HLSL_OP2_ADD && hlsl_base_type_is_integer(type);
 
         case HLSL_OP2_MAX:
             return opr == HLSL_OP2_MIN;
@@ -1593,7 +1615,6 @@ static struct hlsl_ir_node *collect_exprs(struct hlsl_ctx *ctx, struct hlsl_bloc
 {
     enum hlsl_base_type type = instr->data_type->e.numeric.type;
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {0};
-    struct hlsl_ir_node *ab, *res;
     struct hlsl_ir_expr *e1, *e2;
     enum hlsl_ir_expr_op opl;
 
@@ -1610,17 +1631,9 @@ static struct hlsl_ir_node *collect_exprs(struct hlsl_ctx *ctx, struct hlsl_bloc
     if (e1->operands[1].node->type != HLSL_IR_CONSTANT || e2->operands[1].node->type != HLSL_IR_CONSTANT)
         return NULL;
 
-    if (!(ab = hlsl_new_binary_expr(ctx, opr, e1->operands[1].node, e2->operands[1].node)))
-        return NULL;
-    hlsl_block_add_instr(block, ab);
-
     operands[0] = e1->operands[0].node;
-    operands[1] = ab;
-
-    if (!(res = hlsl_new_expr(ctx, opl, operands, instr->data_type, &instr->loc)))
-        return NULL;
-    hlsl_block_add_instr(block, res);
-    return res;
+    operands[1] = hlsl_block_add_binary_expr(ctx, block, opr, e1->operands[1].node, e2->operands[1].node);
+    return hlsl_block_add_expr(ctx, block, opl, operands, instr->data_type, &instr->loc);
 }
 
 bool hlsl_normalize_binary_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
@@ -1677,26 +1690,14 @@ bool hlsl_normalize_binary_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *inst
             if (arg2->type == HLSL_IR_CONSTANT)
             {
                 /* (x OP a) OP b -> x OP (a OP b) */
-                struct hlsl_ir_node *ab;
-
-                if (!(ab = hlsl_new_binary_expr(ctx, op, e1->operands[1].node, arg2)))
-                    goto fail;
-                hlsl_block_add_instr(&block, ab);
-
                 arg1 = e1->operands[0].node;
-                arg2 = ab;
+                arg2 = hlsl_block_add_binary_expr(ctx, &block, op, e1->operands[1].node, arg2);
                 progress = true;
             }
             else if (is_op_commutative(op))
             {
                 /* (x OP a) OP y -> (x OP y) OP a */
-                struct hlsl_ir_node *xy;
-
-                if (!(xy = hlsl_new_binary_expr(ctx, op, e1->operands[0].node, arg2)))
-                    goto fail;
-                hlsl_block_add_instr(&block, xy);
-
-                arg1 = xy;
+                arg1 = hlsl_block_add_binary_expr(ctx, &block, op, e1->operands[0].node, arg2);
                 arg2 = e1->operands[1].node;
                 progress = true;
             }
@@ -1706,13 +1707,7 @@ bool hlsl_normalize_binary_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *inst
                 && e2->operands[0].node->type != HLSL_IR_CONSTANT && e2->operands[1].node->type == HLSL_IR_CONSTANT)
         {
             /* x OP (y OP a) -> (x OP y) OP a */
-            struct hlsl_ir_node *xy;
-
-            if (!(xy = hlsl_new_binary_expr(ctx, op, arg1, e2->operands[0].node)))
-                goto fail;
-            hlsl_block_add_instr(&block, xy);
-
-            arg1 = xy;
+            arg1 = hlsl_block_add_binary_expr(ctx, &block, op, arg1, e2->operands[0].node);
             arg2 = e2->operands[1].node;
             progress = true;
         }
@@ -1757,19 +1752,13 @@ bool hlsl_normalize_binary_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *inst
         struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {arg1, arg2};
         struct hlsl_ir_node *res;
 
-        if (!(res = hlsl_new_expr(ctx, op, operands, instr->data_type, &instr->loc)))
-            goto fail;
-        hlsl_block_add_instr(&block, res);
+        res = hlsl_block_add_expr(ctx, &block, op, operands, instr->data_type, &instr->loc);
 
         list_move_before(&instr->entry, &block.instrs);
         hlsl_replace_node(instr, res);
     }
 
     return progress;
-
-fail:
-    hlsl_block_cleanup(&block);
-    return false;
 }
 
 bool hlsl_fold_constant_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index b608fae21ac..41aa99fbc09 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -1732,8 +1732,20 @@ static enum vkd3d_result instruction_array_normalise_hull_shader_control_point_i
     return VKD3D_OK;
 }
 
+struct io_normaliser_register_data
+{
+    struct
+    {
+        uint8_t register_count;
+        uint32_t mask;
+        uint32_t used_mask;
+    } component[VKD3D_VEC4_SIZE];
+};
+
+
 struct io_normaliser
 {
+    struct vkd3d_shader_message_context *message_context;
     struct vkd3d_shader_instruction_array instructions;
     enum vkd3d_shader_type shader_type;
     uint8_t major;
@@ -1751,9 +1763,9 @@ struct io_normaliser
     struct vkd3d_shader_dst_param *input_dcl_params[MAX_REG_OUTPUT];
     struct vkd3d_shader_dst_param *output_dcl_params[MAX_REG_OUTPUT];
     struct vkd3d_shader_dst_param *pc_dcl_params[MAX_REG_OUTPUT];
-    uint8_t input_range_map[MAX_REG_OUTPUT][VKD3D_VEC4_SIZE];
-    uint8_t output_range_map[MAX_REG_OUTPUT][VKD3D_VEC4_SIZE];
-    uint8_t pc_range_map[MAX_REG_OUTPUT][VKD3D_VEC4_SIZE];
+    struct io_normaliser_register_data input_range_map[MAX_REG_OUTPUT];
+    struct io_normaliser_register_data output_range_map[MAX_REG_OUTPUT];
+    struct io_normaliser_register_data pc_range_map[MAX_REG_OUTPUT];
 
     bool use_vocp;
 };
@@ -1794,36 +1806,44 @@ struct signature_element *vsir_signature_find_element_for_reg(const struct shade
     return NULL;
 }
 
-static unsigned int range_map_get_register_count(uint8_t range_map[][VKD3D_VEC4_SIZE],
+static unsigned int range_map_get_register_count(struct io_normaliser_register_data range_map[],
         unsigned int register_idx, uint32_t write_mask)
 {
-    return range_map[register_idx][vsir_write_mask_get_component_idx(write_mask)];
+    return range_map[register_idx].component[vsir_write_mask_get_component_idx(write_mask)].register_count;
 }
 
-static void range_map_set_register_range(uint8_t range_map[][VKD3D_VEC4_SIZE], unsigned int register_idx,
-        unsigned int register_count, uint32_t write_mask, bool is_dcl_indexrange)
+static enum vkd3d_result range_map_set_register_range(struct io_normaliser *normaliser,
+        struct io_normaliser_register_data range_map[], unsigned int register_idx,
+        unsigned int register_count, uint32_t mask, uint32_t used_mask, bool is_dcl_indexrange)
 {
     unsigned int i, j, r, c, component_idx, component_count;
 
-    VKD3D_ASSERT(write_mask <= VKD3DSP_WRITEMASK_ALL);
-    component_idx = vsir_write_mask_get_component_idx(write_mask);
-    component_count = vsir_write_mask_component_count(write_mask);
+    VKD3D_ASSERT(mask <= VKD3DSP_WRITEMASK_ALL);
+    component_idx = vsir_write_mask_get_component_idx(mask);
+    component_count = vsir_write_mask_component_count(mask);
 
     VKD3D_ASSERT(register_idx < MAX_REG_OUTPUT && MAX_REG_OUTPUT - register_idx >= register_count);
 
-    if (range_map[register_idx][component_idx] > register_count && is_dcl_indexrange)
+    if (range_map[register_idx].component[component_idx].register_count > register_count && is_dcl_indexrange)
     {
-        /* Validated in the TPF reader. */
-        VKD3D_ASSERT(range_map[register_idx][component_idx] != UINT8_MAX);
-        return;
+        if (range_map[register_idx].component[component_idx].register_count == UINT8_MAX)
+        {
+            WARN("Conflicting index ranges.\n");
+            vkd3d_shader_error(normaliser->message_context, NULL,
+                    VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE, "Conflicting index ranges.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+        return VKD3D_OK;
     }
-    if (range_map[register_idx][component_idx] == register_count)
+    if (range_map[register_idx].component[component_idx].register_count == register_count)
     {
         /* Already done. This happens when fxc splits a register declaration by
          * component(s). The dcl_indexrange instructions are split too. */
-        return;
+        return VKD3D_OK;
     }
-    range_map[register_idx][component_idx] = register_count;
+    range_map[register_idx].component[component_idx].register_count = register_count;
+    range_map[register_idx].component[component_idx].mask = mask;
+    range_map[register_idx].component[component_idx].used_mask = used_mask;
 
     for (i = 0; i < register_count; ++i)
     {
@@ -1834,21 +1854,31 @@ static void range_map_set_register_range(uint8_t range_map[][VKD3D_VEC4_SIZE], u
             /* A synthetic patch constant range which overlaps an existing range can start upstream of it
              * for fork/join phase instancing, but ranges declared by dcl_indexrange should not overlap.
              * The latter is validated in the TPF reader. */
-            VKD3D_ASSERT(!range_map[r][c] || !is_dcl_indexrange);
-            range_map[r][c] = UINT8_MAX;
+            if (range_map[r].component[c].register_count && is_dcl_indexrange)
+            {
+                WARN("Conflicting index ranges.\n");
+                vkd3d_shader_error(normaliser->message_context, NULL,
+                        VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE, "Conflicting index ranges.");
+                return VKD3D_ERROR_INVALID_SHADER;
+            }
+            range_map[r].component[c].register_count = UINT8_MAX;
+            range_map[r].component[c].mask = mask;
+            range_map[r].component[c].used_mask = used_mask;
         }
     }
+
+    return VKD3D_OK;
 }
 
-static void io_normaliser_add_index_range(struct io_normaliser *normaliser,
+static enum vkd3d_result io_normaliser_add_index_range(struct io_normaliser *normaliser,
         const struct vkd3d_shader_instruction *ins)
 {
     const struct vkd3d_shader_index_range *range = &ins->declaration.index_range;
     const struct vkd3d_shader_register *reg = &range->dst.reg;
+    struct io_normaliser_register_data *range_map;
     const struct shader_signature *signature;
-    uint8_t (*range_map)[VKD3D_VEC4_SIZE];
-    struct signature_element *element;
-    unsigned int reg_idx, write_mask;
+    uint32_t mask, used_mask;
+    unsigned int reg_idx, i;
 
     switch (reg->type)
     {
@@ -1879,9 +1909,21 @@ static void io_normaliser_add_index_range(struct io_normaliser *normaliser,
     }
 
     reg_idx = reg->idx[reg->idx_count - 1].offset;
-    write_mask = range->dst.write_mask;
-    element = vsir_signature_find_element_for_reg(signature, reg_idx, write_mask);
-    range_map_set_register_range(range_map, reg_idx, range->register_count, element->mask, true);
+    mask = range->dst.write_mask;
+    used_mask = 0;
+
+    for (i = 0; i < range->register_count; ++i)
+    {
+        struct signature_element *element;
+
+        if ((element = vsir_signature_find_element_for_reg(signature, reg_idx + i, mask)))
+        {
+            mask |= element->mask;
+            used_mask |= element->used_mask;
+        }
+    }
+
+    return range_map_set_register_range(normaliser, range_map, reg_idx, range->register_count, mask, used_mask, true);
 }
 
 static int signature_element_mask_compare(const void *a, const void *b)
@@ -1908,11 +1950,12 @@ static bool sysval_semantics_should_merge(const struct signature_element *e, con
 }
 
 /* Merge tess factor sysvals because they are an array in SPIR-V. */
-static void shader_signature_map_patch_constant_index_ranges(struct shader_signature *s,
-        uint8_t range_map[][VKD3D_VEC4_SIZE])
+static enum vkd3d_result shader_signature_map_patch_constant_index_ranges(struct io_normaliser *normaliser,
+        struct shader_signature *s, struct io_normaliser_register_data range_map[])
 {
-    struct signature_element *e, *f;
     unsigned int i, j, register_count;
+    struct signature_element *e, *f;
+    enum vkd3d_result ret;
 
     qsort(s->elements, s->element_count, sizeof(s->elements[0]), signature_element_mask_compare);
 
@@ -1933,8 +1976,12 @@ static void shader_signature_map_patch_constant_index_ranges(struct shader_signa
         if (register_count < 2)
             continue;
 
-        range_map_set_register_range(range_map, e->register_index, register_count, e->mask, false);
+        if ((ret = range_map_set_register_range(normaliser, range_map,
+                e->register_index, register_count, e->mask, e->used_mask, false) < 0))
+            return ret;
     }
+
+    return VKD3D_OK;
 }
 
 static int signature_element_register_compare(const void *a, const void *b)
@@ -1977,62 +2024,19 @@ static int signature_element_index_compare(const void *a, const void *b)
     return vkd3d_u32_compare(e->sort_index, f->sort_index);
 }
 
-static unsigned int signature_element_range_expand_mask(struct signature_element *e, unsigned int register_count,
-        uint8_t range_map[][VKD3D_VEC4_SIZE])
-{
-    unsigned int i, j, component_idx, component_count, merged_write_mask = e->mask;
-
-    /* dcl_indexrange instructions can declare a subset of the full mask, and the masks of
-     * the elements within the range may differ. TPF's handling of arrayed inputs with
-     * dcl_indexrange is really just a hack. Here we create a mask which covers all element
-     * masks, and check for collisions with other ranges. */
-
-    for (i = 1; i < register_count; ++i)
-        merged_write_mask |= e[i].mask;
-
-    if (merged_write_mask == e->mask)
-        return merged_write_mask;
-
-    /* Reaching this point is very rare to begin with, and collisions are even rarer or
-     * impossible. If the latter shows up, the fallback in shader_signature_find_element_for_reg()
-     * may be sufficient. */
-
-    component_idx = vsir_write_mask_get_component_idx(e->mask);
-    component_count = vsir_write_mask_component_count(e->mask);
-
-    for (i = e->register_index; i < e->register_index + register_count; ++i)
-    {
-        for (j = 0; j < component_idx; ++j)
-            if (range_map[i][j])
-                break;
-        for (j = component_idx + component_count; j < VKD3D_VEC4_SIZE; ++j)
-            if (range_map[i][j])
-                break;
-    }
-
-    if (i == register_count)
-    {
-        WARN("Expanding mask %#x to %#x for %s, base reg %u, count %u.\n", e->mask, merged_write_mask,
-                e->semantic_name, e->register_index, register_count);
-        return merged_write_mask;
-    }
-
-    WARN("Cannot expand mask %#x to %#x for %s, base reg %u, count %u.\n", e->mask, merged_write_mask,
-            e->semantic_name, e->register_index, register_count);
-    return e->mask;
-}
-
-static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map[][VKD3D_VEC4_SIZE],
+static enum vkd3d_result shader_signature_merge(struct io_normaliser *normaliser,
+        struct shader_signature *s, struct io_normaliser_register_data range_map[],
         bool is_patch_constant)
 {
     unsigned int i, j, element_count, new_count, register_count;
     struct signature_element *elements;
+    enum vkd3d_result ret = VKD3D_OK;
     struct signature_element *e, *f;
     bool used;
 
     element_count = s->element_count;
     if (!(elements = vkd3d_malloc(element_count * sizeof(*elements))))
-        return false;
+        return VKD3D_ERROR_OUT_OF_MEMORY;
     if (element_count)
         memcpy(elements, s->elements, element_count * sizeof(*elements));
 
@@ -2091,42 +2095,49 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
     s->elements = elements;
     s->element_count = element_count;
 
-    if (is_patch_constant)
-        shader_signature_map_patch_constant_index_ranges(s, range_map);
+    if (is_patch_constant
+            && (ret = shader_signature_map_patch_constant_index_ranges(normaliser, s, range_map)) < 0)
+        goto out;
 
-    for (i = 0, new_count = 0; i < element_count; i += register_count, elements[new_count++] = *e)
+    for (i = 0, new_count = 0; i < element_count; ++i)
     {
         e = &elements[i];
         register_count = 1;
 
         if (e->register_index >= MAX_REG_OUTPUT)
+        {
+            elements[new_count++] = *e;
             continue;
+        }
 
         register_count = range_map_get_register_count(range_map, e->register_index, e->mask);
-        VKD3D_ASSERT(register_count != UINT8_MAX);
-        register_count += !register_count;
 
-        if (register_count > 1)
+        if (register_count == UINT8_MAX)
         {
-            TRACE("Merging %s, base reg %u, count %u.\n", e->semantic_name, e->register_index, register_count);
-            e->register_count = register_count;
-            e->mask = signature_element_range_expand_mask(e, register_count, range_map);
+            TRACE("Register %u mask %#x semantic %s%u has already been merged, dropping it.\n",
+                    e->register_index, e->mask, e->semantic_name, e->semantic_index);
+            vkd3d_free((void *)e->semantic_name);
+            continue;
+        }
 
-            for (j = 1; j < register_count; ++j)
-            {
-                f = &elements[i + j];
-                vkd3d_free((void *)f->semantic_name);
-            }
+        if (register_count > 0)
+        {
+            TRACE("Register %u mask %#x semantic %s%u is used as merge destination.\n",
+                    e->register_index, e->mask, e->semantic_name, e->semantic_index);
+            e->register_count = register_count;
+            e->mask = range_map[e->register_index].component[vsir_write_mask_get_component_idx(e->mask)].mask;
+            e->used_mask = range_map[e->register_index].component[vsir_write_mask_get_component_idx(e->mask)].used_mask;
         }
+
+        elements[new_count++] = *e;
     }
-    element_count = new_count;
+    s->element_count = new_count;
 
+out:
     /* Restoring the original order is required for sensible trace output. */
-    qsort(elements, element_count, sizeof(elements[0]), signature_element_index_compare);
-
-    s->element_count = element_count;
+    qsort(s->elements, s->element_count, sizeof(elements[0]), signature_element_index_compare);
 
-    return true;
+    return ret;
 }
 
 static unsigned int shader_register_normalise_arrayed_addressing(struct vkd3d_shader_register *reg,
@@ -2342,8 +2353,9 @@ static void shader_instruction_normalise_io_params(struct vkd3d_shader_instructi
 static enum vkd3d_result vsir_program_normalise_io_registers(struct vsir_program *program,
         struct vsir_transformation_context *ctx)
 {
-    struct io_normaliser normaliser = {program->instructions};
+    struct io_normaliser normaliser = {ctx->message_context, program->instructions};
     struct vkd3d_shader_instruction *ins;
+    enum vkd3d_result ret;
     unsigned int i;
 
     VKD3D_ASSERT(program->normalisation_level == VSIR_NORMALISED_HULL_CONTROL_POINT_IO);
@@ -2365,7 +2377,8 @@ static enum vkd3d_result vsir_program_normalise_io_registers(struct vsir_program
                 normaliser.output_control_point_count = ins->declaration.count;
                 break;
             case VKD3DSIH_DCL_INDEX_RANGE:
-                io_normaliser_add_index_range(&normaliser, ins);
+                if ((ret = io_normaliser_add_index_range(&normaliser, ins)) < 0)
+                    return ret;
                 vkd3d_shader_instruction_make_nop(ins);
                 break;
             case VKD3DSIH_HS_CONTROL_POINT_PHASE:
@@ -2378,12 +2391,14 @@ static enum vkd3d_result vsir_program_normalise_io_registers(struct vsir_program
         }
     }
 
-    if (!shader_signature_merge(&program->input_signature, normaliser.input_range_map, false)
-            || !shader_signature_merge(&program->output_signature, normaliser.output_range_map, false)
-            || !shader_signature_merge(&program->patch_constant_signature, normaliser.pc_range_map, true))
+    if ((ret = shader_signature_merge(&normaliser, &program->input_signature, normaliser.input_range_map, false)) < 0
+            || (ret = shader_signature_merge(&normaliser, &program->output_signature,
+                    normaliser.output_range_map, false)) < 0
+            || (ret = shader_signature_merge(&normaliser, &program->patch_constant_signature,
+                    normaliser.pc_range_map, true)) < 0)
     {
         program->instructions = normaliser.instructions;
-        return VKD3D_ERROR_OUT_OF_MEMORY;
+        return ret;
     }
 
     normaliser.phase = VKD3DSIH_INVALID;
@@ -8505,10 +8520,13 @@ static void vsir_validate_signature_element(struct validation_context *ctx,
     {
         case VKD3D_SHADER_COMPONENT_INT:
         case VKD3D_SHADER_COMPONENT_UINT:
+        case VKD3D_SHADER_COMPONENT_INT16:
+        case VKD3D_SHADER_COMPONENT_UINT16:
             integer_type = true;
             break;
 
         case VKD3D_SHADER_COMPONENT_FLOAT:
+        case VKD3D_SHADER_COMPONENT_FLOAT16:
             break;
 
         default:
diff --git a/libs/vkd3d/libs/vkd3d-shader/preproc.l b/libs/vkd3d/libs/vkd3d-shader/preproc.l
index 4a8d0fddae1..d167415c356 100644
--- a/libs/vkd3d/libs/vkd3d-shader/preproc.l
+++ b/libs/vkd3d/libs/vkd3d-shader/preproc.l
@@ -20,6 +20,7 @@
 
 %{
 
+#include "preproc.h"
 #include "preproc.tab.h"
 
 #undef ERROR  /* defined in wingdi.h */
diff --git a/libs/vkd3d/libs/vkd3d-shader/preproc.y b/libs/vkd3d/libs/vkd3d-shader/preproc.y
index c6be17bd230..95987831faa 100644
--- a/libs/vkd3d/libs/vkd3d-shader/preproc.y
+++ b/libs/vkd3d/libs/vkd3d-shader/preproc.y
@@ -178,6 +178,16 @@ static int default_open_include(const char *filename, bool local,
     if (S_ISREG(st.st_mode))
         size = st.st_size;
 
+    if (!size)
+    {
+        fclose(f);
+
+        out->code = NULL;
+        out->size = 0;
+
+        return VKD3D_OK;
+    }
+
     if (!(data = vkd3d_malloc(size)))
     {
         fclose(f);
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index db7ebab742d..66a4a274f17 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -18,6 +18,7 @@
  */
 
 #include "vkd3d_shader_private.h"
+#include "spirv_grammar.h"
 #include "wine/rbtree.h"
 
 #include <stdarg.h>
@@ -60,6 +61,8 @@
 #define VKD3D_SPIRV_INSTRUCTION_OP_SHIFT            0u
 #define VKD3D_SPIRV_INSTRUCTION_OP_MASK             (0xffffu << VKD3D_SPIRV_INSTRUCTION_OP_SHIFT)
 
+#define VKD3D_SPIRV_INDENT 15
+
 #ifdef HAVE_SPIRV_TOOLS
 # include "spirv-tools/libspirv.h"
 
@@ -211,6 +214,10 @@ struct spirv_colours
 {
     const char *reset;
     const char *comment;
+    const char *literal;
+    const char *enumerant;
+    const char *opcode;
+    const char *id;
 };
 
 struct spirv_parser
@@ -240,6 +247,16 @@ static void VKD3D_PRINTF_FUNC(3, 4) spirv_parser_error(struct spirv_parser *pars
     parser->failed = true;
 }
 
+static void VKD3D_PRINTF_FUNC(3, 4) spirv_parser_warning(struct spirv_parser *parser,
+        enum vkd3d_shader_error error, const char *format, ...)
+{
+    va_list args;
+
+    va_start(args, format);
+    vkd3d_shader_vwarning(parser->message_context, &parser->location, error, format, args);
+    va_end(args);
+}
+
 static uint32_t spirv_parser_read_u32(struct spirv_parser *parser)
 {
     if (parser->pos >= parser->size)
@@ -290,6 +307,128 @@ static void spirv_parser_print_generator(struct spirv_parser *parser, uint32_t m
         spirv_parser_print_comment(parser, "Generator: Unknown (%#x); %u", id, version);
 }
 
+static void spirv_parser_print_immediate_word(struct spirv_parser *parser,
+        struct vkd3d_string_buffer *buffer, const char *prefix, uint32_t w, const char *suffix)
+{
+    vkd3d_string_buffer_printf(buffer, "%s!%s0x%08x%s%s",
+            prefix, parser->colours.literal, w, parser->colours.reset, suffix);
+}
+
+static void spirv_parser_print_id(struct spirv_parser *parser,
+        struct vkd3d_string_buffer *buffer, const char *prefix, uint32_t id, const char *suffix)
+{
+    vkd3d_string_buffer_printf(buffer, "%s%%%s%u%s%s",
+            prefix, parser->colours.id, id, parser->colours.reset, suffix);
+}
+
+static void spirv_parser_print_uint_literal(struct spirv_parser *parser,
+        struct vkd3d_string_buffer *buffer, const char *prefix, uint32_t i, const char *suffix)
+{
+    vkd3d_string_buffer_printf(buffer, "%s%s%u%s%s",
+            prefix, parser->colours.literal, i, parser->colours.reset, suffix);
+}
+
+static void spirv_parser_print_enumerant(struct spirv_parser *parser,
+        struct vkd3d_string_buffer *buffer, const char *prefix, const char *name, const char *suffix)
+{
+    vkd3d_string_buffer_printf(buffer, "%s%s%s%s%s",
+            prefix, parser->colours.enumerant, name, parser->colours.reset, suffix);
+}
+
+static void spirv_parser_print_opcode(struct spirv_parser *parser,
+        struct vkd3d_string_buffer *buffer, const char *name)
+{
+    vkd3d_string_buffer_printf(buffer, "%s%s%s", parser->colours.opcode, name, parser->colours.reset);
+}
+
+static void spirv_parser_print_instruction_offset(struct spirv_parser *parser,
+        struct vkd3d_string_buffer *buffer, const char *prefix, size_t offset, const char *suffix)
+{
+    vkd3d_string_buffer_printf(parser->text, "%s%s; 0x%08zx%s%s", prefix,
+            parser->colours.comment, offset * sizeof(uint32_t), parser->colours.reset, suffix);
+}
+
+static char get_escape_char(char c)
+{
+    switch (c)
+    {
+        case '"':
+        case '\\':
+            return c;
+        case '\t':
+            return 't';
+        case '\n':
+            return 'n';
+        case '\v':
+            return 'v';
+        case '\f':
+            return 'f';
+        case '\r':
+            return 'r';
+        default:
+            return 0;
+    }
+}
+
+static void spirv_parser_print_string_literal(struct spirv_parser *parser, struct vkd3d_string_buffer *buffer,
+        const char *prefix, const char *s, size_t len, const char *suffix)
+{
+    size_t start, i;
+    char c;
+
+    vkd3d_string_buffer_printf(buffer, "%s\"%s", prefix, parser->colours.literal);
+    for (i = 0, start = 0; i < len; ++i)
+    {
+        if ((c = get_escape_char(s[i])))
+        {
+            vkd3d_string_buffer_printf(buffer, "%.*s\\%c", (int)(i - start), &s[start], c);
+            start = i + 1;
+        }
+        else if (!isprint(s[i]))
+        {
+            vkd3d_string_buffer_printf(buffer, "%.*s\\%03o", (int)(i - start), &s[start], (uint8_t)s[i]);
+            start = i + 1;
+        }
+    }
+    vkd3d_string_buffer_printf(buffer, "%.*s%s\"%s", (int)(len - start), &s[start], parser->colours.reset, suffix);
+}
+
+static const struct spirv_parser_enumerant *spirv_parser_get_enumerant(
+        const struct spirv_parser_operand_type_info *info, uint32_t value)
+{
+    const struct spirv_parser_enumerant *e;
+    size_t i;
+
+    for (i = 0; i < info->enumerant_count; ++i)
+    {
+        if ((e = &info->enumerants[i])->value == value)
+            return e;
+    }
+
+    return NULL;
+}
+
+static const struct spirv_parser_operand_type_info *spirv_parser_get_operand_type_info(enum spirv_parser_operand_type t)
+{
+    if (t >= ARRAY_SIZE(spirv_parser_operand_type_info))
+        return NULL;
+    return &spirv_parser_operand_type_info[t];
+}
+
+static int spirv_parser_opcode_info_compare(const void *key, const void *element)
+{
+    const struct spirv_parser_opcode_info *e = element;
+    const uint16_t *op = key;
+
+    return vkd3d_u32_compare(*op, e->op);
+}
+
+static const struct spirv_parser_opcode_info *spirv_parser_get_opcode_info(uint16_t op)
+{
+    return bsearch(&op, spirv_parser_opcode_info, ARRAY_SIZE(spirv_parser_opcode_info),
+            sizeof(*spirv_parser_opcode_info), spirv_parser_opcode_info_compare);
+}
+
 static enum vkd3d_result spirv_parser_read_header(struct spirv_parser *parser)
 {
     uint32_t magic, version, generator, bound, schema;
@@ -357,36 +496,260 @@ static enum vkd3d_result spirv_parser_read_header(struct spirv_parser *parser)
     return VKD3D_OK;
 }
 
+static bool spirv_parser_parse_string_literal(struct spirv_parser *parser,
+        struct vkd3d_string_buffer *buffer, size_t end)
+{
+    const char *s = (const char *)&parser->code[parser->pos];
+    size_t len, max_len;
+
+    max_len = (end - parser->pos) * sizeof(uint32_t);
+    len = strnlen(s, max_len);
+    if (len == max_len)
+    {
+        spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                "Insufficient words remaining while parsing string literal.");
+        return false;
+    }
+
+    spirv_parser_print_string_literal(parser, buffer, " ", s, len, "");
+    parser->pos += (len / sizeof(uint32_t)) + 1;
+
+    return true;
+}
+
+static uint32_t lowest_set(uint32_t v)
+{
+    return v & -v;
+}
+
+static bool spirv_parser_parse_operand(struct spirv_parser *parser, struct vkd3d_string_buffer *buffer,
+        const char *opcode_name, enum spirv_parser_operand_type type, size_t end, uint32_t *result_id)
+{
+    const struct spirv_parser_operand_type_info *info;
+    const struct spirv_parser_enumerant *e;
+    uint32_t word, tmp, v, i, j;
+
+    if (parser->pos >= end)
+    {
+        spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                "Insufficient words remaining while parsing operands for instruction \"%s\".", opcode_name);
+        return false;
+    }
+
+    if (!(info = spirv_parser_get_operand_type_info(type)))
+    {
+        ERR("Invalid operand type %#x.\n", type);
+        return false;
+    }
+
+    if (info->category == SPIRV_PARSER_OPERAND_CATEGORY_BIT_ENUM)
+    {
+        if (!(word = spirv_parser_read_u32(parser)))
+        {
+            if (!(e = spirv_parser_get_enumerant(info, word)))
+            {
+                spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                        "Unhandled enumeration value %#x.", word);
+                return false;
+            }
+            spirv_parser_print_enumerant(parser, buffer, " ", e->name, "");
+
+            for (j = 0; j < e->parameter_count; ++j)
+            {
+                if (!spirv_parser_parse_operand(parser, buffer, opcode_name, e->parameters[j], end, result_id))
+                    return false;
+            }
+
+            return true;
+        }
+
+        for (i = 0, tmp = word; tmp; ++i, tmp ^= v)
+        {
+            v = lowest_set(tmp);
+            if (!(e = spirv_parser_get_enumerant(info, v)))
+            {
+                spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                        "Unhandled enumeration value %#x.", v);
+                return false;
+            }
+            spirv_parser_print_enumerant(parser, buffer, i ? " | " : " ", e->name, "");
+        }
+
+        for (i = 0, tmp = word; tmp; ++i, tmp ^= v)
+        {
+            v = lowest_set(tmp);
+            if (!(e = spirv_parser_get_enumerant(info, v)))
+            {
+                spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                        "Unhandled enumeration value %#x.", v);
+                return false;
+            }
+
+            for (j = 0; j < e->parameter_count; ++j)
+            {
+                if (!spirv_parser_parse_operand(parser, buffer, opcode_name, e->parameters[j], end, result_id))
+                    return false;
+            }
+        }
+
+        return true;
+    }
+
+    if (info->category == SPIRV_PARSER_OPERAND_CATEGORY_VALUE_ENUM)
+    {
+        word = spirv_parser_read_u32(parser);
+        if (!(e = spirv_parser_get_enumerant(info, word)))
+        {
+            spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                    "Unhandled \"%s\" enumeration value %#x.", info->name, word);
+            return false;
+        }
+        spirv_parser_print_enumerant(parser, buffer, " ", e->name, "");
+
+        for (i = 0; i < e->parameter_count; ++i)
+        {
+            if (!spirv_parser_parse_operand(parser, buffer, opcode_name, e->parameters[i], end, result_id))
+                return false;
+        }
+
+        return true;
+    }
+
+    switch (type)
+    {
+        case SPIRV_PARSER_OPERAND_TYPE_ID_REF:
+        case SPIRV_PARSER_OPERAND_TYPE_ID_RESULT_TYPE:
+            spirv_parser_print_id(parser, buffer, " ", spirv_parser_read_u32(parser), "");
+            return true;
+
+        case SPIRV_PARSER_OPERAND_TYPE_ID_RESULT:
+            if (*result_id)
+            {
+                spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                        "Instruction has multiple results.");
+                return false;
+            }
+            *result_id = spirv_parser_read_u32(parser);
+            return true;
+
+        case SPIRV_PARSER_OPERAND_TYPE_LITERAL_INTEGER:
+            spirv_parser_print_uint_literal(parser, buffer, " ", spirv_parser_read_u32(parser), "");
+            return true;
+
+        case SPIRV_PARSER_OPERAND_TYPE_LITERAL_STRING:
+            return spirv_parser_parse_string_literal(parser, buffer, end);
+
+        default:
+            spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                    "Unhandled operand type \"%s\".", info->name);
+            return false;
+    }
+}
+
+static void spirv_parser_parse_raw_instruction(struct spirv_parser *parser, uint16_t count)
+{
+    size_t pos = parser->pos;
+    size_t i;
+
+    if (parser->formatting & VKD3D_SHADER_COMPILE_OPTION_FORMATTING_INDENT)
+        vkd3d_string_buffer_printf(parser->text, "%*s", VKD3D_SPIRV_INDENT, "");
+    for (i = 0; i < count; ++i)
+    {
+        spirv_parser_print_immediate_word(parser, parser->text, i ? " " : "", spirv_parser_read_u32(parser), "");
+    }
+    if (parser->formatting & VKD3D_SHADER_COMPILE_OPTION_FORMATTING_OFFSETS)
+        spirv_parser_print_instruction_offset(parser, parser->text, " ", pos, "");
+    vkd3d_string_buffer_printf(parser->text, "\n");
+}
+
 static enum vkd3d_result spirv_parser_parse_instruction(struct spirv_parser *parser)
 {
-    struct vkd3d_string_buffer *buffer;
-    uint16_t op, count;
-    unsigned int i;
-    uint32_t word;
+    const struct spirv_parser_instruction_operand *operand;
+    struct vkd3d_string_buffer *operands, *result_name;
+    const struct spirv_parser_opcode_info *info;
+    uint32_t result_id, word;
+    uint16_t op, count, rem;
+    size_t end, pos, i;
 
+    pos = parser->pos;
     word = spirv_parser_read_u32(parser);
     count = (word & VKD3D_SPIRV_INSTRUCTION_WORD_COUNT_MASK) >> VKD3D_SPIRV_INSTRUCTION_WORD_COUNT_SHIFT;
     op = (word & VKD3D_SPIRV_INSTRUCTION_OP_MASK) >> VKD3D_SPIRV_INSTRUCTION_OP_SHIFT;
 
-    if (!count)
+    if (!count || count > parser->size - pos)
     {
         spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
                 "Invalid word count %u.", count);
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    --count;
-    buffer = vkd3d_string_buffer_get(&parser->string_buffers);
-    for (i = 0; i < count; ++i)
+    if (!(info = spirv_parser_get_opcode_info(op)))
     {
-        word = spirv_parser_read_u32(parser);
-        vkd3d_string_buffer_printf(buffer, " 0x%08x", word);
+        spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                "Unrecognised instruction %#x.", op);
+        goto raw;
+    }
+
+    operands = vkd3d_string_buffer_get(&parser->string_buffers);
+
+    result_id = 0;
+    for (i = 0, end = pos + count; i < info->operand_count; ++i)
+    {
+        operand = &info->operands[i];
+
+        do
+        {
+            if (parser->pos >= end && (operand->quantifier == '?' || operand->quantifier == '*'))
+                break;
+
+            if (!spirv_parser_parse_operand(parser, operands, info->name, operand->type, end, &result_id))
+            {
+                vkd3d_string_buffer_release(&parser->string_buffers, operands);
+                goto raw;
+            }
+        } while (operand->quantifier == '*' && parser->pos < end);
     }
-    spirv_parser_print_comment(parser, "<unrecognised instruction %#x>%s", op, buffer->buffer);
-    vkd3d_string_buffer_release(&parser->string_buffers, buffer);
 
-    spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
-            "Unrecognised instruction %#x.", op);
+    if ((rem = end - parser->pos))
+    {
+        spirv_parser_warning(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                "%u word(s) remaining after parsing all operands for instruction \"%s\"", rem, info->name);
+        for (i = 0; i < rem; ++i)
+        {
+            spirv_parser_print_immediate_word(parser, operands, " ", spirv_parser_read_u32(parser), "");
+        }
+    }
+
+    if (result_id)
+    {
+        int max_indent = 0;
+
+        if (parser->formatting & VKD3D_SHADER_COMPILE_OPTION_FORMATTING_INDENT)
+            max_indent = VKD3D_SPIRV_INDENT - 4;
+        result_name = vkd3d_string_buffer_get(&parser->string_buffers);
+        vkd3d_string_buffer_printf(result_name, "%u", result_id);
+        vkd3d_string_buffer_printf(parser->text, "%*s%%%s%s%s = ",
+                result_name->content_size > max_indent ? 0 : max_indent - (int)result_name->content_size, "",
+                parser->colours.id, result_name->buffer, parser->colours.reset);
+        vkd3d_string_buffer_release(&parser->string_buffers, result_name);
+    }
+    else if (parser->formatting & VKD3D_SHADER_COMPILE_OPTION_FORMATTING_INDENT)
+    {
+        vkd3d_string_buffer_printf(parser->text, "%*s", VKD3D_SPIRV_INDENT, "");
+    }
+    spirv_parser_print_opcode(parser, parser->text, info->name);
+    vkd3d_string_buffer_printf(parser->text, "%s", operands->buffer);
+    if (parser->formatting & VKD3D_SHADER_COMPILE_OPTION_FORMATTING_OFFSETS)
+        spirv_parser_print_instruction_offset(parser, parser->text, " ", pos, "");
+    vkd3d_string_buffer_printf(parser->text, "\n");
+
+    vkd3d_string_buffer_release(&parser->string_buffers, operands);
+
+    return VKD3D_OK;
+
+raw:
+    parser->pos = pos;
+    spirv_parser_parse_raw_instruction(parser, count);
 
     return VKD3D_OK;
 }
@@ -441,11 +804,19 @@ static enum vkd3d_result spirv_parser_init(struct spirv_parser *parser, const st
     {
         .reset = "",
         .comment = "",
+        .literal = "",
+        .enumerant = "",
+        .opcode = "",
+        .id = "",
     };
     static const struct spirv_colours colours =
     {
         .reset = "\x1b[m",
         .comment = "\x1b[36m",
+        .literal = "\x1b[95m",
+        .enumerant = "\x1b[93m",
+        .opcode = "\x1b[96;1m",
+        .id = "\x1b[96m",
     };
 
     memset(parser, 0, sizeof(*parser));
@@ -829,16 +1200,16 @@ static unsigned int vkd3d_spirv_string_word_count(const char *str)
 static void vkd3d_spirv_build_string(struct vkd3d_spirv_stream *stream,
         const char *str, unsigned int word_count)
 {
-    unsigned int word_idx, i;
-    const char *ptr = str;
+    uint32_t *ptr;
 
-    for (word_idx = 0; word_idx < word_count; ++word_idx)
-    {
-        uint32_t word = 0;
-        for (i = 0; i < sizeof(uint32_t) && *ptr; ++i)
-            word |= (uint32_t)*ptr++ << (8 * i);
-        vkd3d_spirv_build_word(stream, word);
-    }
+    if (!vkd3d_array_reserve((void **)&stream->words, &stream->capacity,
+            stream->word_count + word_count, sizeof(*stream->words)))
+        return;
+
+    ptr = &stream->words[stream->word_count];
+    ptr[word_count - 1] = 0;
+    memcpy(ptr, str, strlen(str));
+    stream->word_count += word_count;
 }
 
 typedef uint32_t (*vkd3d_spirv_build_pfn)(struct vkd3d_spirv_builder *builder);
@@ -3375,7 +3746,8 @@ static uint32_t spirv_compiler_get_constant(struct spirv_compiler *compiler,
                     "Vectors of bool type are not supported.");
             return vkd3d_spirv_get_op_undef(builder, type_id);
         default:
-            FIXME("Unhandled component_type %#x.\n", component_type);
+            spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_INVALID_TYPE,
+                    "Unhandled component_type %#x.", component_type);
             return vkd3d_spirv_get_op_undef(builder, type_id);
     }
 
@@ -6904,6 +7276,13 @@ static void spirv_compiler_emit_workgroup_memory(struct spirv_compiler *compiler
     const SpvStorageClass storage_class = SpvStorageClassWorkgroup;
     struct vkd3d_symbol reg_symbol;
 
+    if (zero_init && !(compiler->features & VKD3D_SHADER_COMPILE_OPTION_FEATURE_ZERO_INITIALIZE_WORKGROUP_MEMORY))
+    {
+        WARN("Unsupported zero-initialized workgroup memory.\n");
+        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_UNSUPPORTED_FEATURE,
+                "The target environment does not support zero-initialized workgroup memory.");
+    }
+
     /* Alignment is supported only in the Kernel execution model. */
     if (alignment)
         TRACE("Ignoring alignment %u.\n", alignment);
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index 82302aac666..267f0884d83 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -1051,7 +1051,8 @@ static void shader_sm4_read_dcl_index_range(struct vkd3d_shader_instruction *ins
                     register_idx, register_count, write_mask, e->sysval_semantic);
             return;
         }
-        if ((io_masks[register_idx + i] & write_mask) != write_mask)
+        if ((io_masks[register_idx + i] & write_mask) != write_mask
+                && (io_masks[register_idx + i] & write_mask) != 0)
         {
             WARN("No matching declaration for index range base %u, count %u, mask %#x.\n",
                     register_idx, register_count, write_mask);
@@ -3228,6 +3229,7 @@ static int signature_element_pointer_compare(const void *x, const void *y)
 
 static void tpf_write_signature(struct tpf_compiler *tpf, const struct shader_signature *signature, uint32_t tag)
 {
+    bool has_minimum_precision = tpf->program->global_flags & VKD3DSGF_ENABLE_MINIMUM_PRECISION;
     bool output = tag == TAG_OSGN || (tag == TAG_PCSG
             && tpf->program->shader_version.type == VKD3D_SHADER_TYPE_HULL);
     const struct signature_element **sorted_elements;
@@ -3256,12 +3258,16 @@ static void tpf_write_signature(struct tpf_compiler *tpf, const struct shader_si
         if (sysval >= VKD3D_SHADER_SV_TARGET)
             sysval = VKD3D_SHADER_SV_NONE;
 
+        if (has_minimum_precision)
+            put_u32(&buffer, 0); /* FIXME: stream index */
         put_u32(&buffer, 0); /* name */
         put_u32(&buffer, element->semantic_index);
         put_u32(&buffer, sysval);
         put_u32(&buffer, element->component_type);
         put_u32(&buffer, element->register_index);
         put_u32(&buffer, vkd3d_make_u16(element->mask, used_mask));
+        if (has_minimum_precision)
+            put_u32(&buffer, element->min_precision);
     }
 
     for (i = 0; i < signature->element_count; ++i)
@@ -3270,9 +3276,21 @@ static void tpf_write_signature(struct tpf_compiler *tpf, const struct shader_si
         size_t string_offset;
 
         string_offset = put_string(&buffer, element->semantic_name);
-        set_u32(&buffer, (2 + i * 6) * sizeof(uint32_t), string_offset);
+        if (has_minimum_precision)
+            set_u32(&buffer, (2 + i * 8 + 1) * sizeof(uint32_t), string_offset);
+        else
+            set_u32(&buffer, (2 + i * 6) * sizeof(uint32_t), string_offset);
     }
 
+    if (has_minimum_precision)
+    {
+        if (tag == TAG_ISGN)
+            tag = TAG_ISG1;
+        else if (tag == TAG_OSGN || tag == TAG_OSG5)
+            tag = TAG_OSG1;
+        else if (tag == TAG_PCSG)
+            tag = TAG_PSG1;
+    }
     add_section(tpf, tag, &buffer);
     vkd3d_free(sorted_elements);
 }
@@ -4233,6 +4251,9 @@ static void tpf_write_sfi0(struct tpf_compiler *tpf)
     if (tpf->program->features.rovs)
         *flags |= DXBC_SFI0_REQUIRES_ROVS;
 
+    if (tpf->program->global_flags & VKD3DSGF_ENABLE_MINIMUM_PRECISION)
+        *flags |= DXBC_SFI0_REQUIRES_MINIMUM_PRECISION;
+
     /* FIXME: We also emit code that should require UAVS_AT_EVERY_STAGE,
      * STENCIL_REF, and TYPED_UAV_LOAD_ADDITIONAL_FORMATS. */
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index 021691bb3a1..c990b496545 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -23,6 +23,8 @@
 #include <stdio.h>
 #include <math.h>
 
+/* VKD3D_DEBUG_ENV_NAME("VKD3D_SHADER_DEBUG"); */
+
 static inline int char_to_int(char c)
 {
     if ('0' <= c && c <= '9')
@@ -454,8 +456,15 @@ struct shader_dump_data
     const char *target_suffix;
 };
 
+enum shader_dump_type
+{
+    SHADER_DUMP_TYPE_SOURCE,
+    SHADER_DUMP_TYPE_PREPROC,
+    SHADER_DUMP_TYPE_TARGET,
+};
+
 static void vkd3d_shader_dump_shader(const struct shader_dump_data *dump_data,
-        const void *data, size_t size, bool source)
+        const void *data, size_t size, enum shader_dump_type type)
 {
     static const char hexadecimal_digits[] = "0123456789abcdef";
     const uint8_t *checksum = dump_data->checksum;
@@ -480,8 +489,10 @@ static void vkd3d_shader_dump_shader(const struct shader_dump_data *dump_data,
     if (dump_data->profile)
         pos += snprintf(filename + pos, ARRAY_SIZE(filename) - pos, "-%s", dump_data->profile);
 
-    if (source)
+    if (type == SHADER_DUMP_TYPE_SOURCE)
         pos += snprintf(filename + pos, ARRAY_SIZE(filename) - pos, "-source.%s", dump_data->source_suffix);
+    else if (type == SHADER_DUMP_TYPE_PREPROC)
+        pos += snprintf(filename + pos, ARRAY_SIZE(filename) - pos, "-preproc.%s", dump_data->source_suffix);
     else
         pos += snprintf(filename + pos, ARRAY_SIZE(filename) - pos, "-target.%s", dump_data->target_suffix);
 
@@ -737,12 +748,20 @@ void vkd3d_shader_free_messages(char *messages)
 static bool vkd3d_shader_signature_from_shader_signature(struct vkd3d_shader_signature *signature,
         const struct shader_signature *src)
 {
-    unsigned int i;
+    struct vkd3d_shader_signature_element *d;
+    const struct signature_element *e;
+    size_t count, i, j;
+
+    for (i = 0, count = 0; i < src->element_count; ++i)
+    {
+        e = &src->elements[i];
+        count += e->register_count;
+    }
 
-    signature->element_count = src->element_count;
+    signature->element_count = count;
     if (!src->elements)
     {
-        VKD3D_ASSERT(!signature->element_count);
+        VKD3D_ASSERT(!count);
         signature->elements = NULL;
         return true;
     }
@@ -750,30 +769,25 @@ static bool vkd3d_shader_signature_from_shader_signature(struct vkd3d_shader_sig
     if (!(signature->elements = vkd3d_calloc(signature->element_count, sizeof(*signature->elements))))
         return false;
 
-    for (i = 0; i < signature->element_count; ++i)
+    for (i = 0, d = signature->elements; i < src->element_count; ++i)
     {
-        struct vkd3d_shader_signature_element *d = &signature->elements[i];
-        struct signature_element *e = &src->elements[i];
-
-        if (!(d->semantic_name = vkd3d_strdup(e->semantic_name)))
+        for (j = 0, e = &src->elements[i]; j < e->register_count; ++j)
         {
-            for (unsigned int j = 0; j < i; ++j)
+            if (!(d->semantic_name = vkd3d_strdup(e->semantic_name)))
             {
-                vkd3d_free((void *)signature->elements[j].semantic_name);
+                vkd3d_shader_free_shader_signature(signature);
+                return false;
             }
-            vkd3d_free(signature->elements);
-            return false;
+            d->semantic_index = e->semantic_index + j;
+            d->stream_index = e->stream_index;
+            d->sysval_semantic = e->sysval_semantic;
+            d->component_type = e->component_type;
+            d->register_index = e->register_index + j;
+            d->mask = e->mask;
+            d->used_mask = e->used_mask;
+            d->min_precision = e->min_precision;
+            ++d;
         }
-        d->semantic_index = e->semantic_index;
-        d->stream_index = e->stream_index;
-        d->sysval_semantic = e->sysval_semantic;
-        d->component_type = e->component_type;
-        d->register_index = e->register_index;
-        if (e->register_count > 1)
-            FIXME("Arrayed elements are not supported yet.\n");
-        d->mask = e->mask;
-        d->used_mask = e->used_mask;
-        d->min_precision = e->min_precision;
     }
 
     return true;
@@ -1631,7 +1645,7 @@ int vkd3d_shader_scan(const struct vkd3d_shader_compile_info *compile_info, char
     vkd3d_shader_message_context_init(&message_context, compile_info->log_level);
 
     fill_shader_dump_data(compile_info, &dump_data);
-    vkd3d_shader_dump_shader(&dump_data, compile_info->source.code, compile_info->source.size, true);
+    vkd3d_shader_dump_shader(&dump_data, compile_info->source.code, compile_info->source.size, SHADER_DUMP_TYPE_SOURCE);
 
     if (compile_info->source_type == VKD3D_SHADER_SOURCE_HLSL)
     {
@@ -1711,7 +1725,8 @@ int vsir_program_compile(struct vsir_program *program, uint64_t config_flags,
 }
 
 static int compile_hlsl(const struct vkd3d_shader_compile_info *compile_info,
-        struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context)
+        const struct shader_dump_data *dump_data, struct vkd3d_shader_code *out,
+        struct vkd3d_shader_message_context *message_context)
 {
     struct vkd3d_shader_code preprocessed;
     int ret;
@@ -1719,6 +1734,8 @@ static int compile_hlsl(const struct vkd3d_shader_compile_info *compile_info,
     if ((ret = preproc_lexer_parse(compile_info, &preprocessed, message_context)))
         return ret;
 
+    vkd3d_shader_dump_shader(dump_data, preprocessed.code, preprocessed.size, SHADER_DUMP_TYPE_PREPROC);
+
     ret = hlsl_compile_shader(&preprocessed, compile_info, out, message_context);
 
     vkd3d_shader_free_shader_code(&preprocessed);
@@ -1745,11 +1762,11 @@ int vkd3d_shader_compile(const struct vkd3d_shader_compile_info *compile_info,
     vkd3d_shader_message_context_init(&message_context, compile_info->log_level);
 
     fill_shader_dump_data(compile_info, &dump_data);
-    vkd3d_shader_dump_shader(&dump_data, compile_info->source.code, compile_info->source.size, true);
+    vkd3d_shader_dump_shader(&dump_data, compile_info->source.code, compile_info->source.size, SHADER_DUMP_TYPE_SOURCE);
 
     if (compile_info->source_type == VKD3D_SHADER_SOURCE_HLSL)
     {
-        ret = compile_hlsl(compile_info, out, &message_context);
+        ret = compile_hlsl(compile_info, &dump_data, out, &message_context);
     }
     else if (compile_info->source_type == VKD3D_SHADER_SOURCE_FX)
     {
@@ -1768,7 +1785,7 @@ int vkd3d_shader_compile(const struct vkd3d_shader_compile_info *compile_info,
     }
 
     if (ret >= 0)
-        vkd3d_shader_dump_shader(&dump_data, out->code, out->size, false);
+        vkd3d_shader_dump_shader(&dump_data, out->code, out->size, SHADER_DUMP_TYPE_TARGET);
 
     vkd3d_shader_message_context_trace_messages(&message_context);
     if (!vkd3d_shader_message_context_copy_messages(&message_context, messages))
@@ -1961,9 +1978,7 @@ const enum vkd3d_shader_source_type *vkd3d_shader_get_supported_source_types(uns
         VKD3D_SHADER_SOURCE_DXBC_TPF,
         VKD3D_SHADER_SOURCE_HLSL,
         VKD3D_SHADER_SOURCE_D3D_BYTECODE,
-#ifdef VKD3D_SHADER_UNSUPPORTED_DXIL
         VKD3D_SHADER_SOURCE_DXBC_DXIL,
-#endif
         VKD3D_SHADER_SOURCE_FX,
     };
 
@@ -2012,7 +2027,6 @@ const enum vkd3d_shader_target_type *vkd3d_shader_get_supported_target_types(
         VKD3D_SHADER_TARGET_D3D_ASM,
     };
 
-#ifdef VKD3D_SHADER_UNSUPPORTED_DXIL
     static const enum vkd3d_shader_target_type dxbc_dxil_types[] =
     {
         VKD3D_SHADER_TARGET_SPIRV_BINARY,
@@ -2021,7 +2035,6 @@ const enum vkd3d_shader_target_type *vkd3d_shader_get_supported_target_types(
 # endif
         VKD3D_SHADER_TARGET_D3D_ASM,
     };
-#endif
 
     static const enum vkd3d_shader_target_type fx_types[] =
     {
@@ -2044,11 +2057,9 @@ const enum vkd3d_shader_target_type *vkd3d_shader_get_supported_target_types(
             *count = ARRAY_SIZE(d3dbc_types);
             return d3dbc_types;
 
-#ifdef VKD3D_SHADER_UNSUPPORTED_DXIL
         case VKD3D_SHADER_SOURCE_DXBC_DXIL:
             *count = ARRAY_SIZE(dxbc_dxil_types);
             return dxbc_dxil_types;
-#endif
 
         case VKD3D_SHADER_SOURCE_FX:
             *count = ARRAY_SIZE(fx_types);
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index 03643acff3c..eb50da28d24 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -59,7 +59,7 @@
 #define VKD3D_VEC4_SIZE 4
 #define VKD3D_DVEC2_SIZE 2
 
-#define VKD3D_SHADER_COMPONENT_TYPE_COUNT (VKD3D_SHADER_COMPONENT_UINT64 + 1)
+#define VKD3D_SHADER_COMPONENT_TYPE_COUNT (VKD3D_SHADER_COMPONENT_INT16 + 1)
 #define VKD3D_SHADER_MINIMUM_PRECISION_COUNT (VKD3D_SHADER_MINIMUM_PRECISION_UINT_16 + 1)
 
 #define VKD3D_MAX_STREAM_COUNT 4
@@ -74,6 +74,8 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_DXBC_INVALID_CHUNK_SIZE          = 6,
     VKD3D_SHADER_ERROR_DXBC_OUT_OF_MEMORY               = 7,
     VKD3D_SHADER_ERROR_DXBC_INVALID_SIGNATURE           = 8,
+    VKD3D_SHADER_ERROR_DXBC_INVALID_STRING_REFERENCE    = 9,
+    VKD3D_SHADER_ERROR_DXBC_INVALID_COMPONENT_TYPE      = 10,
 
     VKD3D_SHADER_ERROR_TPF_MISMATCHED_CF                = 1000,
     VKD3D_SHADER_ERROR_TPF_INVALID_REGISTER_RANGE       = 1001,
@@ -261,6 +263,8 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_FX_NOT_IMPLEMENTED               = 11000,
     VKD3D_SHADER_ERROR_FX_INVALID_VERSION               = 11001,
     VKD3D_SHADER_ERROR_FX_INVALID_DATA                  = 11002,
+    VKD3D_SHADER_ERROR_FX_INVALID_SIZE                  = 11003,
+    VKD3D_SHADER_ERROR_FX_OUT_OF_MEMORY                 = 11004,
 };
 
 enum vkd3d_shader_opcode
diff --git a/libs/vkd3d/libs/vkd3d-utils/vkd3d_utils_main.c b/libs/vkd3d/libs/vkd3d-utils/vkd3d_utils_main.c
index 62dd5f69f77..d59a133c3d4 100644
--- a/libs/vkd3d/libs/vkd3d-utils/vkd3d_utils_main.c
+++ b/libs/vkd3d/libs/vkd3d-utils/vkd3d_utils_main.c
@@ -19,6 +19,8 @@
 #include "vkd3d_utils_private.h"
 #undef D3D12CreateDevice
 
+/* VKD3D_DEBUG_ENV_NAME("VKD3D_DEBUG"); */
+
 static const char *debug_d3d_blob_part(D3D_BLOB_PART part)
 {
     switch (part)
diff --git a/libs/vkd3d/libs/vkd3d/command.c b/libs/vkd3d/libs/vkd3d/command.c
index ce0c3b9128f..1ff58f97565 100644
--- a/libs/vkd3d/libs/vkd3d/command.c
+++ b/libs/vkd3d/libs/vkd3d/command.c
@@ -1499,7 +1499,7 @@ static VkDescriptorPool d3d12_command_allocator_allocate_descriptor_pool(
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     struct VkDescriptorPoolCreateInfo pool_desc;
     VkDevice vk_device = device->vk_device;
-    VkDescriptorPoolSize vk_pool_sizes[2];
+    VkDescriptorPoolSize vk_pool_sizes[4];
     unsigned int pool_size, pool_limit;
     VkDescriptorPool vk_pool;
     VkResult vr;
@@ -1530,21 +1530,43 @@ static VkDescriptorPool d3d12_command_allocator_allocate_descriptor_pool(
         }
         descriptor_count = pool_size;
 
-        vk_pool_sizes[0].type = vk_descriptor_type_from_vkd3d_descriptor_type(descriptor_type, true);
-        vk_pool_sizes[0].descriptorCount = descriptor_count;
-
-        vk_pool_sizes[1].type = vk_descriptor_type_from_vkd3d_descriptor_type(descriptor_type, false);
-        vk_pool_sizes[1].descriptorCount = descriptor_count;
-
         pool_desc.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
         pool_desc.pNext = NULL;
         pool_desc.flags = 0;
         pool_desc.maxSets = 512;
-        pool_desc.poolSizeCount = 1;
-        if (vk_pool_sizes[1].type != vk_pool_sizes[0].type)
-            ++pool_desc.poolSizeCount;
         pool_desc.pPoolSizes = vk_pool_sizes;
 
+        if (allocator->device->use_vk_heaps)
+        {
+            /* SRV root descriptors. */
+            vk_pool_sizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER;
+            vk_pool_sizes[0].descriptorCount = descriptor_count;
+
+            /* UAV root descriptors and UAV counters. */
+            vk_pool_sizes[1].type = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
+            vk_pool_sizes[1].descriptorCount = descriptor_count;
+
+            /* CBV root descriptors. */
+            vk_pool_sizes[2].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
+            vk_pool_sizes[2].descriptorCount = descriptor_count;
+
+            /* Static samplers. */
+            vk_pool_sizes[3].type = VK_DESCRIPTOR_TYPE_SAMPLER;
+            vk_pool_sizes[3].descriptorCount = descriptor_count;
+
+            pool_desc.poolSizeCount = 4;
+        }
+        else
+        {
+            vk_pool_sizes[0].type = vk_descriptor_type_from_vkd3d_descriptor_type(descriptor_type, true);
+            vk_pool_sizes[0].descriptorCount = descriptor_count;
+
+            vk_pool_sizes[1].type = vk_descriptor_type_from_vkd3d_descriptor_type(descriptor_type, false);
+            vk_pool_sizes[1].descriptorCount = descriptor_count;
+
+            pool_desc.poolSizeCount = 1 + (vk_pool_sizes[0].type != vk_pool_sizes[1].type);
+        }
+
         if ((vr = VK_CALL(vkCreateDescriptorPool(vk_device, &pool_desc, NULL, &vk_pool))) < 0)
         {
             ERR("Failed to create descriptor pool, vr %d.\n", vr);
@@ -1578,6 +1600,10 @@ static VkDescriptorSet d3d12_command_allocator_allocate_descriptor_set(struct d3
     VkDescriptorSet vk_descriptor_set;
     VkResult vr;
 
+    /* With Vulkan heaps we use just one descriptor pool. */
+    if (device->use_vk_heaps)
+        descriptor_type = 0;
+
     if (!allocator->vk_descriptor_pools[descriptor_type])
         allocator->vk_descriptor_pools[descriptor_type] = d3d12_command_allocator_allocate_descriptor_pool(allocator,
                 descriptor_type, descriptor_count, unbounded);
@@ -2222,7 +2248,7 @@ static bool vk_barrier_parameters_from_d3d12_resource_state(unsigned int state,
                 if (!stencil_state || (stencil_state & D3D12_RESOURCE_STATE_DEPTH_WRITE))
                     *image_layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
                 else
-                    *image_layout = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
+                    *image_layout = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR;
             }
             return true;
 
@@ -2256,7 +2282,7 @@ static bool vk_barrier_parameters_from_d3d12_resource_state(unsigned int state,
             {
                 if (stencil_state & D3D12_RESOURCE_STATE_DEPTH_WRITE)
                 {
-                    *image_layout = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
+                    *image_layout = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR;
                     *access_mask |= VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
                 }
                 else
diff --git a/libs/vkd3d/libs/vkd3d/device.c b/libs/vkd3d/libs/vkd3d/device.c
index b51e2963efa..15affcee9cb 100644
--- a/libs/vkd3d/libs/vkd3d/device.c
+++ b/libs/vkd3d/libs/vkd3d/device.c
@@ -73,6 +73,7 @@ static const struct vkd3d_optional_extension_info optional_instance_extensions[]
 static const char * const required_device_extensions[] =
 {
     VK_KHR_MAINTENANCE1_EXTENSION_NAME,
+    VK_KHR_MAINTENANCE2_EXTENSION_NAME,
     VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME,
 };
 
@@ -91,12 +92,12 @@ static const struct vkd3d_optional_extension_info optional_device_extensions[] =
     VK_EXTENSION(KHR_DRAW_INDIRECT_COUNT, KHR_draw_indirect_count),
     VK_EXTENSION(KHR_GET_MEMORY_REQUIREMENTS_2, KHR_get_memory_requirements2),
     VK_EXTENSION(KHR_IMAGE_FORMAT_LIST, KHR_image_format_list),
-    VK_EXTENSION(KHR_MAINTENANCE2, KHR_maintenance2),
     VK_EXTENSION(KHR_MAINTENANCE3, KHR_maintenance3),
     VK_EXTENSION(KHR_PORTABILITY_SUBSET, KHR_portability_subset),
     VK_EXTENSION(KHR_PUSH_DESCRIPTOR, KHR_push_descriptor),
     VK_EXTENSION(KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE, KHR_sampler_mirror_clamp_to_edge),
     VK_EXTENSION(KHR_TIMELINE_SEMAPHORE, KHR_timeline_semaphore),
+    VK_EXTENSION(KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY, KHR_zero_initialize_workgroup_memory),
     /* EXT extensions */
     VK_EXTENSION(EXT_4444_FORMATS, EXT_4444_formats),
     VK_EXTENSION(EXT_CALIBRATED_TIMESTAMPS, EXT_calibrated_timestamps),
@@ -520,7 +521,26 @@ static VkBool32 VKAPI_PTR vkd3d_debug_report_callback(VkDebugReportFlagsEXT flag
         VkDebugReportObjectTypeEXT object_type, uint64_t object, size_t location,
         int32_t message_code, const char *layer_prefix, const char *message, void *user_data)
 {
-    FIXME("%s\n", debugstr_a(message));
+    while (*message)
+    {
+        const char *end = strchr(message, '\n');
+        size_t len;
+
+        if (end)
+            len = end - message;
+        else
+            len = strlen(message);
+
+        len = min(len, 256);
+
+        FIXME("%s\n", debugstr_an(message, len));
+
+        message += len;
+
+        if (*message == '\n')
+            ++message;
+    }
+
     return VK_FALSE;
 }
 
@@ -835,6 +855,7 @@ struct vkd3d_physical_device_info
     VkPhysicalDeviceTimelineSemaphoreFeaturesKHR timeline_semaphore_features;
     VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT mutable_features;
     VkPhysicalDevice4444FormatsFeaturesEXT formats4444_features;
+    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR zero_initialize_workgroup_memory_features;
 
     VkPhysicalDeviceFeatures2 features2;
 };
@@ -870,6 +891,8 @@ static void vkd3d_chain_physical_device_info_structures(struct vkd3d_physical_de
         vk_prepend_struct(&info->features2, &info->mutable_features);
     if (vulkan_info->EXT_4444_formats)
         vk_prepend_struct(&info->features2, &info->formats4444_features);
+    if (vulkan_info->KHR_zero_initialize_workgroup_memory)
+        vk_prepend_struct(&info->features2, &info->zero_initialize_workgroup_memory_features);
 
     info->properties2.pNext = NULL;
 
@@ -908,6 +931,7 @@ static void vkd3d_physical_device_info_init(struct vkd3d_physical_device_info *i
     info->timeline_semaphore_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR;
     info->mutable_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
     info->formats4444_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
+    info->zero_initialize_workgroup_memory_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR;
 
     info->properties2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
     info->maintenance3_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
@@ -1418,6 +1442,9 @@ static void vkd3d_init_feature_level(struct vkd3d_vulkan_info *vk_info,
     else if (!vk_info->vertex_attrib_zero_divisor)
         WARN("Vertex attribute instance rate zero divisor is not supported.\n");
 
+    if (!vk_info->KHR_zero_initialize_workgroup_memory)
+        WARN("Shader zero initialize workgroup memory is not supported.\n");
+
 #undef CHECK_MIN_REQUIREMENT
 #undef CHECK_MAX_REQUIREMENT
 #undef CHECK_FEATURE
@@ -1834,6 +1861,8 @@ static HRESULT vkd3d_init_device_caps(struct d3d12_device *device,
         vulkan_info->EXT_mutable_descriptor_type = false;
     if (!physical_device_info->timeline_semaphore_features.timelineSemaphore)
         vulkan_info->KHR_timeline_semaphore = false;
+    if (!physical_device_info->zero_initialize_workgroup_memory_features.shaderZeroInitializeWorkgroupMemory)
+        vulkan_info->KHR_zero_initialize_workgroup_memory = false;
 
     physical_device_info->formats4444_features.formatA4B4G4R4 = VK_FALSE;
 
@@ -3610,11 +3639,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CheckFeatureSupport(ID3D12Device9
 
             TRACE("Request shader model %#x.\n", data->HighestShaderModel);
 
-#ifdef VKD3D_SHADER_UNSUPPORTED_DXIL
             data->HighestShaderModel = min(data->HighestShaderModel, D3D_SHADER_MODEL_6_0);
-#else
-            data->HighestShaderModel = min(data->HighestShaderModel, D3D_SHADER_MODEL_5_1);
-#endif
 
             TRACE("Shader model %#x.\n", data->HighestShaderModel);
             return S_OK;
diff --git a/libs/vkd3d/libs/vkd3d/resource.c b/libs/vkd3d/libs/vkd3d/resource.c
index eab97715944..cb184986f2a 100644
--- a/libs/vkd3d/libs/vkd3d/resource.c
+++ b/libs/vkd3d/libs/vkd3d/resource.c
@@ -3094,7 +3094,7 @@ bool vkd3d_create_texture_view(struct d3d12_device *device, uint32_t magic, VkIm
     if (vk_image)
     {
         view_desc.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
-        view_desc.pNext = NULL;
+        view_desc.pNext = &usage_desc;
         view_desc.flags = 0;
         view_desc.image = vk_image;
         view_desc.viewType = desc->view_type;
@@ -3107,13 +3107,11 @@ bool vkd3d_create_texture_view(struct d3d12_device *device, uint32_t magic, VkIm
         view_desc.subresourceRange.levelCount = desc->miplevel_count;
         view_desc.subresourceRange.baseArrayLayer = desc->layer_idx;
         view_desc.subresourceRange.layerCount = desc->layer_count;
-        if (device->vk_info.KHR_maintenance2)
-        {
-            usage_desc.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
-            usage_desc.pNext = NULL;
-            usage_desc.usage = desc->usage;
-            view_desc.pNext = &usage_desc;
-        }
+
+        usage_desc.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
+        usage_desc.pNext = NULL;
+        usage_desc.usage = desc->usage;
+
         if ((vr = VK_CALL(vkCreateImageView(device->vk_device, &view_desc, NULL, &vk_view))) < 0)
         {
             WARN("Failed to create Vulkan image view, vr %d.\n", vr);
diff --git a/libs/vkd3d/libs/vkd3d/state.c b/libs/vkd3d/libs/vkd3d/state.c
index aa08dc985bd..a1f09422305 100644
--- a/libs/vkd3d/libs/vkd3d/state.c
+++ b/libs/vkd3d/libs/vkd3d/state.c
@@ -754,8 +754,11 @@ struct vkd3d_descriptor_set_context
     unsigned int uav_counter_index;
     unsigned int push_constant_index;
 
-    struct vk_binding_array *push_descriptor_set;
+    struct vk_binding_array *root_descriptor_set;
+    struct vk_binding_array *static_samplers_descriptor_set;
     bool push_descriptor;
+    bool static_samplers;
+    bool use_vk_heaps;
 };
 
 static void descriptor_set_context_cleanup(struct vkd3d_descriptor_set_context *context)
@@ -806,13 +809,59 @@ static struct vk_binding_array *d3d12_root_signature_vk_binding_array_for_type(
 {
     struct vk_binding_array *array, **current;
 
+    /* There are a few different ways we can reach this point:
+     *  * If we are using virtual heaps we want to allocate descriptors to sets
+     *    depending on their descriptor type, in order to minimize waste when
+     *    recycling descriptor pools.
+     *    + With the exception of root descriptors when we are using push
+     *      descriptors: the push descriptors must be in a separate set, so we
+     *      keep one specifically for them.
+     *  * If we are using Vulkan heaps then all the root table descriptors don't
+     *    even reach here, because they are managed by the D3D12 descriptor
+     *    heap. Thus we only have to deal with root descriptors and static
+     *    samplers.
+     *    + If we're using push descriptors then again we have to dedicate a set
+     *      for them, so static samplers will and up in their own set too.
+     *    + If we're not using push descriptors then we can use the same set and
+     *      save one. In this case we don't care too much about minimizing
+     *      wasted descriptors, because few descriptors can end up here anyway.
+     */
+
     if (context->push_descriptor)
     {
-        if (!context->push_descriptor_set)
-            context->push_descriptor_set = d3d12_root_signature_append_vk_binding_array(root_signature,
-                    descriptor_type, VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, context);
+        /* The descriptor type is irrelevant here, it will never be used. */
+        if (!context->root_descriptor_set)
+            context->root_descriptor_set = d3d12_root_signature_append_vk_binding_array(root_signature,
+                    0, VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, context);
+
+        return context->root_descriptor_set;
+    }
+
+    if (context->use_vk_heaps)
+    {
+        if (context->static_samplers)
+        {
+            if (!context->static_samplers_descriptor_set)
+            {
+                if (!context->push_descriptor && context->root_descriptor_set)
+                    context->static_samplers_descriptor_set = context->root_descriptor_set;
+                else
+                    /* The descriptor type is irrelevant here, it will never be used. */
+                    context->static_samplers_descriptor_set = d3d12_root_signature_append_vk_binding_array(
+                            root_signature, 0, 0, context);
+            }
+
+            return context->static_samplers_descriptor_set;
+        }
+        else
+        {
+            /* The descriptor type is irrelevant here, it will never be used. */
+            if (!context->root_descriptor_set)
+                context->root_descriptor_set = d3d12_root_signature_append_vk_binding_array(
+                        root_signature, 0, 0, context);
 
-        return context->push_descriptor_set;
+            return context->root_descriptor_set;
+        }
     }
 
     current = context->current_binding_array;
@@ -1638,17 +1687,22 @@ static HRESULT d3d12_root_signature_init(struct d3d12_root_signature *root_signa
             sizeof(*root_signature->static_samplers))))
         goto fail;
 
+    context.use_vk_heaps = use_vk_heaps;
     context.push_descriptor = vk_info->KHR_push_descriptor;
     if (FAILED(hr = d3d12_root_signature_init_root_descriptors(root_signature, desc, &context)))
         goto fail;
-    root_signature->main_set = !!context.push_descriptor_set;
+    root_signature->main_set = context.root_descriptor_set && context.push_descriptor;
     context.push_descriptor = false;
 
     if (FAILED(hr = d3d12_root_signature_init_push_constants(root_signature, desc,
             root_signature->push_constant_ranges, &root_signature->push_constant_range_count)))
         goto fail;
+
+    context.static_samplers = true;
     if (FAILED(hr = d3d12_root_signature_init_static_samplers(root_signature, device, desc, &context)))
         goto fail;
+    context.static_samplers = false;
+
     context.push_constant_index = 0;
     if (FAILED(hr = d3d12_root_signature_init_root_descriptor_tables(root_signature, desc, &info, &context)))
         goto fail;
@@ -2316,6 +2370,8 @@ static unsigned int feature_flags_compile_option(const struct d3d12_device *devi
         flags |= VKD3D_SHADER_COMPILE_OPTION_FEATURE_FLOAT64;
     if (device->feature_options1.WaveOps)
         flags |= VKD3D_SHADER_COMPILE_OPTION_FEATURE_WAVE_OPS;
+    if (device->vk_info.KHR_zero_initialize_workgroup_memory)
+        flags |= VKD3D_SHADER_COMPILE_OPTION_FEATURE_ZERO_INITIALIZE_WORKGROUP_MEMORY;
 
     return flags;
 }
@@ -3146,13 +3202,13 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     struct vkd3d_shader_spirv_target_info *stage_target_info;
     uint32_t aligned_offsets[D3D12_VS_INPUT_REGISTER_COUNT];
     struct vkd3d_shader_descriptor_offset_info offset_info;
+    struct vkd3d_shader_scan_signature_info signature_info;
     struct vkd3d_shader_parameter ps_shader_parameters[1];
     struct vkd3d_shader_transform_feedback_info xfb_info;
     struct vkd3d_shader_spirv_target_info ps_target_info;
     struct vkd3d_shader_interface_info shader_interface;
     struct vkd3d_shader_spirv_target_info target_info;
-    const struct d3d12_root_signature *root_signature;
-    struct vkd3d_shader_signature input_signature;
+    struct d3d12_root_signature *root_signature;
     bool have_attachment, is_dsv_format_unknown;
     VkShaderStageFlagBits xfb_stage = 0;
     VkSampleCountFlagBits sample_count;
@@ -3163,7 +3219,6 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     size_t rt_count;
     uint32_t mask;
     HRESULT hr;
-    int ret;
 
     static const DWORD default_ps_code[] =
     {
@@ -3196,7 +3251,8 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     memset(&state->uav_counters, 0, sizeof(state->uav_counters));
     graphics->stage_count = 0;
 
-    memset(&input_signature, 0, sizeof(input_signature));
+    memset(&signature_info, 0, sizeof(signature_info));
+    signature_info.type = VKD3D_SHADER_STRUCTURE_TYPE_SCAN_SIGNATURE_INFO;
 
     for (i = desc->rtv_formats.NumRenderTargets; i < ARRAY_SIZE(desc->rtv_formats.RTFormats); ++i)
     {
@@ -3207,10 +3263,25 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         }
     }
 
+    state->implicit_root_signature = NULL;
     if (!(root_signature = unsafe_impl_from_ID3D12RootSignature(desc->root_signature)))
     {
-        WARN("Root signature is NULL.\n");
-        return E_INVALIDARG;
+        TRACE("Root signature is NULL, looking for an embedded signature in the vertex shader.\n");
+        if (FAILED(hr = d3d12_root_signature_create(device,
+                desc->vs.pShaderBytecode, desc->vs.BytecodeLength, &root_signature))
+                && FAILED(hr = d3d12_root_signature_create(device,
+                desc->ps.pShaderBytecode, desc->ps.BytecodeLength, &root_signature))
+                && FAILED(hr = d3d12_root_signature_create(device,
+                desc->ds.pShaderBytecode, desc->ds.BytecodeLength, &root_signature))
+                && FAILED(hr = d3d12_root_signature_create(device,
+                desc->hs.pShaderBytecode, desc->hs.BytecodeLength, &root_signature))
+                && FAILED(hr = d3d12_root_signature_create(device,
+                desc->gs.pShaderBytecode, desc->gs.BytecodeLength, &root_signature)))
+        {
+            WARN("Failed to find an embedded root signature, hr %s.\n", debugstr_hresult(hr));
+            goto fail;
+        }
+        state->implicit_root_signature = &root_signature->ID3D12RootSignature_iface;
     }
 
     sample_count = vk_samples_from_dxgi_sample_desc(&desc->sample_desc);
@@ -3425,7 +3496,6 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     for (i = 0; i < ARRAY_SIZE(shader_stages); ++i)
     {
         const D3D12_SHADER_BYTECODE *b = (const void *)((uintptr_t)desc + shader_stages[i].offset);
-        const struct vkd3d_shader_code dxbc = {b->pShaderBytecode, b->BytecodeLength};
 
         if (!b->pShaderBytecode)
             continue;
@@ -3439,14 +3509,6 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         stage_target_info = &target_info;
         switch (shader_stages[i].stage)
         {
-            case VK_SHADER_STAGE_VERTEX_BIT:
-                if ((ret = vkd3d_shader_parse_input_signature(&dxbc, &input_signature, NULL)) < 0)
-                {
-                    hr = hresult_from_vkd3d_result(ret);
-                    goto fail;
-                }
-                break;
-
             case VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT:
             case VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT:
                 if (desc->primitive_topology_type != D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH)
@@ -3457,6 +3519,7 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
                 }
                 break;
 
+            case VK_SHADER_STAGE_VERTEX_BIT:
             case VK_SHADER_STAGE_GEOMETRY_BIT:
                 break;
 
@@ -3478,11 +3541,14 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
         ps_target_info.next = NULL;
         target_info.next = NULL;
         offset_info.next = NULL;
+        signature_info.next = NULL;
         if (shader_stages[i].stage == xfb_stage)
             vkd3d_prepend_struct(&shader_interface, &xfb_info);
         vkd3d_prepend_struct(&shader_interface, stage_target_info);
         if (root_signature->descriptor_offsets)
             vkd3d_prepend_struct(&shader_interface, &offset_info);
+        if (shader_stages[i].stage == VK_SHADER_STAGE_VERTEX_BIT)
+            vkd3d_prepend_struct(&shader_interface, &signature_info);
 
         if (FAILED(hr = create_shader_stage(device, &graphics->stages[graphics->stage_count],
                 shader_stages[i].stage, b, &shader_interface)))
@@ -3533,7 +3599,7 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
             goto fail;
         }
 
-        if (!(signature_element = vkd3d_shader_find_signature_element(&input_signature,
+        if (!(signature_element = vkd3d_shader_find_signature_element(&signature_info.input,
                 e->SemanticName, e->SemanticIndex, 0)))
         {
             WARN("Unused input element %u.\n", i);
@@ -3660,19 +3726,21 @@ static HRESULT d3d12_pipeline_state_init_graphics(struct d3d12_pipeline_state *s
     if (FAILED(hr = vkd3d_private_store_init(&state->private_store)))
         goto fail;
 
-    vkd3d_shader_free_shader_signature(&input_signature);
+    vkd3d_shader_free_scan_signature_info(&signature_info);
     state->vk_bind_point = VK_PIPELINE_BIND_POINT_GRAPHICS;
-    state->implicit_root_signature = NULL;
     d3d12_device_add_ref(state->device = device);
 
     return S_OK;
 
 fail:
+    if (state->implicit_root_signature)
+        ID3D12RootSignature_Release(state->implicit_root_signature);
+
     for (i = 0; i < graphics->stage_count; ++i)
     {
         VK_CALL(vkDestroyShaderModule(device->vk_device, state->u.graphics.stages[i].module, NULL));
     }
-    vkd3d_shader_free_shader_signature(&input_signature);
+    vkd3d_shader_free_scan_signature_info(&signature_info);
 
     d3d12_pipeline_uav_counter_state_cleanup(&state->uav_counters, device);
 
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
index fd1fbb1679a..e0e44248053 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -127,12 +127,12 @@ struct vkd3d_vulkan_info
     bool KHR_draw_indirect_count;
     bool KHR_get_memory_requirements2;
     bool KHR_image_format_list;
-    bool KHR_maintenance2;
     bool KHR_maintenance3;
     bool KHR_portability_subset;
     bool KHR_push_descriptor;
     bool KHR_sampler_mirror_clamp_to_edge;
     bool KHR_timeline_semaphore;
+    bool KHR_zero_initialize_workgroup_memory;
     /* EXT device extensions */
     bool EXT_4444_formats;
     bool EXT_calibrated_timestamps;
-- 
2.47.2

