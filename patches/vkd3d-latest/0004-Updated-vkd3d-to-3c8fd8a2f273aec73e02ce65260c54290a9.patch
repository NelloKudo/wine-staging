From e86660db4b31e31874f35e679cf3bb3232d432f2 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 13 May 2025 07:32:01 +1000
Subject: [PATCH] Updated vkd3d to 3c8fd8a2f273aec73e02ce65260c54290a9739d6.

---
 libs/vkd3d/libs/vkd3d-shader/dxil.c | 116 ++++++++++++++++++----------
 libs/vkd3d/libs/vkd3d-shader/hlsl.c |   2 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.y |   2 +-
 3 files changed, 77 insertions(+), 43 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index da872afc265..ca79939a39b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -645,9 +645,12 @@ enum sm6_value_type
 {
     VALUE_TYPE_FUNCTION,
     VALUE_TYPE_REG,
-    VALUE_TYPE_ICB,
+    VALUE_TYPE_DATA,
     VALUE_TYPE_HANDLE,
     VALUE_TYPE_SSA,
+    VALUE_TYPE_ICB,
+    VALUE_TYPE_IDXTEMP,
+    VALUE_TYPE_GROUPSHAREDMEM,
     VALUE_TYPE_UNDEFINED,
     VALUE_TYPE_INVALID,
 };
@@ -671,6 +674,22 @@ struct sm6_ssa_data
     unsigned int id;
 };
 
+struct sm6_icb_data
+{
+    unsigned int data_id;
+    unsigned int id;
+};
+
+struct sm6_idxtemp_data
+{
+    unsigned int id;
+};
+
+struct sm6_groupsharedmem_data
+{
+    unsigned int id;
+};
+
 struct sm6_value
 {
     const struct sm6_type *type;
@@ -680,9 +699,12 @@ struct sm6_value
     union
     {
         struct sm6_function_data function;
-        const struct vkd3d_shader_immediate_constant_buffer *icb;
+        const struct vkd3d_shader_immediate_constant_buffer *data;
         struct sm6_handle_data handle;
         struct sm6_ssa_data ssa;
+        struct sm6_icb_data icb;
+        struct sm6_idxtemp_data idxtemp;
+        struct sm6_groupsharedmem_data groupsharedmem;
     } u;
     struct vkd3d_shader_register reg;
 };
@@ -2244,6 +2266,9 @@ static inline bool sm6_value_is_register(const struct sm6_value *value)
     {
         case VALUE_TYPE_REG:
         case VALUE_TYPE_SSA:
+        case VALUE_TYPE_ICB:
+        case VALUE_TYPE_IDXTEMP:
+        case VALUE_TYPE_GROUPSHAREDMEM:
         case VALUE_TYPE_UNDEFINED:
         case VALUE_TYPE_INVALID:
             return true;
@@ -2283,9 +2308,9 @@ static bool sm6_value_vector_is_constant_or_undef(const struct sm6_value **value
     return true;
 }
 
-static bool sm6_value_is_icb(const struct sm6_value *value)
+static bool sm6_value_is_data(const struct sm6_value *value)
 {
-    return value->value_type == VALUE_TYPE_ICB;
+    return value->value_type == VALUE_TYPE_DATA;
 }
 
 static bool sm6_value_is_ssa(const struct sm6_value *value)
@@ -2425,6 +2450,18 @@ static void sm6_register_from_value(struct vkd3d_shader_register *reg, const str
             reg->dimension = sm6_type_is_scalar(value->type) ? VSIR_DIMENSION_SCALAR : VSIR_DIMENSION_VEC4;
             break;
 
+        case VALUE_TYPE_ICB:
+            register_init_with_id(reg, VKD3DSPR_IMMCONSTBUFFER, data_type, value->u.icb.id);
+            break;
+
+        case VALUE_TYPE_IDXTEMP:
+            register_init_with_id(reg, VKD3DSPR_IDXTEMP, data_type, value->u.idxtemp.id);
+            break;
+
+        case VALUE_TYPE_GROUPSHAREDMEM:
+            register_init_with_id(reg, VKD3DSPR_GROUPSHAREDMEM, data_type, value->u.groupsharedmem.id);
+            break;
+
         case VALUE_TYPE_UNDEFINED:
         case VALUE_TYPE_INVALID:
             vsir_register_init(reg, VKD3DSPR_UNDEF, data_type, 0);
@@ -2432,7 +2469,7 @@ static void sm6_register_from_value(struct vkd3d_shader_register *reg, const str
 
         case VALUE_TYPE_FUNCTION:
         case VALUE_TYPE_HANDLE:
-        case VALUE_TYPE_ICB:
+        case VALUE_TYPE_DATA:
             vkd3d_unreachable();
     }
 }
@@ -3021,13 +3058,6 @@ static float register_get_float_value(const struct vkd3d_shader_register *reg)
     return bitcast_uint_to_float(reg->u.immconst_u32[0]);
 }
 
-static inline float sm6_value_get_constant_float(const struct sm6_value *value)
-{
-    if (!sm6_value_is_constant(value))
-        return UINT_MAX;
-    return register_get_float_value(&value->reg);
-}
-
 static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, const struct sm6_type *type,
         const uint64_t *operands, struct sm6_parser *sm6)
 {
@@ -3072,8 +3102,8 @@ static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, co
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
 
-    dst->value_type = VALUE_TYPE_ICB;
-    dst->u.icb = icb;
+    dst->value_type = VALUE_TYPE_DATA;
+    dst->u.data = icb;
 
     icb->register_idx = sm6->icb_count++;
     icb->data_type = vkd3d_data_type_from_sm6_type(elem_type);
@@ -3477,13 +3507,13 @@ static struct vkd3d_shader_instruction *sm6_parser_add_instruction(struct sm6_pa
 static void sm6_parser_declare_icb(struct sm6_parser *sm6, const struct sm6_type *elem_type, unsigned int count,
         unsigned int alignment, unsigned int init, struct sm6_value *dst)
 {
-    enum vkd3d_data_type data_type = vkd3d_data_type_from_sm6_type(elem_type);
     struct vkd3d_shader_instruction *ins;
 
     ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_IMMEDIATE_CONSTANT_BUFFER);
     /* The icb value index will be resolved later so forward references can be handled. */
     ins->declaration.icb = (void *)(intptr_t)init;
-    register_init_with_id(&dst->reg, VKD3DSPR_IMMCONSTBUFFER, data_type, init);
+    dst->value_type = VALUE_TYPE_ICB;
+    dst->u.icb.data_id = init;
 }
 
 static void sm6_parser_declare_indexable_temp(struct sm6_parser *sm6, const struct sm6_type *elem_type,
@@ -3505,21 +3535,24 @@ static void sm6_parser_declare_indexable_temp(struct sm6_parser *sm6, const stru
     /* The initialiser value index will be resolved later so forward references can be handled. */
     ins->declaration.indexable_temp.initialiser = (void *)(uintptr_t)init;
 
-    register_init_with_id(&dst->reg, VKD3DSPR_IDXTEMP, data_type, ins->declaration.indexable_temp.register_idx);
+    dst->value_type = VALUE_TYPE_IDXTEMP;
+    dst->u.idxtemp.id = ins->declaration.indexable_temp.register_idx;
+    sm6_register_from_value(&dst->reg, dst);
 }
 
 static void sm6_parser_declare_tgsm_raw(struct sm6_parser *sm6, const struct sm6_type *elem_type,
         unsigned int alignment, unsigned int init, struct sm6_value *dst)
 {
-    enum vkd3d_data_type data_type = vkd3d_data_type_from_sm6_type(elem_type);
     struct vkd3d_shader_instruction *ins;
     unsigned int byte_count;
 
     ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_TGSM_RAW);
     dst_param_init(&ins->declaration.tgsm_raw.reg);
-    register_init_with_id(&ins->declaration.tgsm_raw.reg.reg, VKD3DSPR_GROUPSHAREDMEM, data_type, sm6->tgsm_count++);
-    dst->reg = ins->declaration.tgsm_raw.reg.reg;
+    dst->value_type = VALUE_TYPE_GROUPSHAREDMEM;
+    dst->u.groupsharedmem.id = sm6->tgsm_count++;
     dst->structure_stride = 0;
+    sm6_register_from_value(&dst->reg, dst);
+    sm6_register_from_value(&ins->declaration.tgsm_raw.reg.reg, dst);
     ins->declaration.tgsm_raw.alignment = alignment;
     byte_count = elem_type->u.width / 8u;
     if (byte_count != 4)
@@ -3536,25 +3569,23 @@ static void sm6_parser_declare_tgsm_raw(struct sm6_parser *sm6, const struct sm6
 static void sm6_parser_declare_tgsm_structured(struct sm6_parser *sm6, const struct sm6_type *elem_type,
         unsigned int count, unsigned int alignment, unsigned int init, struct sm6_value *dst)
 {
-    enum vkd3d_data_type data_type = vkd3d_data_type_from_sm6_type(elem_type);
     struct vkd3d_shader_instruction *ins;
-    unsigned int structure_stride;
 
     ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_TGSM_STRUCTURED);
     dst_param_init(&ins->declaration.tgsm_structured.reg);
-    register_init_with_id(&ins->declaration.tgsm_structured.reg.reg, VKD3DSPR_GROUPSHAREDMEM,
-            data_type, sm6->tgsm_count++);
-    dst->reg = ins->declaration.tgsm_structured.reg.reg;
-    structure_stride = elem_type->u.width / 8u;
-    if (structure_stride != 4)
+    dst->value_type = VALUE_TYPE_GROUPSHAREDMEM;
+    dst->u.groupsharedmem.id = sm6->tgsm_count++;
+    dst->structure_stride = elem_type->u.width / 8u;
+    sm6_register_from_value(&dst->reg, dst);
+    sm6_register_from_value(&ins->declaration.tgsm_structured.reg.reg, dst);
+    if (dst->structure_stride != 4)
     {
-        FIXME("Unsupported structure stride %u.\n", structure_stride);
+        FIXME("Unsupported structure stride %u.\n", dst->structure_stride);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                "Structured TGSM byte stride %u is not supported.", structure_stride);
+                "Structured TGSM byte stride %u is not supported.", dst->structure_stride);
     }
-    dst->structure_stride = structure_stride;
     ins->declaration.tgsm_structured.alignment = alignment;
-    ins->declaration.tgsm_structured.byte_stride = structure_stride;
+    ins->declaration.tgsm_structured.byte_stride = dst->structure_stride;
     ins->declaration.tgsm_structured.structure_count = count;
     /* The initialiser value index will be resolved later when forward references can be handled. */
     ins->flags = init;
@@ -3717,16 +3748,16 @@ static const struct vkd3d_shader_immediate_constant_buffer *resolve_forward_init
 
     VKD3D_ASSERT(index);
     --index;
-    if (!(value = sm6_parser_get_value_safe(sm6, index)) || (!sm6_value_is_icb(value) && !sm6_value_is_undef(value)))
+    if (!(value = sm6_parser_get_value_safe(sm6, index)) || (!sm6_value_is_data(value) && !sm6_value_is_undef(value)))
     {
         WARN("Invalid initialiser index %zu.\n", index);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Global variable initialiser value index %zu is invalid.", index);
         return NULL;
     }
-    else if (sm6_value_is_icb(value))
+    else if (sm6_value_is_data(value))
     {
-        return value->u.icb;
+        return value->u.data;
     }
     /* In VSIR, initialisation with undefined values of objects is implied, not explicit. */
     return NULL;
@@ -3741,14 +3772,14 @@ static bool resolve_forward_zero_initialiser(size_t index, struct sm6_parser *sm
 
     --index;
     if (!(value = sm6_parser_get_value_safe(sm6, index))
-            || (!sm6_value_is_icb(value) && !sm6_value_is_constant(value) && !sm6_value_is_undef(value)))
+            || (!sm6_value_is_data(value) && !sm6_value_is_constant(value) && !sm6_value_is_undef(value)))
     {
         WARN("Invalid initialiser index %zu.\n", index);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "TGSM initialiser value index %zu is invalid.", index);
         return false;
     }
-    else if ((sm6_value_is_icb(value) && value->u.icb->is_null) || sm6_value_is_constant_zero(value))
+    else if ((sm6_value_is_data(value) && value->u.data->is_null) || sm6_value_is_constant_zero(value))
     {
         return true;
     }
@@ -3853,11 +3884,14 @@ static enum vkd3d_result sm6_parser_globals_init(struct sm6_parser *sm6)
         const struct vkd3d_shader_immediate_constant_buffer *icb;
         struct sm6_value *value = &sm6->values[i];
 
-        if (!sm6_value_is_register(value) || value->reg.type != VKD3DSPR_IMMCONSTBUFFER)
+        if (value->value_type != VALUE_TYPE_ICB)
             continue;
 
-        if ((icb = resolve_forward_initialiser(value->reg.idx[0].offset, sm6)))
-            value->reg.idx[0].offset = icb->register_idx;
+        if ((icb = resolve_forward_initialiser(value->u.icb.data_id, sm6)))
+            value->u.icb.id = icb->register_idx;
+        else
+            value->u.icb.id = 0;
+        sm6_register_from_value(&value->reg, value);
     }
 
     return VKD3D_OK;
@@ -7732,7 +7766,7 @@ static bool sm6_metadata_get_float_value(const struct sm6_parser *sm6,
     if (!sm6_type_is_floating_point(value->type))
         return false;
 
-    *f = sm6_value_get_constant_float(value);
+    *f = register_get_float_value(&value->reg);
 
     return true;
 }
@@ -8610,7 +8644,7 @@ static enum vkd3d_result sm6_parser_metadata_init(struct sm6_parser *sm6, const
                 if (!(value = sm6_parser_get_value_safe(sm6, value_idx)))
                     return VKD3D_ERROR_INVALID_SHADER;
 
-                if (!sm6_value_is_constant(value) && !sm6_value_is_undef(value) && !sm6_value_is_icb(value)
+                if (!sm6_value_is_constant(value) && !sm6_value_is_undef(value) && !sm6_value_is_data(value)
                         && !sm6_value_is_function_dcl(value))
                 {
                     WARN("Value at index %u is not a constant or a function declaration.\n", value_idx);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 0f9aafbe13e..36c79f4c076 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -2687,7 +2687,7 @@ static struct hlsl_ir_node *clone_interlocked(struct hlsl_ctx *ctx,
 
     if (!(dst = hlsl_alloc(ctx, sizeof(*dst))))
         return NULL;
-    init_node(&dst->node, HLSL_IR_INTERLOCKED, NULL, &src->node.loc);
+    init_node(&dst->node, HLSL_IR_INTERLOCKED, src->node.data_type, &src->node.loc);
     dst->op = src->op;
 
     if (!clone_deref(ctx, map, &dst->dst, &src->dst))
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index 05657d27b38..24c7ae6b00b 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -4932,7 +4932,7 @@ static bool intrinsic_GetRenderTargetSampleCount(struct hlsl_ctx *ctx,
                 "GetRenderTargetSampleCount() can only be used from a pixel shader using version 4.1 or higher.");
 
     hlsl_block_add_expr(ctx, params->instrs, HLSL_OP0_RASTERIZER_SAMPLE_COUNT,
-            operands, hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), loc);
+            operands, hlsl_get_vector_type(ctx, HLSL_TYPE_UINT, 1), loc);
     return true;
 }
 
-- 
2.47.2

